<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[Gatsby Starter Blog RSS Feed]]></description><link>http://github.com/dylang/node-rss</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 27 Aug 2023 08:01:38 GMT</lastBuildDate><item><title><![CDATA[개발자가 된 이유]]></title><description><![CDATA[…]]></description><link>null/essay/230812-why-i-become-developer/</link><guid isPermaLink="false">null/essay/230812-why-i-become-developer/</guid><pubDate>Sat, 12 Aug 2023 22:12:00 GMT</pubDate><content:encoded>&lt;h2&gt;아주 단순한 계기&lt;/h2&gt;
&lt;p&gt;어린 시절에 나는 컴퓨터를 아주 좋아하는 아이였다. 당연히 주 컨텐츠는 게임이었다. 메이플스토리, 카트라이더, 그랜드체이스를 열심히 했던 기억이 난다. 하지만 그 무렵 대부분의 내 또래가 그렇듯 하루에 사용할 수 있는 컴퓨터 시간은 정해져 있었다. 그래서 나는 어떻게 하면 컴퓨터를 원하는만큼 할 수 있을까 고민에 빠지다가 문득 한가지 생각이 뇌리를 스쳤다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;프로그래머가 된다면 하루종일 컴퓨터를 할 수 있지 않을까?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 단순무식한 발상이 내가 개발자가 되기로 마음을 먹은 최초의 계기다.&lt;br&gt;
이때 내 나이는 중2(15살), 2011년이었다.&lt;/p&gt;
&lt;p&gt;그날부로 프로그래머라는 직업에 대해서 조사하기 시작했다.&lt;br&gt;
당시에는 프로그래머(개발자)라는 직업에 대한 인식이 지금처럼 좋지만은 않았다. 대부분 야근은 많이하면서 박봉을 받는 일명 3D 직군에 속했기 때문이다. 하지만 중2 시절의 나에게는 겨우 그런 이유들 따위로 꿈을 꺾을 수는 없었다. 오히려 너무 어린 나이였기 때문에 아직 현실의 높은 벽을 마주해보지 못했기
때문일 수도 있다.&lt;/p&gt;
&lt;p&gt;다음으로 개발자가 되기 위해서는 어떻게 해야하는지 찾아 보았다.&lt;br&gt;
&lt;em&gt;&apos;프로그래머는 기본적으로 프로그래밍 언어를 사용하면서 컴퓨터와 상호작용을 하는 직업이다. 그 중에서도 가장 기본은 C언어이다.&apos;&lt;/em&gt;&lt;br&gt;
라는 맥락의 글을 읽었다. 곧바로 나의 다음 목표는 &apos;C언어 마스터&apos;로 정해졌다.&lt;/p&gt;
&lt;h2&gt;프로그래밍과의 첫 만남&lt;/h2&gt;
&lt;p&gt;요즘이야 서점이든 온라인 강의든 C언어를 비롯한 각종 프로그래밍 언어를 학습할 수 있는 방법이 널리고 널렸지만, 그 당시에 프로그래밍 입문자가 독학으로 공부할 수 있는 방법은 거의 전무했다. 그렇지만 나 같은 입문자를 구원해준, 가뭄에 콩 나듯 출시된 입문서가 한 권 있었으니 그 책이 &apos;윤성우의 열혈 C프로그래밍&apos;이었다(이 글을 쓰며 교보문고에서 검색을 해보았는데 놀랍게도 아직까지 절판되지 않고 판매량에서도 상위권에 위치하고 있었다).&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/9645d17b5cbef2076daa1e3b88e113fd/669cd/c-book.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 133.54430379746836%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAAHQklEQVR42h3PaVOTBwLA8WdmX9ROV0WqVURAtAgCchguCUeQU4TIIaByWBQU0FYEqxaP2larFVBOuQIkhMskBGISckCOJwFBqKuuttMPsDP7Zr/Df2f6+wY/obMph77SRGazIxjPCEMlO4Qq9SCqvGiUskP0x/kzkBzMkOwQAzlHGEoPYbQgFsWpJIZPShguSUJRlIBCnsBAfS7Ck4YsxiQhiElROPf7shTggzVsH57yfGy+W7Ds+gyb3xdY21qwHIvCnJuG8WwRttx07JHB2CKDsB+Lwh0dwkxpMkKTPJYO/+2sPGzD0nqZ+VA/ZnOkuAc7MUoOMicJwyQ5jLFCjiXAB3thJgNtF3jadZ3BaxUsf1PBG62KpeI85muyEc5nhPL06wBWj0ViTY3BcXgvr/NScFUUIKYcQZnow5DUB/2hzxBjDuCVxiCW5bNyt5XltDjEbCmrN6/ibjiP6dsyhJqMMDqD9/ImxA/n7i3YA7biCvfHfiQIi+QQr2K+QnciGktWHJ7IYETpUTyp8YjxUYh5x3EW52OvLMV5rgTbpSKE81nh9Pr5ok+PQJtyGFtEIOqSfAySUKw5SThP5eCODWUh5QDaBD+M4b5oEwN4GReELjuC+ZPx6EpTcWQcY7m+GKFaFkZvsD+W7HgWEsOw+f4De0YihuNxLKZGsRwbwv18f56lfYU9KQRbdhwWWRSLecksHI9mXi5jMSsOpyQSsakMoSr5AJ2piYh11YjXLmEtPcFYVhSXW3IwTimxnS1k6MUTxu82Y+l5juX+DzhjQnFIInDLjmG98z3OTCliTBjrrbUIlemH6Y8Nx9FQw9rUBEOXiqj/qZKB6X5a2mtQjP7ImtHEqn0RjV6HRjXC5q/3EMsKsKXFY5Nns5ydiisplvd3riCck4UzLo1D3L8De8wBpi6Wo5zq42FvM7k/JfBwug3NrIZRpYIVrxuTwcTbDx9xjQ5hvlqPtTAX97XLeJsb+VffQ4TyxGAGM9Nw5KVgjghk4vtGiu+kcaGjjNJHGTxR3+XNymu8XjeTUyrahpr5afwWhokRFr9rxFFdjrexFs/9m7wfeIpwWhJEb1oyrpITLMaGMvzoJoX3pNQ8K6FD+4DVDTfv3v3Onx8/0TJWT9XzPDoMP/NtezmbFhPutlZWup6w1HSRT4/vIhRJghgKD8H24A6mK5fpqSvhWtdltAszzExO/d1cXfXgcNmp6ZNjEGf433/+i84xi8k4x3L/cxwXqnBkpPDX818Q5JL9jO7bjS1Tiu32dSbPn2Gss52+7m5criV6ersYGOjnrz/+pFFRRYf+Ae//2KRn5gmiuIzFpMdx+zpmWTIfXzxFKIrcS09sDM4zp7DKs7C3XEG0LSJ63ayvr7KxsYbVasbjcmPyzFPVXUh5ey7NPfV8eLvB5rvXuFuvYiwp5H3fY4RT4X4MHYnAdjQU69OHOO1WPBYT9iUb42MKJtVKXq940SxM0TX9mD5NOx0TD9HNzeB02vndZUV/6zpLTZfY/PkGgjxsNyNfB2M/fRLnrJr1zXXcohOPx8Xqay/z8zpMRiNK9SiPx+/TMfELI/pebnQ38VT9G5teJ5bpcUwNdbiuVCPkH9qFoqKcpcpiPEO9mK0WbFYzoujE63ExN6dBOa5ArVJiMZtYe+3BajVgWjIweKOOxfs/4BgbQF99hsWWOoS80D2MV1ViPnuK5fZHrK2vMtLXw/DwwN9dlXKM3p4uXr2aZ33dy8ePb7GYDbzUzrJQW8tCpgzj4x/RFORgaLmIkOm/lcHkZAz1VegqS9hYEXkjOrCYX6F9Oc2bNQ/zOg1e0cEfH9/hWLbyrOM3Bgf7ML3SoysqQJsrw66fQl11CkEW4MPAnl2YEg6jLcpluq+bjc01NNNqlGMKpmanMS/bmdFqePfhLRurIrZFI3arCY9nmYkMKdrjyczVnkOdFoMg9fehb58fev8daIJ3Y+7r4s2nf2NzOVlcNDHT/hh1ZQUTjZcwDvVjftHNy7ER9HotNpuZ2Xu3mfuuAXWODHViKELcl5/z/MsdTCdLmE6KwdDxCFPzFV4V5GJsqkcjz0d3Mo/B4EAmMtOZv3OLrooyZqcnWRZdWKaUqGtK0Vw6h0oWjXBkvx9DBdlMnz7Jywo5nemRzFaXYSg/zVxFKbOZaczEx6IoLkD1TRWGpnqUcTGoG+qYOnuaiRPpKAI+R5EUhqqxEkGelcTYnZsstDYxV3sGbUw47uEXrHmc6DLTmaw5x0xZMdq68+hav0N97Sqje3cztnULqoA9TMaGoTi4k4mLZxjOkSLUyhP4taGazt1fMBwRhCoyEFWgL1OHAxkL8GUkLJjhfbtQfLmNkSOhDO/xZXzndkZ3fMGw7zbGd25D6fNPxlMS6dm5HaE8OZCz0iCayxO5VhjNzdPx3C6L40ZhJD+USbgqC6YpJYjWzFCuZxykOTmImylfc18WRlvCfm5F7eVetD8PDvhw72gQ/wfRzRgw0GFfuAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;열혈 C프로그래밍&quot;
        title=&quot;&quot;
        src=&quot;/static/9645d17b5cbef2076daa1e3b88e113fd/f058b/c-book.png&quot;
        srcset=&quot;/static/9645d17b5cbef2076daa1e3b88e113fd/c26ae/c-book.png 158w,
/static/9645d17b5cbef2076daa1e3b88e113fd/6bdcf/c-book.png 315w,
/static/9645d17b5cbef2076daa1e3b88e113fd/f058b/c-book.png 630w,
/static/9645d17b5cbef2076daa1e3b88e113fd/40601/c-book.png 945w,
/static/9645d17b5cbef2076daa1e3b88e113fd/78612/c-book.png 1260w,
/static/9645d17b5cbef2076daa1e3b88e113fd/669cd/c-book.png 3024w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;
&lt;em&gt;내가 처음으로 구입한 열혈 C프로그래밍. 아직도 고이 보관 중이다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;나는 조금의 고민도 없이 바로 책을 사서 공부하기 시작했다. 그 당시에 C언어로 프로그래밍 처음 공부하는 사람들은 공감하겠지만 초기 환경 세팅하기까지 거쳐야하는 난관이 상당했다. 우스갯소리로 가장 먼저 배우는 &lt;code class=&quot;language-text&quot;&gt;&quot;Hello World!&lt;/code&gt;를 출력하기만 하면 프로그래밍 공부 고비의 절반은 넘었다는 말이 있을 정도였다.&lt;/p&gt;
&lt;p&gt;그 이유는 우선 비주얼 스튜디오를 설치해야 했는데 설치 파일이 상당히 무거울뿐더러 게임이나 일반인을 대상으로 하는 상업용 소프트웨어와 달리, 개발자를 대상으로 하는 프로그램이다보니 설치 과정이 썩 친절하기 못한 걸로 기억한다. 게다가 왠만한 컴퓨터 사양이 좋지 않고서는 실행하는데에도 시간이 1분 가까이 걸리기도 한다. 아무튼 여러 우여곡절을 겪으며 설치를 완료하고 나면 새 프로젝트(단축키 Ctrl + Shift + N) -&gt; 새 소스코드(Ctrl + Shift + A) -&gt; &lt;code class=&quot;language-text&quot;&gt;hello.c&lt;/code&gt; 파일을 생성하면 모든 준비를 마치게 된다.&lt;/p&gt;
&lt;p&gt;이제 드디어 코드를 작성할 수 있게 된다. 아주 유명한 코드인 &lt;code class=&quot;language-text&quot;&gt;printf(&apos;Hello World!&apos;);&lt;/code&gt; 를 작성하고나서 &apos;실행&apos;버튼을 누르면서 두근두근했던 심정, 콘솔창이 뜨면서 &lt;code class=&quot;language-text&quot;&gt;Hello World!&lt;/code&gt;가 적혀있는 걸 확인했을 때의 그 짜릿한 순간의 기억은 아직까지도 생생하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그 때 나는 이 일을 직업으로 삼아야 되겠다고 확신하게 되었다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그렇게 책의 내용을 하나씩 습득해나갔다. 아무도 내게 공부하라고 시킨 적도 없고 알려주지도 않았지만 프로그래밍 공부가 정말 재미있었다. 내가 작성하는 코드에 따라서 컴퓨터가 이를 해석하고 결과가 나오는 일이 신기하다고 느껴졌다. 나는 이 매력에 빠져서 주말마다 게임 대신에 C언어 공부를 했다.&lt;br&gt;
비록 포인터를 공부할 때 살짝 위기가 찾아오기는 했지만 이해가 안 될때는 두번 세번이고 반복하면서 익숙해질 때까지 연습했다. 나에게 프로그래밍 공부는 억지로 해야하는 &apos;숙제&apos;가 아니었다. 내 인생에서 처음으로 찾은 &apos;내가 하고 싶은 공부&apos;였기 때문이다.&lt;/p&gt;
&lt;p&gt;이 책은 여전히 나의 책장 한 켠에 꽂혀있다. 비록 본인이 웹 개발자라는 이유로 인해 각종 자바스크립트 서적에 둘러싸여 있어서 펼쳐볼 일이 거의 없지만, 나의 개발자 커리어의 첫 스타트를 끊어주었다는 기념비적인 책이기 때문에 앞으로 내가 개발자로서 어떤 커리어를 선택하더라도 이 책을 위한 공간은 항상 남겨두려고 한다.&lt;/p&gt;
&lt;h2&gt;장래희망 : 개발자&lt;/h2&gt;
&lt;p&gt;초중고에서는 매년 학기 초에 장래희망 조사를 했었다. 보통 초등학교까지는 정말 순수한 마음으로 자기가 좋아하는 일, 커서 하고싶은 일을 적기 마련이지만, 중고등학교부터는 현실과 마주함에 따라 장래희망마저 자신의 꿈을 양보하게 된다. 그리고 그 자리는 안정적이거나 사회적 지위가 높은 직업으로 획일화 되기 마련이다.&lt;/p&gt;
&lt;p&gt;그럼에도 나는 중3부터 고3에 이르기까지 장래희망 조사칸을 모두 &apos;개발자&apos;라고 적었다. 내 주변에 장래희망을 개발자라고 적은 친구들은 매우 드물었다. 지금처럼 중고등학교에서 코딩이 교육과정으로 포함되어 있지 않았기 때문에 그만큼 프로그래밍에 대한 학생들의 인식이 높진 않았다. 무엇보다 부모님조차도 개발자라는 직업을 썩 탐탁치 않게 여기셨다. 위에서 언급했다시피 3D 직종이고 생소한 분야이다보니 나에게 다른 직업도 권유하셨지만 나는 확고했다.&lt;/p&gt;
&lt;p&gt;그 나이의 대부분의 남자아이들이 그렇듯, 나 역시도 하나에 꽂히면 끝을 보는 성격이다. 나는 아래와 같은 근거를 준비해서 열심히 부모님을 설득했다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;내가 지금 C언어를 공부하고 있고...나는 이 공부가 재밌고...몇 년 뒤에는 개발자가 유망한 직종이 될 거고...그래서 남들보다 앞서갈 수 있고....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;나의 간절함이 통했는지 부모님은 일단 잠정적으로는 허락해주셨다. 그리고 내가 부모님에게 요구한 조건 한 가지, 바로 &lt;strong&gt;&apos;앞으로 컴퓨터 사용시간에 간섭하지 않기&apos;&lt;/strong&gt; 이다. 부모님께는 프로그래밍을 공부해야한다는 핑계로 대충 얼버무리면서 말했는데 이 요구를 수용해주셨다. &lt;em&gt;(솔직히 그 시간동안 공부만 하지는 않았다. 부모님께는 공부한다 말하고 실제로는 몰래몰래 게임을 했다....)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;이로써 나는 개발자가 되기 위한 모든 만반의 준비를 갖추게 되었다.&lt;/p&gt;
&lt;img height=&quot;500&quot; src=&quot;https://raw.githubusercontent.com/hjhj97/blog.gatsby/main/content/blog/essay/230812-why-i-become-developer/high-school.png&quot;&gt;
&lt;p&gt;&lt;em&gt;당시 고등학교 생활기록부. 고1까지는 아직 부모님을 100% 설득시키지는 못하였다...&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;고등학교에 와서는 정말 입시공부로 인해 프로그래밍 공부를 할 여유가 없어졌다. 다행히 교내 방과후 프로그램의 일종으로 프로그래밍 교실이 있어 신청해서 들을 수 있었다. 이미 내가 공부했던 C언어 기초 내용을 복습하는 수준이었지만 갈증을 해결해 줄 수는 있었다. 이 시절에는 하루빨리 입시공부 때려치우고 대학교에 가서 컴퓨터 공부나 하고 싶다는 생각밖에 없었다.&lt;/p&gt;
&lt;p&gt;하지만 고3 현역 때 수능을 망치는 바람에 모의고사보다 훨씬 못한 성적표를 받아야했다. 여기서도 갈등이었다. 나는 가고자하는 전공이 확고하다보니 대학교의 네임밸류를 포기하더라도, 학과 공부와 개발 공부 열심히 하면 충분히 개발자로서 경쟁력이 있을 수 있다 생각했다.&lt;br&gt;
다른 한편으로는 불안감도 지울 수 없었다. 대학은 평생을 따라다닐 이름표인데 1년 정도는 시간을 더 투자할만 하지 않을까? 여기서 멈춰버리면 너무 아깝지 않을까?&lt;/p&gt;
&lt;p&gt;결국에 재수를 선택하게 되었고 나는 1년을 더 공부했다. 다행히 재수생때는 수능을 그럭저럭 보고 나름 괜찮은 성적을 받았다. 나는 묻지도 따지지도 않고 컴퓨터공학(소프트웨어)학과에만 정시 원서를 넣었다. 사실 학과를 바꾸면 더 높은 학교로 진학할 수 있는 선택지도 있었지만 나에게는 오직 단 하나의 목표, 컴퓨터를 전공하고 싶은 마음 뿐이었다.&lt;/p&gt;
&lt;h2&gt;소프트웨어 전공생&lt;/h2&gt;
&lt;p&gt;그리고 나는 마침내 소프트웨어 전공생이 되었다. 이제 지긋지긋한 &apos;공부를 위한 공부&apos;는 때려치우고 &apos;나를 위한 공부&apos;를 할 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;사실 컴공(소웨)으로 대학에 들어오더라도 1학년부터 대단한 프로그래밍을 하진 않는다. 1,2학년은 C프로그래밍, 자료구조, 네트워크, 컴퓨터구조, 운영체제 등을 배우며 기본적인 CS지식의 기반을 다지는 단계이다. 그래서 저학년에는 코드를 작성하는 시간보다는 강의자료를 보면서 필기하는 데 더 많은 시간을 투자했다.&lt;/p&gt;
&lt;p&gt;그래서 나는 코딩을 하고 싶었다. 갓 입학한 컴공과 학생이 해볼만한 코딩 중 한가지는 바로 프로그래밍 문제를 푸는 일이다. 그래서 나는 학과의 알고리즘 소학회에 가입하게 된다. 여기서부터 본격적으로 나의 6년동안의 문제풀이(소위 &apos;PS&apos;라고 부른다) 인생이 시작되었다. 그 소학회의 C언어 스터디의 커리큘럼이 조금 빡센 편이었는데, 나는 중고등학교 시절의 예습을 한 덕분인지 그럭저럭 따라갈 수 있었다.&lt;/p&gt;
&lt;p&gt;이후 2,3학년이 되어서도 남들보다 쪼금 더 알고리즘 공부에 시간을 투자했다. 그 덕분에 전국 대학생 프로그래밍 경시대회인 ACM-ICPC 에 출전해보고, 소학회의 회장직을 맡아서 100명 이상의 사람들이 모인 커뮤니티 운영하며 C언어 기초 스터디의 강의(무려 3년이나)도 맡아보고, 그리고 교내 프로그래밍 경시대회의 문제 출제도 해볼 수 있었다.&lt;/p&gt;
&lt;p&gt;이 시간은 대학 생활에서 값진 경험을 가져다 주었다. 그 경험의 교훈은 단순히 문제를 어떻게 푸는 지에 대한 방법보다 훨씬 더 귀중한 것이었다.
내가 생각해낸 풀이를 남들이 쉽게 이해할 수 있도록 설명하는 방법, 다른 사람이 생각해낸 풀이에 귀 기울이는 방법, 많은 사람들이 모인 커뮤니티를 운영하는 방법, C언어 스터디를 진행하며 포인터를 쉽게 설명하는 방법, 내 의견을 포기하고 남의 의견을 받아들이는 방법을 배웠다. 또한 축적된 경험이 알게 모르게 개발 공부를 하면서도 탄탄한 밑거름이 되어주었다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(알고리즘 문제 풀이가 개발실력에 도움을 줄 수 있느냐는 사람들마다 의견이 갈리는 주제이지만 나의 의견, 그리고 같이 알고리즘을 공부한 선배들의 의견들은 모두 만장일치로 &apos;도움이 된다&apos;는 의견이다. 다익스트라 알고리즘이나 DP가 실무의 문제를 직접적으로 해결해주지는 않지만 &apos;데이터를 효율적으로 처리하는 방식&apos;에 대한 직관력을 키울 수 있다.)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;내 대학 생활의 또 다른 특이점 중 하나는 (필수)전공과목 말고도 다른 학과의 강의를 많이 들었다. 개인적으로 흥미가 있었던 정수론, 사회심리학, 진화론과 같은 강의들을 들었다. &lt;em&gt;&apos;대학교 때 아니면 언제 이런 강의 들어보겠어? 재밌을 것 같은데 한번 들어보자&apos;&lt;/em&gt; 라는 생각을 갖고 있었다. 내가 궁금한 건 단순히 그 과목에서 가르치는 지식보다, 그 분야를 수십년동안 연구했던 교수님들이 세상을 바라보는 시선을 알고 싶었기 때문이었다. 대학교에서 마저도 중고등학교처럼 점수따기에 목숨 걸 필요는 없다고 생각했다.&lt;/p&gt;
&lt;p&gt;나는 그렇게 3학년까지 학교를 다니다가 군 입대를 하게 된다. 보통 1학년 마치고 다녀오는 게 일반적인데 나는 타이밍을 놓쳐서 시간이 흐르다가 결국 그제서야 가게 되었다. 그나마 다행인 건 특기병으로 지원했기 때문에 야전으로 가지는 않았지만, 교대근무를 하며 하루종일 컴퓨터를 보는 일을 맡아 군생활의 1/4를 밤 새는 일로 보냈다 (평생 할 밤샘을 군대에서 다 했다).&lt;/p&gt;
&lt;p&gt;군 복무 중에도 그냥 흘러만 가는 시간이 아까웠다. 그래서 부대 내 컴퓨터를 사용할 수 있는 사이버 지식 정보방(일명 &apos;사지방&apos;)에서 나는 알고리즘 문제를 풀었다. 주로 코드포스에서 문제를 풀었는데 군 복무 기간동안 대략 400문제 정도 풀었다. 사지방 컴퓨터에는 로컬 IDE 설치가 불가능 했기 때문에 온라인 IDE를 찾아 헤매면서 코딩했던 기억이 난다. 게다가 정말 기막힌 우연 중 하나는, 같은 생활관의 후임 중 한명이 PS를 하는 친구였다. 나만큼 혹은 나보다도 더 문제 풀이에 진심인 친구였기 때문에 외롭지 않게 코딩할 수 있었다.&lt;/p&gt;
&lt;h2&gt;FE 개발자의 길&lt;/h2&gt;
&lt;p&gt;군대를 전역하고 복학하니 4학년이 되어있었다. 이제 나도 본격적으로 취업 전선에 뛰어들 준비를 해야한다. 보통 개발자로 취준을 한다면 먼저 진로를 선택하기 마련이다. 마치 RPG 게임에서 초보자가 직업을 선택할 때 전사/마법사/궁수/도적으로 전직하는 것처럼 개발자도 마찬가지이다. 일반적으로 프론트엔드/백엔드/모바일/ML 중에서 본인의 진로를 정하게 된다.&lt;/p&gt;
&lt;p&gt;내 주변의 컴공 전공생들은 80% 이상이 백엔드로 진로를 선택하는 경우가 많았다. 백엔드 분야가 전공자로서의 이점을 가장 잘 살릴 수 있으면서 대부분의 회사에서 널리 필요한 직종이었기 때문이다. 모바일은 처음 공부를 시작하기 위한 허들이 조금 있는 편이고, ML은 대학원이 90% 필수였다. 그리고 프론트엔드는 상당히 애매한 포지션에 위치한다. 4개 분야 중에서 그나마 CS 지식을 덜 필요로한다는 인식이 있기 때문에 비전공자나 디자인 파트에서 전향하는 사례가 꽤 있는 편이다.나도 그 당시에 프론트엔드와 백엔드를 두고 고민을 많이 했다. 전공자의 이점을 살릴 수 있는 백엔드를 선택할 수도 있었다.&lt;/p&gt;
&lt;p&gt;하지만 프론트엔드는 개발하는 과정이 너무 재미있었다. 마치 중2때 처음 C를 접하고 코딩했었던 기억과 흡사했다. 내가 만든 결과물(웹페이지)이 다른 사람들에게 어떻게 보여질지 상상해면서 코딩을 하는 과정이 행복했고, 그 힘이 마치 무한동력처럼 작용해서 밤을 새서 코딩을 해도 힘들지가 않았다. 비록 프론트엔드 개발자의 진로가 상대적으로 치열하더라도, 내가 하고 싶은 일을 선택하는게 나중에 후회할 일을 만들지 않을 것이라고 생각했다.&lt;/p&gt;
&lt;p&gt;이제 막 FE개발자 경력 1년을 채운 시점에서 돌이켜보자면 1년 전보다 상황이 더 치열해진 건 사실이다. 솔직히 &apos;만약 내가 백엔드 개발자였다면?&apos;을 몇 번 생각해 본 적도 있다.&lt;br&gt;
그래도 후회는 하지 않는다. 인생을 살아가는 나만의 신조 중 하나는 &lt;em&gt;&apos;내가 내린 선택에 대해서는 절대 의심하지 말자&apos;&lt;/em&gt; 이다. 1년 전으로 다시 돌아가도 나는 (조금 고민은 하겠지만)프론트엔드 개발자를 선택할 것이다.&lt;/p&gt;
&lt;p&gt;내가 선택한 길이니 모든 책임은 나의 몫이다. 내가 더 열심히하면 극복할 수 있다고 생각한다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/d059a7dc2274b3319003d03e50db9fcd/5510b/profile-graduate.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGQABAAMBAQAAAAAAAAAAAAAAAAMEBQEC/8QAFwEBAQEBAAAAAAAAAAAAAAAAAAIBA//aAAwDAQACEAMQAAABj7bqpJUPWeb10BL/xAAbEAABBQEBAAAAAAAAAAAAAAACAAEDERIhI//aAAgBAQABBQKsIz0LRcyNcKWiWkz+ul//xAAWEQEBAQAAAAAAAAAAAAAAAAAQARH/2gAIAQMBAT8Bwp//xAAZEQACAwEAAAAAAAAAAAAAAAAAEQECEDH/2gAIAQIBAT8BYyvJz//EABwQAAMAAQUAAAAAAAAAAAAAAAABESEQEjFB4f/aAAgBAQAGPwKbmQWRYTGpIeHWnCP/xAAbEAEAAwEBAQEAAAAAAAAAAAABABEhQVFhkf/aAAgBAQABPyFbMHyJTKt2WNUsvZQVjuRzIdR5IHIt5+Ion25mH//aAAwDAQACAAMAAAAQE/CD/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAR/9oACAEDAQE/EG5E0sL/xAAZEQADAAMAAAAAAAAAAAAAAAAAAREQIVH/2gAIAQIBAT8QWjJ5iU//xAAfEAEBAAICAQUAAAAAAAAAAAABEQAhMUFRYXGBkdH/2gAIAQEAAT8QPEwuht+Zkc6K4fb0y8vCBUuEsgCovnrIsIUQNmtGXAMAB16zcVt4AUqr7ytAg0c/uf/Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;profile graduate&quot;
        title=&quot;&quot;
        src=&quot;/static/d059a7dc2274b3319003d03e50db9fcd/828fb/profile-graduate.jpg&quot;
        srcset=&quot;/static/d059a7dc2274b3319003d03e50db9fcd/ff44c/profile-graduate.jpg 158w,
/static/d059a7dc2274b3319003d03e50db9fcd/a6688/profile-graduate.jpg 315w,
/static/d059a7dc2274b3319003d03e50db9fcd/828fb/profile-graduate.jpg 630w,
/static/d059a7dc2274b3319003d03e50db9fcd/0ede0/profile-graduate.jpg 945w,
/static/d059a7dc2274b3319003d03e50db9fcd/5510b/profile-graduate.jpg 1179w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;지금&lt;/h2&gt;
&lt;p&gt;우리 사회에서 개인의 직업이 정해지는 과정이 그렇게 필연적이기는 어렵다. 자신이 좋아하는 일을 직업으로 삼기는 현실적으로 어렵기 때문이다. 꿈을 쫓다보면 대개 현실적인 제약이 따라오기 마련이다. 그러다보니 많은 사람들은 어쩔 수 없이 입시 점수에 맞춰서 들어간 대학교와 학과에 따라서 직업이 정해지기 마련이다.&lt;/p&gt;
&lt;p&gt;하지만 나에겐 &apos;개발자&apos;라는 직업의 의미는 결코 가볍지 않다. 27살이 된 지금, 프로그래머가 되고자 처음으로 마음을 먹었던 15살을 기점으로 12년동안 간직해온 꿈이고 그 꿈을 직업으로 삼을 수 있다는 점에서 나는 프로그래밍을 하고 있는 순간이 너무나 소중한 기회라 여기고 있다. 내가 살아온 인생의 여정에서 개발자라는 직업은 너무나도 강하게 결합되어 있다.&lt;/p&gt;
&lt;p&gt;내가 남들보다 더 훌륭하다거나 돈을 더 많이 버는 개발자는 아닐 수도 있지만 한 가지는 확신할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;이 일을 내가 하고 싶은 일이다.&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[모바일 환경에서 모달 닫기]]></title><description><![CDATA[2023-03-0…]]></description><link>null/vue/230803-vue-modal-close/</link><guid isPermaLink="false">null/vue/230803-vue-modal-close/</guid><pubDate>Thu, 03 Aug 2023 22:12:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-03-09에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/222&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;모달 닫기&lt;/h2&gt;
&lt;p&gt;모바일 환경에서 모달창이 떠 있는 상태에서 모달을 닫는 방법은 여러가지가 있을 수 있다.&lt;/p&gt;
&lt;p&gt;첫 번째 방법은 모달 창 내부에 별도의 &lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt;버튼을 표시해서 이 영역을 터치하면 닫히게 하는 방법이 있다. 가장 직관적인 방법이지만 버튼을 위한 별도의 공간을 확보해야 하기 때문에 디자인상 의도치 않은 공간을 차지한다는 단점이 있다.&lt;/p&gt;
&lt;p&gt;이런 단점을 해결하기 위한 두 번째 방법은 모달 바깥의 영역을 터치를 감지했을 때 모달을 닫는 방법이 있다. 다만 이 방법 역시 명시적인 &apos;닫기&apos;버튼이 보이지 않기 때문에 이러한 UI/UX가 낯선 사용자에게는 모달을 어떻게 닫아야 하는지 헤맬 수도 있다는 단점이 있다.&lt;/p&gt;
&lt;p&gt;세 번째 방법은 (안드로이드 환경에서) 뒤로가기 버튼을 눌렀을 때 모달이 닫히게 하는 방법이다. 이 방법의 경우, 모달창과 직접적인 상호작용이 일어나지 않으므로 개발자 입장에서는 뒤로가기 이벤트를 감지해야 하는 등 꽤나 까다로운 작업이다. 이번 글에서는 그 방법에 대해서 설명하겠다.&lt;/p&gt;
&lt;h2&gt;뒤로가기&lt;/h2&gt;
&lt;p&gt;&apos;뒤로가기&apos;를 눌렀을 때 모달창이 닫히게 만들기 위해서는, 모달창이 열려있는 상태를 &lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt;객체의 &lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt;에 저장(push)해야 한다. 이때 사용하는 함수가 &lt;code class=&quot;language-text&quot;&gt;window.history.pushState()&lt;/code&gt;함수이다. 이 함수에 대한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History/pushState&quot;&gt;자세한 설명&lt;/a&gt;은 MDN을 참고하기 바란다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pushState()&lt;/code&gt;함수의 첫 번째 인자로는 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt;를 전달해야 하는데, 정해진 양식이 있는 것이 아니라 개발자가 식별할 수 있는 정보를 담아서 객체 형태로 넘기기만 하면 된다. 나는 &lt;code class=&quot;language-text&quot;&gt;{state : &apos;modal&apos;}&lt;/code&gt; 객체를 넣었다. 두 번째 인자는 아무 의미는 없지만 생략할 수는 없으므로 빈 문자열이나 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;를 넣으면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;
    &amp;lt;button @click=&amp;quot;openModal&amp;quot;&amp;gt;open&amp;lt;/button&amp;gt;

    &amp;lt;!-- Modal --&amp;gt;
    &amp;lt;teleport to=&amp;quot;#modal&amp;quot; v-if=&amp;quot;isModalOpen&amp;quot;&amp;gt;
      &amp;lt;Modal @close-modal=&amp;quot;closeModal&amp;quot; /&amp;gt;
    &amp;lt;/teleport&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
  const isModalOpen = ref(false);

  const openModal = () =&amp;gt; {
    isModalOpen.value = true;
  };
  const closeModal = () =&amp;gt; {
    isModalOpen.value = false;
  };
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이전 포스팅에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;안의 코드는 &lt;code class=&quot;language-text&quot;&gt;Modal.vue&lt;/code&gt;라는 별도의 컴포넌트로 분리해두었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Modal.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
      &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
      &amp;lt;button @click=&amp;quot;closeModal&amp;quot;&amp;gt;X&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script setup&amp;gt;
  const emit = defineEmits([&amp;#39;close-modal&amp;#39;]);
  onMounted(() =&amp;gt; {
    window.history.pushState({ state: &amp;#39;modal&amp;#39; }, undefined);
  });
  const closeModal = () =&amp;gt; {
    emit(&amp;#39;close-modal&amp;#39;);
  };
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;이제 버튼을 누르면 모달이 열리면서 &lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;{state:&apos;modal&apos;}&lt;/code&gt;이 추가됨을 확인할 수 있다. 하지만 여기서 뒤로가기를 누르더라도 모달이 닫히지는 않는다. 왜냐하면 &lt;code class=&quot;language-text&quot;&gt;isModalOpen&lt;/code&gt;값은 여전히 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;이기 때문이다. 따라서 &apos;뒤로가기&apos;가 실행되면 &lt;code class=&quot;language-text&quot;&gt;closeModal&lt;/code&gt;함수가 실행되게끔 만들어야 한다.&lt;/p&gt;
&lt;h2&gt;popstate&lt;/h2&gt;
&lt;p&gt;자바스크립트에서 뒤로가기 이벤트를 감지하려면 &lt;code class=&quot;language-text&quot;&gt;popstate&lt;/code&gt;라는 함수를 이벤트리스너에 등록해야 한다. 따라서 &lt;code class=&quot;language-text&quot;&gt;onMounted&lt;/code&gt;함수에 아래와 같이 추가한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;onMounted(() =&amp;gt; {
  window.history.pushState({ state: &amp;quot;modal&amp;quot; }, undefined)
  window.addEventListener(&amp;quot;popstate&amp;quot;, closeModal)
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 &apos;뒤로가기&apos;를 누르면 모달창도 닫힌고, &lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt;도 다시 &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt;된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;하지만 아직 한 가지 문제점이 남아있다.&lt;/strong&gt; &apos;뒤로가기&apos;를 누르지 않고 그냥 &lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt;버튼을 눌러서 닫게 되면 모달을 닫히지만, &lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt;되지 못하고 쌓여있게 된다. 즉 모달은 닫혀 있지만 &lt;code class=&quot;language-text&quot;&gt;window.history&lt;/code&gt;를 찍어보면 &lt;code class=&quot;language-text&quot;&gt;{state:&apos;modal&apos;}&lt;/code&gt;인 상태로 남아있다는 것이다.&lt;/p&gt;
&lt;p&gt;즉 모달이 닫힐 때 &apos;뒤로가기&apos;를 눌러서 닫힌 건지,&lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt;버튼을 눌러서 닫힌 건지 구분해주어야 한다. 따라서 &lt;code class=&quot;language-text&quot;&gt;closeModal&lt;/code&gt;함수의 인자로 뒤로가기가 눌렸는지를 확인하는 인자를 받도록 수정한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const closeModal = (isBackward = false) =&amp;gt; {
  if (!isBackward) {
    history.back()
  }
  emit(&amp;quot;close-modal&amp;quot;)
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;버튼을 눌러서 닫았다면 &lt;code class=&quot;language-text&quot;&gt;isBackward&lt;/code&gt;값이 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;로 들어오고 &lt;code class=&quot;language-text&quot;&gt;history.back()&lt;/code&gt;를 호출하여 상태를 한단계 &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt;해주면 된다. 작동하는 모습은 아래와 같다.&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/hjhj97/blog.gatsby/main/content/blog/vue/images/vue-modal-backward.gif&quot;&gt;
&lt;p&gt;완성된 &lt;code class=&quot;language-text&quot;&gt;Modal.vue&lt;/code&gt;코드는 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Modal.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
      &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
      &amp;lt;button @click=&amp;quot;closeModal(false)&amp;quot;&amp;gt;X&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
  const emit = defineEmits([&amp;#39;close-modal&amp;#39;]);

  onMounted(() =&amp;gt; {
    window.history.pushState({ state: &amp;#39;modal&amp;#39; }, undefined);
    window.addEventListener(&amp;#39;popstate&amp;#39;, () =&amp;gt; closeModal(true));
  });
  onUnmounted(() =&amp;gt; {
    window.removeEventListener(&amp;#39;popstate&amp;#39;, () =&amp;gt; closeModal(true));
  });
  const closeModal = (isBackward = false) =&amp;gt; {
    if (!isBackward) {
      history.back();
    }
    emit(&amp;#39;close-modal&amp;#39;);
  };
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;생각&lt;/h2&gt;
&lt;p&gt;사실 웹뷰 환경에서 모달창이 열려있는 상태를 굳이 &apos;뒤로가기&apos;를 통해서 닫히게 동작해야 할까에 대해 고민이 많았다. 웹뷰는 웹만의 고유한 동작 방식이 있기 때문에 네이티브 앱을 흉내내는 일에 대해서는 회의적이었다. 하지만 개발자가 아닌 일반 사용자 입장에서는 자신이 사용하는 앱이 웹 기반인지 네이티브 기반인지는 별 관심은 없을 것이고, 개인마다 여러 앱을 사용해오면서 축적되어온 경험(&apos;뒤로가기&apos;하면 모달이 닫힘)이 그대로 적용되리라는 기대를 할 것이다.&lt;/p&gt;
&lt;p&gt;그래서 이번 개발을 계기로 유명하다싶은 앱은 모두 다운받아서 과연 &apos;모달창이 뒤로가기로 닫히는가&apos;를 시험해보았다(족히 30개의 앱으로 확인해보았다). 대략 90%의 앱이 네이티브 기반이었고, 이 앱들은 전부 다 뒤로가기를 통해 모달이 닫힘을 확인하였다. 나머지 10%의 웹뷰 기반 앱은 반반이었다. 어떤 앱은 뒤로가기를 누르면 모달이 닫힘과 함께 아예 이전 페이지로 이동해버리는 문제가 있었고, 이 경우의 사용자 예상과 다른 결과로 인하여 사용성이 떨어진다는 인상을 받았다.&lt;/p&gt;
&lt;p&gt;그래서 내가 내린 결론은 웹뷰는 사용자의 경험을 해치지 않는 선에서는 네이티브처럼 동작하게끔 최소한의 기대되는 동작은 구현해줘야 한다는 것이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[vue로 모달 구현하기]]></title><description><![CDATA[2023-03-09에 작성된 원문을 수정한 버전입니다 웹사이트를 이용하다 보면 모달창을 마주하게 된다. 일반적인 모달은 화면이 어두워지면서 기존의 화면은 fade out되면서, 화면 한가운데에서 focus되는 alert…]]></description><link>null/vue/230802-vue-modal-open/</link><guid isPermaLink="false">null/vue/230802-vue-modal-open/</guid><pubDate>Wed, 02 Aug 2023 22:12:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-03-09에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/224&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;웹사이트를 이용하다 보면 모달창을 마주하게 된다. 일반적인 모달은 화면이 어두워지면서 기존의 화면은 fade out되면서, 화면 한가운데에서 focus되는 alert창과 같은 형태이다. 이를 &lt;code class=&quot;language-text&quot;&gt;vue&lt;/code&gt;로 어떻게 구현하는지 살펴보자.&lt;/p&gt;
&lt;h2&gt;모달 구현&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;vue&lt;/code&gt;로 모달을 구현하는 방법에는 여러가지가 있을 수 있다. 가장 간단한 형태는 하나의 파일 안에 모달을 다 집어넣는 방식일 것이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// MyModal.vue
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;

    &amp;lt;!-- Modal --&amp;gt;
    &amp;lt;div id=&amp;quot;modal&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
          &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style&amp;gt;
  @import url(&amp;#39;.../modal.css&amp;#39;)
&amp;lt;/style&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;/* modal.css */
.modal {
  position: fixed;
  z-index: 10;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.5);
}
.modal .modal-content {
  position: absolute;
  width: 600px;
  height: 400px;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #fff;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;이 방식의 경우 아래 사진과 같이 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;태그는 기존 화면이 위치하고 있는 DOM노드 하위에 종속될 수 밖에 없다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0c5a515adca3dad3771e9cb5257a6a8d/09262/vue-modal-1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 72.15189873417721%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAABKklEQVR42u2QOW+DQBBG+dm+D7kx6SzZLty4sP2DUkUpcsiQQATsggPmCPCihRSOIkPKFBnpSSvtN29mV+t2u3Q6HcbjcSOTyYThcMh8Psd8MghlwDmKieKEWJEkJHGK1ia6FA4GA/QbHfvZ4mQHhH5IHqdclqaCv2E6nTIajdB1HSkkgXBxrEfO0iHPc8qirIX9fp9er9eKyqmvmc1mWJaFY1gY97fYT3ccH45YLwIpArTFYsFyuWS1WrFerxtRmc1mUwnFq4eUktN78MWJKIrQTNMkDEOyLKOpyrJ+kuu6vBk26TkhKzOyPCPNUz6Kul/zPK86FEVRNV1D3atyHAfXceshlD8Ga0KIbxu0baiETT3/wr8o3G63HA4H9vt9K7vdrsr6vn9V+AkSCeMgVSbvcAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;vue modal 1&quot;
        title=&quot;&quot;
        src=&quot;/static/0c5a515adca3dad3771e9cb5257a6a8d/f058b/vue-modal-1.png&quot;
        srcset=&quot;/static/0c5a515adca3dad3771e9cb5257a6a8d/c26ae/vue-modal-1.png 158w,
/static/0c5a515adca3dad3771e9cb5257a6a8d/6bdcf/vue-modal-1.png 315w,
/static/0c5a515adca3dad3771e9cb5257a6a8d/f058b/vue-modal-1.png 630w,
/static/0c5a515adca3dad3771e9cb5257a6a8d/40601/vue-modal-1.png 945w,
/static/0c5a515adca3dad3771e9cb5257a6a8d/78612/vue-modal-1.png 1260w,
/static/0c5a515adca3dad3771e9cb5257a6a8d/09262/vue-modal-1.png 1896w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;여기서 한 가지 아쉬운 점이 생긴다. modal 창은 기존의 화면과 구분되는 속성인데 DOM 노드상에서도 이를 구분할 수 없을까? 즉 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;app&quot;&gt;&lt;/code&gt;과 같은 레벨로 끌어올릴 수 없을까? 하는 생각을 품게된다.&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;teleport&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;이를 해결하기 위해 &lt;code class=&quot;language-text&quot;&gt;vue&lt;/code&gt;에서 제공하는 &lt;code class=&quot;language-text&quot;&gt;teleport&lt;/code&gt; 기능을 적용해보자. &lt;code class=&quot;language-text&quot;&gt;teleport&lt;/code&gt;란 &lt;a href=&quot;https://ko.vuejs.org/guide/built-ins/teleport.html#basic-usage&quot;&gt;공식문서&lt;/a&gt;상에서는&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;컴포넌트 템플릿의 일부를 해당 컴포넌트의 DOM 계층 외부의 DOM 노드로 &quot;이동&quot;할 수 있게 해주는 빌트인 컴포넌트입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;라고 설명하고 있다. 간단하게 요약하자면 기존에 보여지고 있던 화면과 논리적/기능적으로 구분된 또다른 화면을 표시해야할 때, 기존의 DOM 노드가 아닌 별도의 DOM노드로 마치 teleport(순간이동)할 수 있는 기능이다.&lt;/p&gt;
&lt;p&gt;이를 사용하기 위해서는 일단 DOM이 그려지는 &lt;code class=&quot;language-text&quot;&gt;index.html&lt;/code&gt;안에 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;이라는 새로운 태그를 추가한다. (id 대신에 class를 사용하더라도 작동은 정상적으로 하지만, 중복 문제를 피하기 위해 관습적으로 id를 사용하는 듯 하다.)&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    ...
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;noscript&amp;gt; ... &amp;lt;/noscript&amp;gt;
    &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;modal&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그리고 기존에 있던 &lt;code class=&quot;language-text&quot;&gt;MyModal.vue&lt;/code&gt;에서는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;한 겹을 벗겨내고 대신에 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport to=&quot;#modal&quot;&gt;&lt;/code&gt;을 넣어주면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;

    &amp;lt;!-- Modal --&amp;gt;
    &amp;lt;teleport to=&amp;quot;#modal&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
          &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/teleport&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;그러면 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;id&quot;&gt;&lt;/code&gt;와 DOM상에서 같은 레벨에 생성된 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/361a6186f39d39e599866d8b3fe8a390/60c1e/vue-modal-2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 70.25316455696203%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAABIUlEQVR42s2RQWvCQBCF869FSEg8eFD/kp4NXkqtlhQFaQPRkBijZndrTPKVDRU8GLRQSh98MPCGtzM7RqvVQmPb9l0cx8E0TaZPU7J0z35/YHcUHDJBJgSHY4ahmzQPBdoOpmXy+jxHhRnHOKOQiqosqaoKLePy8iN0Op06cPYyYxdErBbvfKx8wiAkiROEFBh6hUexLIt2u403fyMXJ9RZ8Xk+IXOFOknKqsTo9XoMBgP6/f5ddF+322W5WNbrXda8luF5Huv1mjRNUUohpbyJEII8zwmCgM1m0xwYx3Gjea2LnyQJYRg2B26327oovy/VhPZ/FPjrE/7fwCiK6qIoivqfmtC+lj7i3044Go1wXZfxeHyXyWTCcDjE9/3GwC/7wOThxMZt/AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;vue modal 2&quot;
        title=&quot;&quot;
        src=&quot;/static/361a6186f39d39e599866d8b3fe8a390/f058b/vue-modal-2.png&quot;
        srcset=&quot;/static/361a6186f39d39e599866d8b3fe8a390/c26ae/vue-modal-2.png 158w,
/static/361a6186f39d39e599866d8b3fe8a390/6bdcf/vue-modal-2.png 315w,
/static/361a6186f39d39e599866d8b3fe8a390/f058b/vue-modal-2.png 630w,
/static/361a6186f39d39e599866d8b3fe8a390/40601/vue-modal-2.png 945w,
/static/361a6186f39d39e599866d8b3fe8a390/78612/vue-modal-2.png 1260w,
/static/361a6186f39d39e599866d8b3fe8a390/60c1e/vue-modal-2.png 1866w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;모달 열고 닫기&lt;/h2&gt;
&lt;p&gt;그렇다면 이제 이 모달을 동적으로 열고 닫을 수 있어야 한다. 방법은 예상하다시피 &lt;code class=&quot;language-text&quot;&gt;v-if&lt;/code&gt;
나 &lt;code class=&quot;language-text&quot;&gt;v-show&lt;/code&gt;를 사용하면 된다. 하지만 사용 방식에는 조금 차이가 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;에는 오직 &lt;code class=&quot;language-text&quot;&gt;v-if&lt;/code&gt;만 사용할 수 있고, &lt;code class=&quot;language-text&quot;&gt;v-show&lt;/code&gt;는 작동하지 않는다. &lt;code class=&quot;language-text&quot;&gt;v-show&lt;/code&gt;를 사용하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;하위의 최상단 root노드에 걸어야만 작동한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;v-if&lt;/code&gt;는 값이 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;일 경우 렌더링 시점에서 아예 제외되므로 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;에 걸면 하위의 모든 노드들이 렌더링되지 않지만, &lt;code class=&quot;language-text&quot;&gt;v-show&lt;/code&gt;의 경우에는 일단 렌더링하고나서 값에 따라 &lt;code class=&quot;language-text&quot;&gt;display:none&lt;/code&gt;으로 처리하는데 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;html&lt;/code&gt; 태그가 아닌 &lt;code class=&quot;language-text&quot;&gt;vue&lt;/code&gt;에서 제공하는 기능에 불과하므로 &lt;code class=&quot;language-text&quot;&gt;display:none&lt;/code&gt;이 걸리지 않는다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;
    &amp;lt;button @click=&amp;quot;isModalOpen = true&amp;quot;&amp;gt;open&amp;lt;/button&amp;gt;

    &amp;lt;!-- Modal --&amp;gt;
    &amp;lt;teleport to=&amp;quot;#modal&amp;quot; v-if=&amp;quot;isModalOpen&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
          &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
          &amp;lt;button @click=&amp;quot;isModalOpen = false&amp;quot;&amp;gt;close&amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/teleport&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
  import { ref } from &amp;#39;vue&amp;#39;;
  const isModalOpen = ref(false);
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;</content:encoded></item><item><title><![CDATA[두 번째 프로젝트 회고]]></title><description><![CDATA[1. pinia와 typescript…]]></description><link>null/230712-second-project-review/</link><guid isPermaLink="false">null/230712-second-project-review/</guid><pubDate>Wed, 12 Jul 2023 22:12:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. pinia와 typescript의 도입&lt;/h2&gt;
&lt;p&gt;이번 프로젝트(커머스)에서 드디어 벼르고 벼르어왔던 기술을 도입하게 되었다. 바로 &lt;code class=&quot;language-text&quot;&gt;typescript&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;이다.&lt;/p&gt;
&lt;p&gt;원래는 더 빨리 도입하고 싶었으나, 이전 프로젝트가 생각보다 늘어짐 + 숙련도 이슈로 인하여 늦어진 감이 있다. 하지만 그만큼 더 철저하게 준비해서 도입 안하느니만 못한 상황이 벌어지지 않게끔 신경썼다. 여기서 &apos;도입 안하느니만 못한 상황&apos;이란 기껏 타입스크립트 도입해놓고 모든 타입을 &lt;code class=&quot;language-text&quot;&gt;any&lt;/code&gt;로 정의한다든가, 에러 해결을 못해서 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt;로 회귀한다든가 하는 상황이다. 도입 초반부에는 이런 일이 실제로 벌어질 위기가 몇 번 있었으나, 그때마다 구글링하고 공식문서 열심히 읽다보니 어찌어찌 해결은 할 수 있었다.&lt;/p&gt;
&lt;p&gt;도입해놓고 나서 느낀 점은 확실히 타입스크립트가 개발경험을 엄청나게 개선시켜준다. VScode에서 제공해주는 자동완성 기능을 맛보면 헤어나올 수가 없다. 특히나 내가 진행한 커머스는 그 특성상 프론트에서 다뤄야할 데이터가 많다. 하나의 상품 데이터 하나에도 그 속성이 20개가 넘고, 이 상품을 주문 로직을 태우려면 또 다시 주문을 위한 데이터 20여개가 추가된다.&lt;/p&gt;
&lt;p&gt;기존 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt;로 개발을 했다면 40개가 넘는 데이터 중에서 하나라도 오타가 나거나 타입이 어긋나면 직접 시연해보며 그 에러를 찾는데 시간이 잡아먹혔겠지만, &lt;code class=&quot;language-text&quot;&gt;ts&lt;/code&gt;를 사용함으로써 런타임 이전 시점에 어디서 문제가 생기는지 쉽게 찾을 수 있게 되었다.&lt;br&gt;
왜 사람들이 &lt;code class=&quot;language-text&quot;&gt;ts&lt;/code&gt;를 제대로 쓸 줄 알기 시작하면 쓰기 이전으로 돌아갈 수 없다고 말하는지 깨달았다. 아직 내가 &apos;제대로 쓴다&apos;라고 말하기엔 어설프긴 하다만, &lt;code class=&quot;language-text&quot;&gt;ts&lt;/code&gt;학습 허들의 고비점은 넘긴 느낌이다.&lt;/p&gt;
&lt;p&gt;또 다른 기술 도입은 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;이다. &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;는 vue 커뮤니티에서 출시한 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 대신할 새로운 전역 상태관리 라이브러리이다. 사실 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 대신한다고는 해도, 그 개발진 대부분이 옮겨간 수준이라 크게 달라진 점은 없다.&lt;br&gt;
기존 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 사용하면서 느꼈던 불편한 점들, 그리고 &lt;code class=&quot;language-text&quot;&gt;ts&lt;/code&gt;와의 호환성 증대로 인하여 서로의 시너지를 극대화시킬 수 있다는 장점이 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에 대한 도입기는 &lt;a href=&quot;https://juheon.dev/vue/230704-start-pinia/&quot;&gt;이전 포스팅&lt;/a&gt;에 자세히 적어놓았다.&lt;/p&gt;
&lt;h2&gt;2. 페이지 / 컴포넌트 구조에 대한 고민&lt;/h2&gt;
&lt;p&gt;개발을 시작한지 얼마 되지 않은 초창기의 개발 스타일은 가급적이면 한 페이지에 내에 많은 기능을 압축적으로 집어넣으려고 했다. 개발이 익숙하지 않을 시기에는 파일을 여러 개로 쪼개는 것에 대한 부담감(두려움)도 있고, 상대적으로 규모가 작은 프로젝트를 맡았었기에 &apos;페이지,컴포넌트 구조론&apos;에 대해 고민이 깊지는 않았다.&lt;br&gt;
하지만 프로젝트의 규모가 점점 커질수록 페이지,컴포넌트의 개수가 많아지게 되고, 여러 파일을 다루는 일도 익숙해지면 자연스레 이 파일들을 어떤 기준으로 나눠야 효율적일지 고민하게 되었다.&lt;/p&gt;
&lt;p&gt;일단 &lt;strong&gt;페이지&lt;/strong&gt;란 사용자가 서비스에서 제공하는 특정한 기능 &lt;strong&gt;한 가지&lt;/strong&gt;를 수행하기 위해 만들어진다. 커머스 서비스로 예를 들자면 상품 전시, 결제, 장바구니, 주문조회와 같은 기능에는 모두 고유한 페이지가 존재한다. 그리고 페이지는 각자마다 고유한 &lt;code class=&quot;language-text&quot;&gt;path(url)&lt;/code&gt;를 부여받는다. 이 &lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;가 사용자와 개발자간의 접점이 되어서 상호작용이 가능한 것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;컴포넌트&lt;/strong&gt;는 그 페이지를 구성하고 있는 일종의 부속품이다. 컴포넌트에는 버튼이나 헤더,푸터, input창 하나하나도 개발자의 판단에 따라서 컴포넌트가 될 수도 있다. 컴포넌트를 분리하는 기준은 저마다 다를 수 있지만 나같은 경우에는 프로젝트 내에서 반복적으로 사용되는 여부와 기능을 구성하는 최소한의 단위를 따져서 만들게 된다.&lt;br&gt;
즉 하나의 페이지 안에도 수십개의 컴포넌트가 존재할 수 있고, 이 말은 곧 작은 기능을 담당하는 부품(컴포넌트)이 여러개가 합쳐짐에 따라 기능을 수행할 수 있게 되는 것이다.&lt;/p&gt;
&lt;p&gt;그래서 내가 페이지를 나누는 기준은 사용자의 행동 단위를 큼직하게 잘라서 구성하는데, 이 기준이 칼로 두부자르듯이 항상 말끔하게 구분되지는 않고 애매모호한 지점이 생긴다. 때로는 특정 행동에서 파생된 기능을 다뤄야 할 때가 있다.
예를 들어 &apos;주문조회&apos; 페이지에서 &apos;배송조회&apos;라는 파생기능이나, &apos;상품 주문&apos;페이지에서 &apos;주소 검색&apos;같은 기능들이다. 이러한 파생기능을 구현하려면 둘 중 하나의 방식을 선택해야 한다.&lt;/p&gt;
&lt;h4&gt;1. 메인 페이지에 녹여내기&lt;/h4&gt;
&lt;p&gt;가장 간단한 방법은 한 페이지에 두 기능을 다 표시하면 된다. 하지만 2가지의 별도의 행동을 하나의 페이지 안에 모두 보여주기에는 부담이 있다. 위에서 언급했던 &lt;strong&gt;페이지&lt;/strong&gt;의 정의와 같이 하나의 페이지 안에서는 &lt;strong&gt;한 가지&lt;/strong&gt; 기능만 수행하도록 하는 원칙에 위배되기 때문이다. 파생된 기능을 욱여넣음으로써 그 페이지만의 맥락을 모호하게 만들고 싶지는 않았다.&lt;/p&gt;
&lt;h4&gt;2. 별도의 페이지(&lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;)로 만들기&lt;/h4&gt;
&lt;p&gt;1번의 방법이 싫다면 페이지 자체를 분리하면 된다. 하지만 페이지를 남발하게 되면 그 만큼 &lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;의 수가 많아지게 된다. 한 페이지 내에서 파생 기능이 10가지라면 새로운 &lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt; 10가지가 추가된다는 뜻인데 과연 이게 효율적인 방법인지는 고민해봐야 한다.&lt;br&gt;
무엇보다 페이지를 쪼개면 메인 페이지 =&gt; 파생 페이지 로 데이터를 전달하기가 난처해진다. 페이지 =&gt; 컴포넌트 구조에서는 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;를 통해 전달할 수 있지만, 페이지 =&gt; 페이지 구조에서는 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;전달이 불가능하다. 따라서 상태관리의 힘을 빌린다거나, 파생 페이지에서 다시 새로운 데이터를 &lt;code class=&quot;language-text&quot;&gt;fetch&lt;/code&gt;해야하는 비효율적인 문제가 발생한다.&lt;/p&gt;
&lt;p&gt;결국 방법 1,2 중 완벽한 방법은 없다. 하나의 페이지라는 제한적인 공간(맥락)안에서도 여러가지 파생된 기능을 넣어야 한다. 나는 이를 해결하기 위해서 &lt;strong&gt;모달&lt;/strong&gt;을 사용하였다. 모달은 별도의 &lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;를 부여하지 않더라도 공간을 분리시킬 수 있다. 평소에는 메인페이지를 보여주고 있다가 사용자가 파생 기능을 선택했을 때에만 모달이 기존 화면을 덮음으로써 공간을 분리할 수 있다.&lt;/p&gt;
&lt;p&gt;그래서 결론을 얘기하자면 이번 프로젝트에서는 모달을 적극적으로 사용하였다. 모달은 &apos;페이지와 컴포넌트 사이 고민&apos;의 산물이다. 나는 페이지는 가능한 적게 만들면서 컴포넌트는 최대한 쪼갤 수 있을만큼 쪼개는 방식을 선호하다보니 이런 고민을 하게 된 것 같다.&lt;/p&gt;
&lt;h2&gt;3. 셀프 코드리뷰(클린 코드)&lt;/h2&gt;
&lt;p&gt;셀프 코드리뷰라는 말이 이상하게 들릴 수 있다. 하지만 회사에 프론트 개발자가 나 혼자밖에 없으니 누군가에게 코드 리뷰를 부탁하기 어려운 상황이다. 그래서 나는 회사에 다니는 동안 &apos;좋은 코드&apos;란 무엇일까에 대해 고민을 많이 할 수밖에 없었다. 그리고 이번 프로젝트에서 주안점으로 둔 3가지는,&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;시간이 지난 뒤에 다른 사람이 읽어도 자연스럽게 읽히는 코드&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;내가 짤 때는 나름 잘 짠 것 같은데, 나중에 다른사람이 내 코드를 읽고서 읽기 어렵다는 피드백을 들은 적이 있었다.
내가 보기에 잘 짠 것 같은 코드는 아무 의미가 없다. 모두가 이해할만한 보편적인 코드를 짜야한다.
특히 변수명과 함수명을 잘 짓는 일이 중요하다고 생각한다. 이름이 좀 길어지더라도 해당 변수(함수)가 하는 역할이 이름만 보고도 짐작할 수 있어야 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;버그가 발생했을 때, 어느 부분을 고쳐야 하는지 직관적으로 찾을 수 있는 코드&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;버그가 발생하지 않는 방향으로 코드를 작성하는 게 가장 바람직하겠지만, 코드를 작성하다보면 버그 발생은 불가피하다. 그래서 버그가 발생하지 않도록 하는 일만큼 중요한 게 &apos;버그를 얼마나 쉽게 고칠 수 있느냐&apos;이다.&lt;br&gt;
대개 해결하기 어려운 버그들의 공통점은 하나의 코드 안에서 여러 로직들이 이어폰줄처럼 엉켜있을 때 발생한다. 어떤 부분을 고치면 이곳에 의존하고 있던 또 다른 함수에게 사이드이펙트가 전파되어서 또 다른 버그가 발생하고 만다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;한 번에 한 가지만 신경쓰는 코드&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;세 번째 정의가 어쩌면 첫 번째, 두 번째 조건을 모두 만족시키기 위한 대전제일 수 있다.&lt;br&gt;
&lt;strong&gt;단일책임원칙&lt;/strong&gt;이라는 객체 지향 프로그래밍의 원칙 중 하나이기도 한데, 하나의 객체는 딱 한 가지의 역할만 담당해야 한다는 원칙이다. 프론트엔드 코드가 엄밀한 객체지향 코드라고 하긴 어렵지만, 이 원칙 하나만큼은 신경써서 개발하는 게 도움이 된다.&lt;/p&gt;
&lt;p&gt;그 점 때문인지 이번 프로젝트는 이전 프로젝트보다 파일의 개수,디렉토리의 개수, 함수의 개수 등이 월등히 많아지게 되었다. 이전 프로젝트에서는 귀찮다거나, 코드의 양을 줄이는 게 무조건적인 미학이라 생각해서 하나의 함수 안에서 여러가지 일을 동시에 처리하는 경우가 많았었는데, 이번에는 그런 로직은 철저히 배제하였다.&lt;/p&gt;
&lt;h2&gt;4. 효율적인 소통 방식&lt;/h2&gt;
&lt;p&gt;마지막은 개발 외적인 이야기이다. &lt;a href=&quot;https://juheon.dev/230625-project-review/&quot;&gt;첫 번재 프로젝트 회고&lt;/a&gt;에서도 언급했다시피 프로젝트에서 가장 어려운 문제는 개발이 아니라 사람과 사람간의 소통의 문제인 경우가 더 많다. 특히나 프론트엔드 개발자는 그 특성상 기획/디자인/백엔드 모든 분야에 다리를 걸치고 있다보니 소통의 중요성이 더욱 강조될 수밖에 없다.&lt;/p&gt;
&lt;p&gt;이 중요성을 간과하고 무지성 개발만 하다보면 참사가 일어나기도 하는데 예를 들어 일주일 동안 열심히 개발/디자인 해놓았는데 나중에 보니 필요없는 기능이었다던지, 동료에게 특정 기능 하나를 요청했는데 나중에 보니 내 요청사항을 이해하지 못해서 기대와 다른 결과물을 받기도 한다. 그래서 이번 프로젝트에서는 내가 어떻게해야 조금 더 효율적으로 일할 수 있을 지에 대해서 먼저 고민해보았다.&lt;/p&gt;
&lt;h4&gt;첫 번째는 기획자와의 소통이다.&lt;/h4&gt;
&lt;p&gt;내가 기획자에게 가장 많이 물어본 질문은 아마 &apos;나중에 이 기능이 추가될 수도 있나요?&apos;일 것이다. 개발 초기에 특정 기능을 배제하고 만들어놓았는데, 프로젝트 중간에 기획자가 &apos;이 기능 추가해주세요&apos;하는 사태가 벌어지면 상당히 곤란해진다.&lt;br&gt;
그래서 기획자와 개발자 사이에 서로의 상황을 이해하고 있어야 한다. 개발자는 기획자가 어떤 기능을 넣고 싶어하는지 파악해야하고, 반대로 개발자는 기획자에게 어떤 기능은 넣을 수 있고, 어떤 기능은 넣기 어려운지 분명하게 알려야 한다. 각자의 상황을 잘 알고 있어야만 나중에 &lt;code class=&quot;language-text&quot;&gt;이거 빼기로 했잖아요&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;이거 넣기로 했잖아요&lt;/code&gt; 사태를 방지할 수 있다.&lt;/p&gt;
&lt;h4&gt;두 번째는 디자이너와의 소통이다.&lt;/h4&gt;
&lt;p&gt;이전 프로젝트에서는 대부분 디자이너가 디자인 작업과 퍼블리싱 작업까지 도맡아서 한 뒤에, 나는 퍼블리싱의 최종 결과물 위에서 프론트엔드 개발을 시작했었다. 이 방식의 경우 디자이너와 프론트 개발자의 역할 부담이 완전히 나뉘어져 있는 방식인데, 이 경우 내가 프론트 개발을 하다가 디자이너에게 돌아가서 다시 물어봐야 하거나, 아니면 퍼블리싱된 코드가 개발하기에는 적합하지 않아 코드를 지우고 처음부터 다시 짜야하는 경우가 있었다.&lt;/p&gt;
&lt;p&gt;따라서 이번 프로젝트에서는 기초적인 디자인 작업과 퍼블리싱 단계에서부터 같이 참여했다. 기본적인 페이지 구조부터 컴포넌트를 어떤 단위로 쪼갤 것인지부터 고민했다. 그리고 자주 사용될만한 컴포넌트는 퍼블리싱 단계부터 미리 공통화를 시켜놓고 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;값에 따라서 다르게 동작하도록 하였다.&lt;br&gt;
이렇게 작업한 결과, 이전보다 프론트엔드를 개발하면서 느꼈었던 모호함이 사라지고 1달이라는 비교적 빠른 시일 내에 서비스의 프로토타입을 개발할 수 있게 되었다.&lt;/p&gt;
&lt;h4&gt;세 번째는 백엔드 개발자와의 소통이다.&lt;/h4&gt;
&lt;p&gt;예전에는 프론트에 어떤 API가 필요한 상황이면 백엔드 개발자에게 두루뭉실하게 &apos;이러이러한 기능하는 API 만들어주세요&apos;라고 전달했었다. 구체적으로 말하지 않더라도 &apos;무슨 말 하는지 이해하겠지?&apos;라는 마인드여서 그랬었는데 이는 역시 나의 착각이다.&lt;/p&gt;
&lt;p&gt;백엔드 개발자는 내가 무엇을 필요로 하는지 정확히 이해하기 힘들다. 반대의 경우도 마찬가지이다. 그래서 요청사항을 전달하는 방식을 바꿨다. 일단 &apos;프론트에 이런 기능이 필요한데&apos;로 시작하여 상대방에게 내가 해결하고자 하는 문제상황을 납득시켜야한다. 그 다음에 &apos;프론트에서 이 엔드포인트로 요청을 보내면, 반환값 형식 이렇게 해서 보내주세요&apos; 라고 전달한다.&lt;br&gt;
여기서 중요한 점은 반환값 형식은 내가 우선적으로 제안을 해야한다. 백엔드에서 다루는 데이터 형식이 프론트의 그것과 상당 부분 다르기 때문에, 내가 원치 않은 형식으로 받게 될 수도 있기 때문이다.&lt;/p&gt;
&lt;p&gt;그리고 상품별로, 혹은 주문별로 상태코드를 정의해야 했다. 백엔드는 물론이고 프론트에서도 상태에 따라서 화면에 보여줘야 할 데이터가 다르기 때문이다. 이 과정 또한 백엔드와 같이 상의하면서 &apos;어떤 상태에서는 어떤 데이터를 보내줘야 하는지&apos;에 대한 일종의 규약을 만들었다.&lt;/p&gt;
&lt;h2&gt;총평&lt;/h2&gt;
&lt;p&gt;나느 매 프로젝트를 진행하면서 스스로에게 미션을 부여한다. 처음 프로젝트를 맡았을 때는 &lt;code class=&quot;language-text&quot;&gt;vue2&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;vue3&lt;/code&gt;로 마이그레이션 하는 미션을, 이번 프로젝트에서는 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;typescript&lt;/code&gt;를 도입하는 미션이었다.&lt;/p&gt;
&lt;p&gt;이런 식으로 조금씩 내가 도전해볼만한, 개척의 여지를 찾아나감으로써 스스로 레벨업하고 있다는 느낌을 찾고 싶어서다. 누가 시켜서 하는 게 아니다. 그냥 기존에 쓰던 기술스택 그대로 써도 아무 문제 없다. 오히려 당장 개발할 때는 익숙할테니 버그도 덜 발생하고, 개발 기간도 더 짧을 수도 있다. 하지만 장기적인 관점에서, 그리고 유지보수의 관점에서는 기술을 도입함으로써 얻을 수 있는 이점이 훨씬 더 크다고 믿고 있다.&lt;/p&gt;
&lt;p&gt;다음 프로젝트에는 꼭 &lt;code class=&quot;language-text&quot;&gt;Next.js&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;Nuxt.js&lt;/code&gt;를 이용해서 SSR을 도입하고 싶다. 얼마 전에 살짝 찍먹해봤는데 쉽지 않을 것 같다.서버에 대한 이해도가 어느정도 갖춰져 있어야 할 것으로 보인다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[TS 개념 정리]]></title><description><![CDATA[인덱스 시그니쳐 객체의 속성의 개수가 정해져 있지 않다면 인덱스 시그니쳐를 사용하는 게 좋다. 유니온타입 인터섹션 타입 타입 alias enum 숫자형 enum 문자형 enum const enum 기본적인 enum…]]></description><link>null/ts/230703-index-signature/</link><guid isPermaLink="false">null/ts/230703-index-signature/</guid><pubDate>Wed, 05 Jul 2023 22:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;인덱스 시그니쳐&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  [name: string]: string
}

const phone: Phone = {
  cpu: &amp;quot;A15&amp;quot;,
  sim: &amp;quot;eSIM&amp;quot;,
  brand : &amp;quot;Apple&amp;quot;,
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;객체의 속성의 개수가 정해져 있지 않다면 인덱스 시그니쳐를 사용하는 게 좋다.&lt;/p&gt;
&lt;h2&gt;유니온타입&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  sim: string
}
interface Laptop {
  cpu: string
  gpu: string
}

function getDevice(device: Phone | Laptop) {
  // device는 Phone과 Laptop 중 어떤 타입인지 정해져있지 않기 때문에
  // 두 인터페이스가 공통으로 갖고 있는 속성만 접근 가능하다.

  console.log(device.cpu) // ✅
  console.log(device.sim) // ❌

  // typeof나 in 연산자를 이용하여 타입을 필터링해주면 접근이 가능해진다.
  if (&amp;quot;sim&amp;quot; in device) {
    console.log(device.sim)
  }
  if (&amp;quot;gpu&amp;quot; in device) {
    console.log(device.gpu)
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;인터섹션 타입&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  sim: string
}
interface Laptop {
  cpu: string
  gpu: string
}

function getDevice(device: Phone &amp;amp; Laptop) {
  // device는 Phone과 Laptop 의 속성을 모두 만족시켜야 한다.
  console.log(device.cpu) // ✅
  console.log(device.sim) // ✅
}

getDevice({ cpu: &amp;quot;Intel&amp;quot;, sim: &amp;quot;eSIM&amp;quot; }) // ❌, Laptop이 갖고 있는 속성도 만족시켜야함.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;타입 alias&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type Phone = {
  cpu: string
  sim: string
}
const myPhone: Phone = {
  cpu: &amp;quot;A16&amp;quot;,
  sim: &amp;quot;physical&amp;quot;,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  sim: string
}
interface Laptop {
  cpu: string
  gpu: string
}
// type은 연산자를 이용한 확장 가능
type Device = Phone | Laptop&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;enum&lt;/h2&gt;
&lt;h4&gt;숫자형 enum&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;enum Count {
  ZERO,
  ONE,
  TWO,
}
// 별도로 값을 지정하지 않으면 0부터 1씩 증가하면서 값이 배정된다
console.log(Count.ZERO) // 0
console.log(Count.ONE) // 1
console.log(Count.TWO) // 2&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;문자형 enum&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;enum Color {
  PRIMARY = &amp;quot;blue&amp;quot;,
  SECONDARY = &amp;quot;white&amp;quot;,
}
console.log(Color.PRIMARY) // blue
console.log(Color.SECONDARY) // white&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;const enum&lt;/h4&gt;
&lt;p&gt;기본적인 enum은 컴파일 시, &lt;code class=&quot;language-text&quot;&gt;[속성이름]=값&lt;/code&gt;을 연결해주는 별도의 객체를 생성한다.&lt;br&gt;
하지만 enum 앞에 const를 붙이면 컴파일 시 객체를 생성하지 않고 &lt;code class=&quot;language-text&quot;&gt;[속성이름]&lt;/code&gt;을 직접 &lt;code class=&quot;language-text&quot;&gt;값&lt;/code&gt;으로 치환해버리기 때문에 컴파일 코드의 양을 줄일 수 있다.&lt;/p&gt;
&lt;h2&gt;제네릭&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function getValue&amp;lt;T&amp;gt;(value: T): T {
  return value
}
// 파라미터에 어떤 타입을 넣느냐에 따라 value의 타입이 정해짐
console.log(gatValue(10)) // number type
console.log(gatValue(&amp;quot;hello&amp;quot;)) // string type&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;T extends type&lt;/code&gt;&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function getValue&amp;lt;T extends string&amp;gt;(value: T) {
  return value.length
}
// extends 키워드를 통해 제네릭으로 받을 타입을 제한할 수 있음
const num = getValue(10) // ❌
const str = getValue(&amp;quot;hello&amp;quot;) // ✅&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;T extends keyof type&lt;/code&gt;&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  sim: string
}
type PhoneType = keyof Phone // &amp;quot;cpu&amp;quot; | &amp;quot;sim&amp;quot;

function getPhoneComponent&amp;lt;T extends keyof Phone&amp;gt;(component: T) {
  return component
}
const component1 = getPhoneComponent(&amp;quot;cpu&amp;quot;) //  ✅
const component2 = getPhoneComponent(&amp;quot;gpu&amp;quot;) // ❌&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;Non-null assertion&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const elem = document.querySelector(&amp;quot;.elem&amp;quot;)
// elem : HTMLElement | null
elem.textContent = &amp;quot;Hello&amp;quot; // ❌, elem is possibly null;
elem!.textContent = &amp;quot;Hello&amp;quot; // ✅&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;유틸리티 타입&lt;/h2&gt;
&lt;h4&gt;Pick&lt;/h4&gt;
&lt;p&gt;특정 타입만 골라내서 새로운 타입을 만듦&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  ram: string
  sim: string
}
type Cpu = Pick&amp;lt;Phone, &amp;quot;cpu&amp;quot;&amp;gt;
const myPhone: Cpu = {
  cpu: &amp;quot;A15&amp;quot;,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Omit&lt;/h4&gt;
&lt;p&gt;특정 타입만 제외해서 새로운 타입을 만듦&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  ram: string
  sim: string
}
type withoutCpu = Omit&amp;lt;Phone, &amp;quot;cpu&amp;quot;&amp;gt;
const myPhone: withoutCpu = {
  ram: &amp;quot;8GB&amp;quot;,
  sim: &amp;quot;physical&amp;quot;,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Partial&lt;/h4&gt;
&lt;p&gt;모든 타입을 옵셔널 파라미터로 바꿔서 새로운 타입으로 만듦&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  ram: string
  sim: string
}
type PartialPhone = Partial&amp;lt;Phone&amp;gt;
/*
  PartialPhone = {
    cpu?:string
    ram?:string
    sim?:string
  }
*/
const myPhone: PartialPhone = {
  ram: &amp;quot;8GB&amp;quot;,
}
const yourPhone: PartialPhone = {
  cpu: &amp;quot;A16&amp;quot;,
  ram: &amp;quot;8GB&amp;quot;,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Exclude&lt;/h4&gt;
&lt;p&gt;유니온 타입에서 특정 타입을 제외하여 새로운 타입으로 만듦&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type PhoneBrands = &amp;quot;Samsung&amp;quot; | &amp;quot;Apple&amp;quot; | &amp;quot;LG&amp;quot;
type WithoutApple = Exclude&amp;lt;PhoneBrands, &amp;quot;Apple&amp;quot;&amp;gt; // &amp;#39;Samsung&amp;#39; | &amp;#39;LG&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Record&lt;/h4&gt;
&lt;p&gt;key-value 값 형태의 객체 타입을 만들어줌&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type PhoneBrands = &amp;quot;Samsung&amp;quot; | &amp;quot;Apple&amp;quot; | &amp;quot;LG&amp;quot;
interface Phone {
  cpu: string
  ram: string
  sim: string
}
type PhoneComponent = Record&amp;lt;PhoneBrands, Phone&amp;gt;
/*
 type PhoneComponent = {
  Samsung: Phone
  Apple: Phone
  LG: Phone
}
*/&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;맵드 타입&lt;/h2&gt;
&lt;p&gt;이미 정의된 타입을 가지고 새로운 타입을 만들어줌&lt;/p&gt;
&lt;h4&gt;in&lt;/h4&gt;
&lt;p&gt;유니온타입의 원소를 하나씩 순회하면서 string 형태로 뽑아줌&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type PhoneBrands = &amp;quot;Samsung&amp;quot; | &amp;quot;Apple&amp;quot; | &amp;quot;LG&amp;quot;
type Phone = {
  [brand in PhoneBrands]: string
}
/*
type Phone = {
    Samsung: string;
    Apple: string;
    LG: string;
}
*/&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;in keyof&lt;/h4&gt;
&lt;p&gt;객체의 각 속성을 하나씩 순회하면서 string 형태로 뽑아줌&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  ram: string
  sim: string
}
type PhoneIncluded = {
  [phone in keyof Phone]: boolean
}
/*
type PhoneIncluded = {
    cpu: boolean;
    ram: boolean;
    sim: boolean;
}
*/&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yes24.com/Product/Goods/119410497&quot;&gt;쉽게 시작하는 타입스크립트(장기효)&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[pinia 소개 및 도입 후기]]></title><description><![CDATA[pinia란? 기존 vue의 전역 상태관리 라이브러리는 거의 가 독점하다시피 한 시장이었다. 옆 동네 react만 하더라도 ,,,와 같이 여러 라이브러리 중에서 선택할 수 있었지만, vue에서는 선택권 없이 사실상 9…]]></description><link>null/vue/230704-start-pinia/</link><guid isPermaLink="false">null/vue/230704-start-pinia/</guid><pubDate>Tue, 04 Jul 2023 22:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;pinia란?&lt;/h2&gt;
&lt;p&gt;기존 vue의 전역 상태관리 라이브러리는 거의 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;가 독점하다시피 한 시장이었다. 옆 동네 react만 하더라도 &lt;code class=&quot;language-text&quot;&gt;redux&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;recoil&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;MobX&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;zustand&lt;/code&gt;와 같이 여러 라이브러리 중에서 선택할 수 있었지만, vue에서는 선택권 없이 사실상 99% &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 써야했다. 오히려 이 점이 학습에 대한 부담(여러 라이브러리 두루 알고 있어야 함)을 줄여주기도 했지만, vuex의 아쉬운 점을 대체할 수단이 없다는 단점을 껴안고 있었다.&lt;/p&gt;
&lt;p&gt;그러다가 2019년 11월에 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;의 experiment to redesign(리디자인 실험)으로서 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;가 처음 출시되었고, 현재는 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 대신하여 vue의 공식 상태관리 라이브러리로 자리잡았다. 이름은 달라졌다고는 해도 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt; 개발팀이 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;를 개발했기 때문에 기존 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;의 기능과 문법은 거의 바뀌지 않았고 새로 학습해야할 내용도 부담 없는 수준이다.(공식문서에서는 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;를 &lt;code class=&quot;language-text&quot;&gt;vuex 5&lt;/code&gt;의 다른 이름이라고 소개한다)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://npmtrends.com/pinia-vs-vuex&quot;&gt;npmtrends&lt;/a&gt;를 보더라도 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;와의 격차가 점점 줄어들고 있음을 확인할 수 있다.
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 34.177215189873415%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA5UlEQVR42lVRC67EIAj0/jfdZPO2La2KAvMC9LNrMgEHcEAK9w4zgwFpVaCqYaEDlSfenwV6/EE8SSfsgud/15qirOsKa44N1ncY79DwKTkmgAk2GqwtyfMevDWC1eWp7YTSvMPZYTJCwZVU5VF2eIxe2RW+eJ/EY17vvndYaz3bxT1CjJxEQmZMEefi7mef4zWFiFzqJynU1DBFwaJhXWRI4mDB1gVbEyxVsLYZPnVBOWrF3v2iNzKY/s5pP1VAp9+nQkLwF84VEYkOLjhZW8cY8x7bbeucmz+3aSZgZqjavWH/w3+SAyeNoekG7wAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;npm trends pinia&quot;
        title=&quot;&quot;
        src=&quot;/static/c5bf99a91716a6dc0ec17d96e55aae29/f058b/npm-trends-pinia.png&quot;
        srcset=&quot;/static/c5bf99a91716a6dc0ec17d96e55aae29/c26ae/npm-trends-pinia.png 158w,
/static/c5bf99a91716a6dc0ec17d96e55aae29/6bdcf/npm-trends-pinia.png 315w,
/static/c5bf99a91716a6dc0ec17d96e55aae29/f058b/npm-trends-pinia.png 630w,
/static/c5bf99a91716a6dc0ec17d96e55aae29/40601/npm-trends-pinia.png 945w,
/static/c5bf99a91716a6dc0ec17d96e55aae29/78612/npm-trends-pinia.png 1260w,
/static/c5bf99a91716a6dc0ec17d96e55aae29/1cb21/npm-trends-pinia.png 2586w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;vuex와 비교해 달라진 점&lt;/h2&gt;
&lt;h4&gt;1. 다중 store&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;에서 여러 종류의 store를 사용할 경우 일반적으로 modules 디렉토리 밑에 몰아넣고 &lt;code class=&quot;language-text&quot;&gt;index.js&lt;/code&gt;에서 하나로 합쳐주는 방식을 사용하였다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;// vuex
src
└── store
    ├── index.js
    └── modules
        ├── counter.js
        ├── user.js
        ├── order.js
        └── ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 다중store를 지원하기 때문에 modules를 사용할 필요가 없어졌다. 따라서 stores 디렉토리 밑에 모든 store를 둘 수 있게 되었다. (개인 선호에 따라 &lt;code class=&quot;language-text&quot;&gt;stores/index.js&lt;/code&gt;를 두어서 기본 설정을 초기화하는 코드를 작성하기도 한다.)&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
src
└── stores
    ├── counter.js
    ├── user.js
    ├── order.js
    └── ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;2. mutation 없이 state의 직접 변경 가능&lt;/h4&gt;
&lt;p&gt;기존 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;에서는 state의 값을 변경하려면 반드시 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;을 통해야 했다.&lt;br&gt;
가령 &lt;code class=&quot;language-text&quot;&gt;count&lt;/code&gt;라는 state와 이 값을 증가시키는 &lt;code class=&quot;language-text&quot;&gt;increment&lt;/code&gt;라는 함수가 있다고 하자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// vuex
const store = createStore({
  state: {
    count: 1,
  },
  mutations: {
    increment(state) {
      state.count++
    },
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;count&lt;/code&gt;값을 증가시키기 위해서는 반드시 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;에 등록된 함수를 통해서만 접근해야 한다.
&lt;code class=&quot;language-text&quot;&gt;store.state.count++&lt;/code&gt;처럼 직접적으로 state를 변경시키는 건 허용되지 않았다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// vuex
&amp;lt;template&amp;gt;
  &amp;lt;p&amp;gt;{{ $store.state.count }}&amp;lt;/p&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  ...
  setup(){
    // store.state.count++; // 직접 변형 불가
    store.commit(&amp;#39;increment&amp;#39;); // 반드시 mutation을 통해서만 변형
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;p&gt;하지만 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;이 사라지고 값의 직접 변형이 가능해졌다. 따라서 매번 state값을 변경하기 위한 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;함수를 만들 필요가 없어졌기 때문에 상당히 편리해졌다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
export const useCounterStore = defineStore(&amp;quot;counter&amp;quot;, {
  state: () =&amp;gt; {
    return {
      count: 1,
    }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그러면 &lt;code class=&quot;language-text&quot;&gt;counterStore&lt;/code&gt;로 받아오기만 하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
&amp;lt;template&amp;gt;
  &amp;lt;p&amp;gt;{{ counterStore.count }}&amp;lt;/p&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  ...
  setup(){
    const counterStore = useCounterStore();
    counterStore.count++; // 직접 변경 가능
    return{
      counterStore,
    }
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;변경해야 하는 값이 복잡하거나, 따로 함수로 분리하고 싶다면 &lt;code class=&quot;language-text&quot;&gt;actions&lt;/code&gt;에서 선언하거나 혹은 아래에서 설명할 &lt;code class=&quot;language-text&quot;&gt;$patch&lt;/code&gt; 라는 내장 메소드를 사용하면 된다.&lt;/p&gt;
&lt;h4&gt;3. Typescript 호환성 증가&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;에서는 도입하기 까다로웠던 &lt;code class=&quot;language-text&quot;&gt;typescript&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 쉽게 사용할 수 있게 되었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
interface VueLib {
  state: &amp;quot;vuex&amp;quot; | &amp;quot;pinia&amp;quot;
}

export const useCounterStore = defineStore(&amp;quot;counter&amp;quot;, {
  state: () =&amp;gt; {
    return {
      count: 0 as number,
      library: {
        state: &amp;quot;pinia&amp;quot;,
      } as VueLib,
    }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;프로젝트 도입 후기&lt;/h2&gt;
&lt;h4&gt;1. mutation 이 없어서 정말 편리하다&lt;/h4&gt;
&lt;p&gt;위에서 언급했다시피 state값의 직접 변형이 가능하기 때문에 별도의 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;을 선언할 필요가 없다는 점이 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;로 개발하면서 느꼈던 답답함을 한방에 뚫어주는듯한 기분이다. 덕분에 &lt;code class=&quot;language-text&quot;&gt;store&lt;/code&gt; 코드의 절반 가량을 차지하던 부분이 사라졌으니 코드가 상당히 가벼워지고 가독성도 나아졌다.&lt;/p&gt;
&lt;h4&gt;2. 생각보다 유용한 내장 메소드&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 Option API 기준으로 3개의 내장 메소드를 갖고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$reset()&lt;/code&gt; : 현재 store의 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt; 값들을 모두 초기화시킨다. 예를 들어 회원 로그인시 회원 데이터를 store에 갖고 있다가 로그아웃을 하면 값을 초기화해주어야 할 때 사용한다. 기존 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;에서는 개발자가 직접 reset함수를 만들어야 했는데 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt; 에서는 그럴 필요가 없어졌다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$patch(state)&lt;/code&gt; : state값을 변경시켜주는 함수이다. &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;는 값의 직접 변경이 가능한데 왜 굳이 필요한가 싶을 수 있는데, 여러 변수들의 값을 한번(함수 하나)에 변경하려고 할 때나 값의 변경 로직이 복잡해지면 오히려 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;이 그리워 질 수도 있다. &lt;code class=&quot;language-text&quot;&gt;$patch()&lt;/code&gt;함수가 그 역할을 대신한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;counterStore.$patch({ count: 1 })
OR
counterStore.$patch(state =&amp;gt; {
  state.count = state.count + 1
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;$subscribe(mutation,state)&lt;/code&gt; : 현재 store의 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt;값을 &lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;하는 기능이라고 생각하면 된다. 프로젝트에서는 이 기능을 써보지 않아서 정확히 어떤 상황에 필요할 지는 잘 모르겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. modules가 없어져서 코드 양은 쪼금 늘어날 수 있다&lt;/h4&gt;
&lt;p&gt;개인적으로 한가지 아쉬운 점은 모든 store를 하나로 묶어주는 modules 기능의 부재로 인하여 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;template&lt;/code&gt;레벨에서 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt;값을 가져올 때처럼 &lt;code class=&quot;language-text&quot;&gt;$store.state.[store이름]&lt;/code&gt; 식으로 접근할 수 없다는 점이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// vuex
&amp;lt;tempalate&amp;gt;
  &amp;lt;div&amp;gt;{{$store.state.counter.count}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 반드시 &lt;code class=&quot;language-text&quot;&gt;script&lt;/code&gt;레벨에서 &lt;code class=&quot;language-text&quot;&gt;use*Store()&lt;/code&gt; 훅을 이용하여 &lt;code class=&quot;language-text&quot;&gt;*store&lt;/code&gt;를 한번 빼와야만 &lt;code class=&quot;language-text&quot;&gt;template&lt;/code&gt;레벨에서도 값을 전달할 수 있다. 그래서 코드의 양이 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;대비 늘어날 수도 있다. 그렇다고 이거 하나가 단점이라 지적하기엔 사소한 문제이고 1,2번에서 얻을 수 있는 이점이 훨씬 더 크다고 생각한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
&amp;lt;tempalate&amp;gt;
  &amp;lt;div&amp;gt;{{counterStore.count}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  ...
  setup(){
    const counterStore = useCounterStore();
    return{
      counterStore,
    }
  }
  &amp;lt;/script&amp;gt;
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;총평&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;와 비교하여 typescript 지원, mutation 삭제, 다중 store지원 같은 기능으로 인하여 DX(개발 경험)을 상당히 개선시켜 주었다. 커뮤니티와 자료의 양이 아직 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;만큼은 아니지만 조금씩 쌓여나가고 있다는 점에서 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt; 도입을 주저하는 개발자가 있다면 주저하지 말고 한번 써보라고 추천하고 싶다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[v-model 원리와 커스텀 컴포넌트 만들기 (2 of 2)]]></title><description><![CDATA[2023-04-0…]]></description><link>null/vue/230702-vmodel-and-custom-component-2/</link><guid isPermaLink="false">null/vue/230702-vmodel-and-custom-component-2/</guid><pubDate>Sun, 02 Jul 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-04-04에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/226&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juheon.dev/vue/230701-vmodel-and-custom-component-1/&quot;&gt;지난 포스팅&lt;/a&gt;에서 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;의 작동원리와 커스텀 컴포넌트를 만드는 방법에 대해서 살펴보았다. 이번 포스팅에서는 만들어진 컴포넌트에다 각각의 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt; 특성에 맞는 로직을 구현해보도록 하겠다.&lt;/p&gt;
&lt;h2&gt;기본 구조&lt;/h2&gt;
&lt;p&gt;부모 컴포넌트인 &lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;와 전화번호를 위한 &lt;code class=&quot;language-text&quot;&gt;InputContact.vue&lt;/code&gt;, 이메일을 위한 &lt;code class=&quot;language-text&quot;&gt;InputEmail.vue&lt;/code&gt;를 자식 컴포넌트로 구성한다. 자식 컴포넌트는 지난 포스팅에서 다루었던 &lt;code class=&quot;language-text&quot;&gt;MyInput.vue&lt;/code&gt;를 베이스로 작성했다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;App.vue
└── MainPage.vue
  ├── InputContact.vue
  └── InputEmail.vue&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;연락처와 이메일과 관련된 변수는 당연히 &lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;에서만 관리하고, 두 &lt;code class=&quot;language-text&quot;&gt;Input*.vue&lt;/code&gt;에는 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;로 전달하여 데이터 처리 로직 수행 후, &lt;code class=&quot;language-text&quot;&gt;emit(&apos;update:modelValue&apos;)&lt;/code&gt;로 가공된 데이터를 넘겨주는 방식이다.&lt;/p&gt;
&lt;h2&gt;전화번호를 위한 input&lt;/h2&gt;
&lt;p&gt;전화번호를 입력하는 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt;을 생각해보자. 우선적으로 필요한 기능은 전화번호 사이마다 &apos;-&apos;를 넣어주는 기능이다. 예를 들어 사용자가 &lt;code class=&quot;language-text&quot;&gt;01012345678&lt;/code&gt;를 입력한다면 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;010-1234-5678&lt;/code&gt;로 표시되도록 해야한다.&lt;/p&gt;
&lt;p&gt;그래서 일단 전화번호 포맷팅을 수행하는 &lt;code class=&quot;language-text&quot;&gt;formatContact()&lt;/code&gt; 함수에 정규표현식을 사용하려고 한다. 전화번호 포맷팅 관련 정규표현식은 구글링을 해봐도 쉽게 찾을 수 있지만 내가 사용한 정규표현식은 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const formatContact = rawString =&amp;gt; {
  const formatted = rawString
    .replace(/[^0-9]/g, &amp;quot;&amp;quot;) // 숫자만 필터링하기
    .replace(/^(\d{0,3})(\d{0,4})(\d{0,4})$/g, &amp;quot;$1-$2-$3&amp;quot;) // 3,4,4자리로 끊고 -로 구분
    .replace(/(\-{1,2})$/g, &amp;quot;&amp;quot;) //아직 숫자 입력되기 전의 -는 가려주기
  return formatted
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이 &lt;code class=&quot;language-text&quot;&gt;formatContact&lt;/code&gt;함수를 &lt;code class=&quot;language-text&quot;&gt;@input&lt;/code&gt;의 콜백함수에 넣어주고, &lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;함수를 호출할 때도 &lt;code class=&quot;language-text&quot;&gt;formatted&lt;/code&gt;된 값을 부모 컴포넌트(&lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;)에 넘겨야한다.&lt;/p&gt;
&lt;h4&gt;InputContact.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;...

const emit = defineEmits([&amp;quot;update:modelValue&amp;quot;]);

const onInput = (e) =&amp;gt; {
  const newValue = e.target.value;
    const formatted = formatContact(newValue);
    emit(&amp;quot;update:modelValue&amp;quot;, newValue);
};

const formatContact = (rawString) =&amp;gt; {
  const formatted = rawString
    .replace(/[^0-9]/g, &amp;quot;&amp;quot;) // 숫자만 필터링하기
    .replace(/^(\d{0,3})(\d{0,4})(\d{0,4})$/g, &amp;quot;$1-$2-$3&amp;quot;) // 3,4,4자리로 끊고 -로 구분
    .replace(/(\-{1,2})$/g, &amp;quot;&amp;quot;); //아직 숫자 입력되기 전의 -는 가려주기
  return formatted;
};
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;는 그냥 일반적인 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt; 태그를 다룰 때처럼만 작성하면 된다. 커스텀 컴포넌트로 변경했다고 한들, 부모 컴포넌트가 데이터 처리 로직에 관여해서 안되고 &lt;code class=&quot;language-text&quot;&gt;Input*.vue&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;되는 이벤트에만 의존하고 있어야 한다.&lt;/p&gt;
&lt;h4&gt;MainPage.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;InputContact v-model=&amp;quot;contact&amp;quot; /&amp;gt;
    &amp;lt;p&amp;gt;contact : {{ contact }}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
import { ref } from &amp;quot;vue&amp;quot;;
import InputContact from &amp;quot;@/components/InputContact.vue&amp;quot;;

const contact = ref(&amp;quot;&amp;quot;);
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;선택적으로 포맷팅하고 싶다면?&lt;/h4&gt;
&lt;p&gt;위 코드에서는 전화번호가 항상 포맷팅되지만, 상황에 따라서는 포맷팅되지 않는 걸 원할 수도 있다. &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;로 &lt;code class=&quot;language-text&quot;&gt;useFormat&lt;/code&gt; 을 받아서 이 값이 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;일 때만 포맷팅되도록 할 수도 있다.&lt;/p&gt;
&lt;h4&gt;InputContact.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const props = defineProps({
  modelValue: String,
  useFormat: {
    type: Boolean,
    default: true,
  },
})

const emit = defineEmits([&amp;quot;update:modelValue&amp;quot;])

const onInput = e =&amp;gt; {
  const newValue = e.target.value
  if (props.useFormat) {
    const formatted = formatContact(newValue)
    emit(&amp;quot;update:modelValue&amp;quot;, formatted)
  } else {
    emit(&amp;quot;update:modelValue&amp;quot;, newValue)
  }
}

const formatContact = rawString =&amp;gt; {
  const formatted = rawString
    .replace(/[^0-9]/g, &amp;quot;&amp;quot;) // 숫자만 필터링하기
    .replace(/^(\d{0,3})(\d{0,4})(\d{0,4})$/g, &amp;quot;$1-$2-$3&amp;quot;) // 3자리,4자리,4자리로 끊고 -로 구분하기
    .replace(/(\-{1,2})$/g, &amp;quot;&amp;quot;) //아직 숫자 입력되기 전의 -는 가려주기
  return formatted
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;MainPage.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  &amp;lt;InputContact :useFormat=&amp;quot;true&amp;quot; v-model=&amp;quot;contact&amp;quot; /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;이메일을 위한 input&lt;/h2&gt;
&lt;p&gt;이번에는 이메일을 입력받는 &lt;code class=&quot;language-text&quot;&gt;InputEmail.vue&lt;/code&gt;를 살펴볼텐데, 전화번호와는 다르게 유효성을 검증하는 기능을 하나 추가하려고 한다. 이메일 유효성을 검증하는데에도 역시 구글링해보면 정규표현식이 많이 나오긴 하지만 여기서는 편하게 &lt;code class=&quot;language-text&quot;&gt;email-validator&lt;/code&gt;라는 npm 패키지를 사용했다.&lt;/p&gt;
&lt;p&gt;큰 틀에서는 &lt;code class=&quot;language-text&quot;&gt;InputContact.vue&lt;/code&gt;와 동일하나, &lt;code class=&quot;language-text&quot;&gt;@input&lt;/code&gt; 이벤트마다 유효성 검증을 거친 값을 부모 컴포넌트인 &lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;으로 전달해주어야 한다. 따라서 나는 &lt;code class=&quot;language-text&quot;&gt;emit(&apos;is-valid&apos;,유효성여부)&lt;/code&gt;으로 지정했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;input type=&amp;quot;email&amp;quot; :value=&amp;quot;modelValue&amp;quot; @input=&amp;quot;onInput&amp;quot; /&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
import { ref } from &amp;quot;vue&amp;quot;;
import * as EmailValidator from &amp;quot;email-validator&amp;quot;;

const props = defineProps({
  modelValue: String,
});

const emit = defineEmits([&amp;quot;update:modelValue&amp;quot;, &amp;quot;is-valid&amp;quot;]);

const onInput = (e) =&amp;gt; {
  const newValue = e.target.value;
  const isEmailValid = checkEmailValid(newValue);
  emit(&amp;quot;is-valid&amp;quot;, isEmailValid);
  emit(&amp;quot;update:modelValue&amp;quot;, newValue);
};

const checkEmailValid = (email) =&amp;gt; {
  return EmailValidator.validate(email);
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그러면 &lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;에서는 &lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;으로 보낸 값을 &lt;code class=&quot;language-text&quot;&gt;@is-valid&lt;/code&gt;로 받고 콜백함수에서 유효성 여부를 인자로 받을 수 있다. 콜백함수를 위한 별도의 함수를 하나 만들어도 되긴 하는데, 예제 상에서는 만들지 않고 &lt;code class=&quot;language-text&quot;&gt;isEmailValid&lt;/code&gt;라는 변수에 직접 넣어주는 방식을 선택하였다.&lt;/p&gt;
&lt;h4&gt;MainPage.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;InputEmail v-model=&amp;quot;email&amp;quot; @is-valid=&amp;quot;(data) =&amp;gt; (isEmailValid = data)&amp;quot; /&amp;gt;
    &amp;lt;p&amp;gt;email : {{ email }}&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;valid : {{ isEmailValid }}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
import { ref } from &amp;quot;vue&amp;quot;;
import InputEmail from &amp;quot;@/components/InputEmail.vue&amp;quot;;

const email = ref(&amp;quot;&amp;quot;);

const isEmailValid = ref(null);
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue-custom-input-2-mcx2wv?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;vue-custom-input-2&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[v-model 원리와 커스텀 컴포넌트 만들기 (1 of 2)]]></title><description><![CDATA[2023-04-0…]]></description><link>null/vue/230701-vmodel-and-custom-component-1/</link><guid isPermaLink="false">null/vue/230701-vmodel-and-custom-component-1/</guid><pubDate>Sat, 01 Jul 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-04-04에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/226&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;반복되는 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt; 태그&lt;/h2&gt;
&lt;p&gt;사용자에게 입력을 받기 위해서는&lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt;태그가 필요한데, 입력 받는 데이터의 종류와 특성에 따라 제공되는 기능이 달라질 수 있다. 예를 들어 &apos;오늘의 집&apos;의 주문 페이지를 살펴보자.&lt;/p&gt;
&lt;div align=&quot;center&quot; height=&quot;600&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/hjhj97/blog.gatsby/main/content/blog/vue/230701-vmodel-and-custom-component-1/input-tag-1.png&quot; height=&quot;600&quot;&gt;
&lt;/div&gt;
&lt;!--![](./input-tag-1.png)--&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이름이나 주소같은 단순한 텍스트 : &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&quot;text&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문자가 아닌 오직 숫자만 입력받을 경우(상품 수량) &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&quot;number&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전화번호 형식 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&quot;tel&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이메일 형식 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&quot;email&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이처럼 같은 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt;태그라도 각각의 특성과 수행해야 될 기능이 다르다.&lt;br&gt;
이름이나 주소의 경우에는 빈 문자열이어서는 안된다거나 최소/최대 글자수 제한이 있을 수 있고, 전화번호나 이메일은 유효성 검증을 거쳐야 할 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt;속성으로으로도 어느정도 해결할 수는 있지만, 이러한 기능을 가진 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt; 태그들이 프로젝트에서 반복적으로 사용된다면 컴포넌트로 분리시켜 공통화하고 싶다는 생각이 든다. 그러면 각 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Input&gt;&lt;/code&gt; 컴포넌트별로 특정 기능에만 집중할 수 있다. 그렇다면 커스텀 컴포넌트화 시키려면 어떻게 해야하는지 살펴볼 건데, 그 전에 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;의 작동원리에 대해서 알아보자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;의 작동원리&lt;/h2&gt;
&lt;p&gt;vue의 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;은 양방향 데이터바인딩(two-way binding) 기능을 제공하는 &lt;code class=&quot;language-text&quot;&gt;directive&lt;/code&gt;이다.&lt;br&gt;
양방향 바인딩이란, 화면상에 보이는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt;에 데이터를 입력(수정)할 때마다 &lt;code class=&quot;language-text&quot;&gt;Javascript&lt;/code&gt;에서도 실시간으로 변화를 감지하여 값이 업데이트 되는 기능이다.&lt;/p&gt;
&lt;p&gt;SPA 라이브러리를 vue로 처음 입문한 사람에게는 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;이 왜 편리한 기능인지 이해하기 어려울 수 있지만, react를 접한 뒤에 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;을 만난다면 그 편리함에 감탄할 것이다. 왜냐하면 react에서 양방향 바인딩을 구현하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt;태그에 다음와 같이 작성해야만 했다.&lt;/p&gt;
&lt;h4&gt;react&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const [text, setText] = useState(&amp;quot;&amp;quot;)
const onInputChange = e =&amp;gt; {
  setText(e.target.value)
}
...
return &amp;lt;input onChange={onInputChange} value={text} /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 이를 vue에서 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;로 구현한다면 간단하게 구현할 수 있다.&lt;/p&gt;
&lt;h4&gt;vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// &amp;lt;template&amp;gt;
&amp;lt;input v-model=&amp;quot;text&amp;quot;&amp;gt;
// &amp;lt;script setup&amp;gt;
const text = ref(&amp;#39;&amp;#39;);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;두 코드 사이에서 주목해야 할 점은 react의 경우에 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt; 태그에 &lt;code class=&quot;language-text&quot;&gt;onChange&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 2개가 필요한 반면에, vue에서는 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt; 단 하나만 필요하다는 점이다. 단순히 생각해보더라도 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;onChange&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 2개의 역할을 동시에 수행하고 있으리라 예상할 수 있다.&lt;br&gt;
사실은 vue도 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;을 사용하지 않고 양방향 바인딩을 구현해보자면 아래와 같이 구현해야 했다.&lt;/p&gt;
&lt;h4&gt;vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// &amp;lt;template&amp;gt;
&amp;lt;input @change=&amp;quot;onChangeInput&amp;quot; :value=&amp;quot;text&amp;quot;&amp;gt;
// &amp;lt;script setup&amp;gt;
const text = ref(&amp;#39;&amp;#39;);
const onChangeInput = (e) =&amp;gt; {
  text.value = e.target.value
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 매번 두 개의 속성을 적어주는 건 성가신 일이기 때문에 이를 하나로 합쳐서 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;이 탄생하게 된 것이다.
vue에서는 이처럼 tag 레벨에서 자주 쓰이는 기능들은 하나의 공통 함수로 묶게 되었는데 이게 바로 vue의 &lt;code class=&quot;language-text&quot;&gt;directive&lt;/code&gt;이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;필자 개인의견 : &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;이 react와 vue가 추구하는 방향성의 다름을 가장 잘 보여주는 대목이다. react는 코드 뒷편에서 무슨 일이 일어나는지 최대한 개발자에게 숨기지 않고 드러내려는 반면, vue는 &apos;이 기능은 라이브러리에서 책임질테니, 무슨 일이 일어나는 지는 신경쓰지 마&apos;라고 말하는 인상이 들었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;커스텀 컴포넌트로 만들기&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt;을 컴포넌트화 시켜서 부모-자식간의 관계가 형성되면 부모 컴포넌트에서 자식 컴포넌트로&lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;를 별도로 연결시켜주어야만 양방향 데이터 바인딩 기능을 유지할 수 있다.&lt;/p&gt;
&lt;p&gt;방법은 어렵지 않다. 부모 컴포넌트 입장에서는 컴포넌트화하기 이전 코드와 동일하게 &lt;code class=&quot;language-text&quot;&gt;v-model=&quot;data&quot;&lt;/code&gt;를 걸어주기만 하면 된다. 이렇게만 하면 자식 컴포넌트의 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;에서 자동으로 &lt;code class=&quot;language-text&quot;&gt;modelValue&lt;/code&gt;라는 (미리 정해진)이름으로 받을 수 있게 된다.&lt;/p&gt;
&lt;p&gt;다만 자식 컴포넌트에서는 별도로 처리해줘야 한다. &lt;code class=&quot;language-text&quot;&gt;v-model=&quot;modelValue&quot;&lt;/code&gt;로 받을 수 있을 것 같지만 아쉽게도 불가능하다. 왜냐하면 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;@input=&quot;() =&gt; modelValue = e.target.value&quot;&lt;/code&gt;가 생략되어있는데, vue에서 자식 컴포넌트가 받은 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;값(여기서는 &lt;code class=&quot;language-text&quot;&gt;modelValue&lt;/code&gt;)의 직접 변형이 불가능하기 때문이다.&lt;/p&gt;
&lt;p&gt;이를 해결하기 위해서는 자식 컴포넌트에서는 input 이벤트가 발생하면 부모 컴포넌트에게 이를 알려야 한다.&lt;br&gt;
자식컴포넌트가 부모컴포넌트에게 이벤트를 발생시키고 싶을 때 호출하는&lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;함수를 통해&lt;br&gt;
&lt;em&gt;&quot;&lt;code class=&quot;language-text&quot;&gt;modelValue&lt;/code&gt;의 값이 &lt;code class=&quot;language-text&quot;&gt;e.target.value&lt;/code&gt;로 변했다&quot;&lt;/em&gt;&lt;br&gt;
는 정보만 전달하고, 실질적인 변경된 값을 반영하는 과정은 부모 컴포넌트에서 진행되야 한다. 다행히도 그 과정은 이미 &lt;code class=&quot;language-text&quot;&gt;update:modelValue&lt;/code&gt;라는 이벤트로 미리 등록되어 있기 때문에 우리가 직접 구현할 필요는 없다.&lt;/p&gt;
&lt;h4&gt;MainPage.vue (parent)&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;MyInput v-model=&amp;quot;num&amp;quot; /&amp;gt;
    &amp;lt;p&amp;gt;text : {{ num }}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
import { ref } from &amp;quot;vue&amp;quot;;
import MyInput from &amp;quot;@/components/MyInput.vue&amp;quot;;

const num = ref(&amp;quot;Hello&amp;quot;);
&amp;lt;/script&amp;gt;

&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;MyInput.vue (child)&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;!-- 불가능 --&amp;gt;
  &amp;lt;!-- &amp;lt;input v-model=&amp;quot;modelValue&amp;quot; /&amp;gt;  --&amp;gt;

  &amp;lt;input :value=&amp;quot;modelValue&amp;quot; @input=&amp;quot;onInput&amp;quot; /&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
const props = defineProps({
  modelValue: String,
});

const emit = defineEmits([&amp;quot;update:modelValue&amp;quot;]);

const onInput = (e) =&amp;gt; {
  const newValue = e.target.value;
  emit(&amp;quot;update:modelValue&amp;quot;, newValue);
};
&amp;lt;/script&amp;gt;

&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue-custom-input-3tnt3q?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;vue-custom-input&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;
&lt;p&gt;&lt;em&gt;다음 포스팅에서 &apos;input 종류별로 기능 적용하기&apos;를 소개하겠습니다&lt;/em&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[react에는 named-route 없나요?(Feat. vue에는 있는데..)]]></title><description><![CDATA[2023-05-05에 작성된 원문을 수정한 버전입니다 vue-router를 사용하는 두 가지 방법 vue…]]></description><link>null/vue/230630-vue-named-route/</link><guid isPermaLink="false">null/vue/230630-vue-named-route/</guid><pubDate>Fri, 30 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-05-05에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/229&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;vue-router를 사용하는 두 가지 방법&lt;/h2&gt;
&lt;p&gt;vue에서는 &lt;code class=&quot;language-text&quot;&gt;vue-router&lt;/code&gt;에서 제공하는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;router-link&gt;&lt;/code&gt; 컴포넌트로 페이지 이동을 하려면 크게 두 가지 방법이 있는데, 하나는 해당 페이지의 &lt;code class=&quot;language-text&quot;&gt;pathname&lt;/code&gt;을 직접 적는 방법과 다른 하나는 &lt;code class=&quot;language-text&quot;&gt;router&lt;/code&gt;에서 미리 정의해둔 &lt;code class=&quot;language-text&quot;&gt;route name&lt;/code&gt;을 적는 방법이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 방법 1
&amp;lt;router-link to=&amp;quot;/&amp;quot;&amp;gt;홈&amp;lt;/router-link&amp;gt;
&amp;lt;router-link to=&amp;quot;/about&amp;quot;&amp;gt;어바웃&amp;lt;/router-link&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 방법 2
&amp;lt;router-link :to=&amp;quot;{name : &amp;#39;Home&amp;#39;}&amp;quot;&amp;gt;홈&amp;lt;/router-link&amp;gt;
&amp;lt;router-link :to=&amp;quot;{name : &amp;#39;About&amp;#39;}&amp;quot;&amp;gt;어바웃&amp;lt;/router-link&amp;gt;

// 그리고 vue-router에서 미리 route별로 name을 지정해주어야 한다
const routes = [
	{
		path: &amp;#39;/&amp;#39;,
		name: &amp;#39;Home&amp;#39;,
		component: ...,
	},
	{
		path: &amp;#39;/about&amp;#39;,
		name: &amp;#39;About&amp;#39;,
		component: ...,
	},
]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;하지만 오타가 난다면?&lt;/h2&gt;
&lt;p&gt;나는 개발할 때 주로 방법 2를 선호하는데 그 이유는 방법 1의 경우에는 경로명을 잘못 입력하더라도 에러로 검출해내지 못하고 클릭하면 &lt;code class=&quot;language-text&quot;&gt;/abou&lt;/code&gt;페이지로 이동시켜버리는 반면에, 방법 2는 아래와 같이 개발자 도구의 콘솔창에서 에러를 띄워주기 때문이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 방법 1
&amp;lt;router-link to=&amp;quot;/&amp;quot;&amp;gt;홈&amp;lt;/router-link&amp;gt;
&amp;lt;router-link to=&amp;quot;/abou&amp;quot;&amp;gt;어바웃&amp;lt;/router-link&amp;gt; // 오타, 에러 발생X&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 방법 2
&amp;lt;router-link :to=&amp;quot;{name : &amp;#39;Home&amp;#39;}&amp;quot;&amp;gt;홈&amp;lt;/router-link&amp;gt;
&amp;lt;router-link :to=&amp;quot;{name : &amp;#39;Abou&amp;#39;}&amp;quot;&amp;gt;어바웃&amp;lt;/router-link&amp;gt; // 오타, 에러 발생함&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/ce3ee02400fcbc8fb937fed74135d507/64639/named-route-error.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 23.417721518987342%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA2ElEQVR42o3JW1OCQABAYf7/f6qnrMwxEbkYphOWGMjuchVE2NNEUy/WTA/fnIdjhMEIlVhkyqMQLlVsUec+TfE89FSu4by71IW0dUCVbzgWG8p8TVO9YBztB/Rqgd6u6OSePj8MdCmgklBKKJJfteqdOtkNGhHSyD0GkyncjGhnJjvHI1g4vNoupyjmfBCg0j/1UtEJ+aMXCkPf3sHVNYzHpKZJYM7xpo/4psWb7YJUkKb/lGFoawaTe3DmlL5H9OQReA7bpUO0WtKLGJ0KyL7JC/pT+vU+AO/YeJJTSVuIAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;named route error&quot;
        title=&quot;&quot;
        src=&quot;/static/ce3ee02400fcbc8fb937fed74135d507/f058b/named-route-error.png&quot;
        srcset=&quot;/static/ce3ee02400fcbc8fb937fed74135d507/c26ae/named-route-error.png 158w,
/static/ce3ee02400fcbc8fb937fed74135d507/6bdcf/named-route-error.png 315w,
/static/ce3ee02400fcbc8fb937fed74135d507/f058b/named-route-error.png 630w,
/static/ce3ee02400fcbc8fb937fed74135d507/40601/named-route-error.png 945w,
/static/ce3ee02400fcbc8fb937fed74135d507/78612/named-route-error.png 1260w,
/static/ce3ee02400fcbc8fb937fed74135d507/64639/named-route-error.png 1568w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;방법 1은 오타가 발생하더라도 해당 라우터를 클릭해서 404 페이지가 뜨는 걸 확인하기 전까지는 찾기가 어렵다. 왜냐하면 사용자가 오타를 낸 건지, 아니면 정말로 &lt;code class=&quot;language-text&quot;&gt;/abou&lt;/code&gt;페이지로 이동하길 원하는지 라우터에게는 알 수 있는 정보가 없기 때문이다.&lt;/p&gt;
&lt;p&gt;반면에 방법 2에서는 라우터를 클릭하기 전에도 콘솔창에서 에러를 검출할 수 있다. &lt;code class=&quot;language-text&quot;&gt;routes&lt;/code&gt;에 들어있는 원소를 하나씩 뒤져보면서 name이 &lt;code class=&quot;language-text&quot;&gt;Abou&lt;/code&gt;와 일치하는 라우트를 찾아본다. 일치하는 라우트가 없으면 에러로 판별해낼 수 있는 단서가 제공된다는 뜻이다.&lt;/p&gt;
&lt;p&gt;이런 식으로 vue 에서는 &lt;code class=&quot;language-text&quot;&gt;named-route&lt;/code&gt;기반으로 페이지 이동이 가능하기 때문에 예상치 못한 오타 발생시 에러로 검출할 수 있는 반면에 react에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Link to={&apos;/about&apos;}&lt;/code&gt; 또는 &lt;code class=&quot;language-text&quot;&gt;useNavigate&lt;/code&gt;훅의 &lt;code class=&quot;language-text&quot;&gt;navigate(&apos;/about&apos;)&lt;/code&gt;와 같이 &lt;code class=&quot;language-text&quot;&gt;pathname&lt;/code&gt; 기반으로만 이동할 수 있다.&lt;/p&gt;
&lt;p&gt;따라서 위의 언급한 방법 1처럼 오타로 인한 route 이동을 막을 수 있는 방법은 아직까지는 찾지 못하였다. 타입스크립트로 &lt;code class=&quot;language-text&quot;&gt;pathname&lt;/code&gt;을 &lt;code class=&quot;language-text&quot;&gt;enum&lt;/code&gt;이나 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt;으로 변수화시키는 방법이라면 가능할 지도 모르겠다는 생각은 드는데, 실무에서도 그렇게 개발할 지는 모르겠다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;현재 페이지 판별&lt;/h2&gt;
&lt;p&gt;위 주제와 비슷한 궁금증.&lt;/p&gt;
&lt;p&gt;리액트에서는 현재 접속해있는 페이지를 판별하는 방법에 대해서이다.
예를 들어 현재 접속한 페이지와 일치하면 class에 &lt;code class=&quot;language-text&quot;&gt;isMatched&lt;/code&gt;를 붙여서 하이라이트 스타일을 주는 상황을 생각해보자.
vue로 구현한다면 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  &amp;lt;router-link :to={name : &amp;quot;Home&amp;quot;} class=&amp;quot;{ matched : $route.name === &amp;#39;Home&amp;#39;}&amp;quot;&amp;gt;
    Home
  &amp;lt;/router-link&amp;gt;
  &amp;lt;router-link :to={name : &amp;quot;About&amp;quot;} class=&amp;quot;{ matched : $route.name === &amp;#39;About&amp;#39;}&amp;quot;&amp;gt;
    About
  &amp;lt;/router-link&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;사실상 스크립트 코드를 하나도 작성하지 않고 template 레벨에서만 현재 라우트 일치 여부를 판별해낼 수 있다.&lt;/p&gt;
&lt;p&gt;이걸 react 로 작성해본다면&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function Header() {
  const { pathname: currentPath } = useLocation()
  const isMatch = (path: string) =&amp;gt; {
    if (currentPath === path) return &amp;quot;matched&amp;quot;
  }
  return (
    &amp;lt;Nav&amp;gt;
      &amp;lt;Link to=&amp;quot;/&amp;quot; className={currentPath === &amp;quot;/&amp;quot; ? &amp;quot;matched&amp;quot; : &amp;quot;&amp;quot;}&amp;gt;
        Home
      &amp;lt;/Link&amp;gt;
      &amp;lt;Link to=&amp;quot;/about&amp;quot; className={isMatch(&amp;quot;/about&amp;quot;)}&amp;gt;
        About
      &amp;lt;/Link&amp;gt;
    &amp;lt;/Nav&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;우선 &lt;code class=&quot;language-text&quot;&gt;useLocation&lt;/code&gt;훅을 통해서 현재의 &lt;code class=&quot;language-text&quot;&gt;pathname&lt;/code&gt;을 한번 뽑아와야하며, &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Link&gt;&lt;/code&gt;에서도 클래스를 동적으로 바인딩 할 때도 삼항연산자로 판별하거나, 코드를 줄이려면 &lt;code class=&quot;language-text&quot;&gt;isMatch&lt;/code&gt;함수를 하나 선언해서 인자로 현재 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Link&gt;&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;To&lt;/code&gt; 값을 그대로 넣어줘야 한다(물론 이건 vue도 마찬가지다).&lt;/p&gt;
&lt;p&gt;vue는 template 레벨에서 &lt;code class=&quot;language-text&quot;&gt;$route.name&lt;/code&gt; 으로 현재 라우트 정보를 한방에 가져올 수 있고, class-binding을 할 때에도 &lt;code class=&quot;language-text&quot;&gt;:class={isMatched : someValue}&lt;/code&gt; 에서 &lt;code class=&quot;language-text&quot;&gt;someValue&lt;/code&gt;값이 true면 곧바로 클래스 이름으로 붙일 수 있어 편리하다.&lt;/p&gt;
&lt;p&gt;vue는 &lt;code class=&quot;language-text&quot;&gt;너한테-이런게-필요할거-같았어&lt;/code&gt; 기능(함수)들이 미리 제공되어있는 반면에 react는 &lt;code class=&quot;language-text&quot;&gt;너가-직접-구현하렴&lt;/code&gt;같은 느낌이다.&lt;br&gt;
react는 기능에 대한 부품들만 던져준다면, vue는 그 부품으로 조립까지 해주는 느낌이랄까? 각 라이브러리가 추구하는 방향성의 차이를 알 수 있는 대목이다.&lt;/p&gt;
&lt;p&gt;각자 장단점이 있겠지만, 나 같이 vue를 먼저 익히고 난 뒤에 react에서는 그 기능을 어떻게 구현해야 하는지 찾아보는 입장에서는 조금 답답함이 느껴지는 것도 사실이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[vue-router를 통한 페이지간 state 전달]]></title><description><![CDATA[2023-04-24에 작성된 원문을 수정한 버전입니다 페이지에 state를 전달하는 방법 react에서는 페이지 이동 시 state를 전달하기 위해서는 에서  컴포넌트 또는  훅을 통해 전달이 가능하다. 반면에 vue…]]></description><link>null/vue/230629-vue-router-state/</link><guid isPermaLink="false">null/vue/230629-vue-router-state/</guid><pubDate>Thu, 29 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-04-24에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/227&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;페이지에 state를 전달하는 방법&lt;/h2&gt;
&lt;p&gt;react에서는 페이지 이동 시 state를 전달하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;react-router-dom&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Link&gt;&lt;/code&gt; 컴포넌트 또는 &lt;code class=&quot;language-text&quot;&gt;useNaviate()&lt;/code&gt; 훅을 통해 전달이 가능하다.&lt;br&gt;
반면에 vue에서는 직접적인 전달 방법이 존재하지 않아 개발자 자체적으로 방법을 찾아야 했다. 생각해볼 수 있는 방법으로는&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;와 같은 전역상태 저장소에 넣어두고 꺼내쓰기&lt;br&gt;
=&gt; 일회용 데이터를 위해서 전역상태에 임시 데이터를 넣고 싶지는 않았다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;router.push()&lt;/code&gt;를 하는 코드 직후에 &lt;code class=&quot;language-text&quot;&gt;window.pushState(state)&lt;/code&gt;를 추가해서 페이지가 이동되면 꺼내쓴다&lt;br&gt;
=&gt; 그나마 현실적인 방법이다. 다만 history를 두번으로 push하기 때문에 똑같은 페이지가 히스토리에 스택에 두번 들어가게 된다.&lt;/li&gt;
&lt;li&gt;이동하려는 URL에 쿼리스트링으로 데이터 값을 담아서 전달 하기&lt;br&gt;
=&gt; URL이 괜히 길어지는데다가, 보안상 민감한 데이터는 쿼리스트링에 담기 조심스럽다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;해결방법&lt;/h2&gt;
&lt;p&gt;이런 불편함 때문인지 vue git의 rfc에도 글이 몇 개 올라와 있었고, 드디어 2022년 7월에 &lt;code class=&quot;language-text&quot;&gt;vue-router@4.1.0&lt;/code&gt;버전에서 정식 기능으로 추가되었다(&lt;a href=&quot;https://github.com/vuejs/router/releases/tag/v4.1.0&quot;&gt;링크&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;방법은 간단하다. router에 params를 넣는 방식처럼 state도 객체 형태로 적어주기만 하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;router.push({name &amp;#39;NextPage&amp;#39;, state : { isDetailsOpen : true }})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;다만 꺼낼 때는 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt;값을 &lt;code class=&quot;language-text&quot;&gt;useRoute()&lt;/code&gt;에서 뽑아내는 게 아니라, &lt;code class=&quot;language-text&quot;&gt;windiw.history.state&lt;/code&gt;에서 직접 꺼내야한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const { isDetailsOpen } = window.history?.state || false&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;사실 정식기능으로 추가되었다고는 하더라도 &lt;code class=&quot;language-text&quot;&gt;window.history&lt;/code&gt;객체의 state 힘을 빌리는 정도에 불과하기 때문에 위에서 언급한 임시 해결방법 2번과 거의 유사하다고 볼 수 있다. 또한 이 방법을 사용한다고 하더라도 보안에 민감한 데이터를 전달하기엔 역시나 찝찝한 구석이 있다. 그냥 다음 페이지에의 상태(모달 오픈 여부 등)만 전달하는 데 사용할 수 있을 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[router-view 에서 DOM을 찾지 못하는 문제]]></title><description><![CDATA[2023-04-04에 작성된 원문을 수정한 버전입니다 router-view안에 있는 DOM은 왜 못 찾지? vue로 프론트엔드 개발을 하던 도중,  에서 안에 들어있는 특정 DOM에 접근해야 할 일이 생겼다(정확히 말하자면 태그에 특정 class…]]></description><link>null/vue/230628-router-view-find-dom/</link><guid isPermaLink="false">null/vue/230628-router-view-find-dom/</guid><pubDate>Wed, 28 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-04-04에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/225&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;router-view안에 있는 DOM은 왜 못 찾지?&lt;/h2&gt;
&lt;p&gt;vue로 프론트엔드 개발을 하던 도중, &lt;code class=&quot;language-text&quot;&gt;App.vue&lt;/code&gt; 에서 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt;안에 들어있는 특정 DOM에 접근해야 할 일이 생겼다(정확히 말하자면 태그에 특정 class가 존재 유무를 확인해야 했다).&lt;br&gt;
따라서 &lt;code class=&quot;language-text&quot;&gt;document.querySelector(&apos;.특정클래스&apos;)&lt;/code&gt;함수를 호출하여 해당 DOM에 접근하려고 시도했는데 결과는 예상과 달리 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;로 반환되었다. (파일 구조는 아래와 같이 구성되어있다.)&lt;/p&gt;
&lt;h4&gt;NavBar.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;nav&amp;gt;
    &amp;lt;router-link :to=&amp;quot;{ name: &amp;#39;Home&amp;#39; }&amp;quot;&amp;gt;Home&amp;lt;/router-link&amp;gt;
  &amp;lt;/nav&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Home.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;h1 class=&amp;quot;home&amp;quot;&amp;gt;This is home&amp;lt;/h1&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;App.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;NavBar /&amp;gt;
  &amp;lt;router-view /&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
...
export default {
  components: { NavBar },
  setup() {
    onMounted(async () =&amp;gt; {
      const homeEl = document.querySelector(&amp;quot;.home&amp;quot;);
      const navEl = document.querySelector(&amp;quot;nav&amp;quot;);

      console.log(homeEl); // not found
      console.log(navEl); // found
    });
  },
};
&amp;lt;/script&amp;gt;

&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt;내부에 있는 DOM요소(&apos;home&apos; 클래스)에 접근하는 건데 왜 못 찾는 걸까? 혹시나 하는 마음에 똑같이 글로벌 범위로 사용되는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;nav&gt;&lt;/code&gt;를 찾아보았을 때는 잘 찾고 있었다.&lt;/p&gt;
&lt;p&gt;내 경험상 vue에서 특정 DOM을 찾지 못하는 문제에 부딪혔을 때는 일단 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;으로 딜레이를 걸어서 찾으면 해결되는 경우가 많았다. 그래서 일단 아래와 같이 코드를 수정해보았다.&lt;/p&gt;
&lt;h4&gt;App.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;script&amp;gt;
export default {
  setup() {
    onMounted(() =&amp;gt; {
      setTimeout(()=&amp;gt;{
        const homeEl = document.querySelector(&amp;quot;.home&amp;quot;);
        const navEl = document.querySelector(&amp;quot;nav&amp;quot;);

        console.log(homeEl); // found
        console.log(navEl); // found
      },1000)
    });
  },
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;아니나 다를까, 시간을 두고 DOM을 찾았더니 성공하였다. 우선 가장 무식한(비효율적인) 방법으로는 문제를 해결하기는 했다.&lt;/p&gt;
&lt;p&gt;문제의 원인은 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt;가 &lt;strong&gt;mount 될 때까지 미세하게나마 시간이 소요되기 때문&lt;/strong&gt;이었다.&lt;br&gt;
따라서 &lt;code class=&quot;language-text&quot;&gt;App.vue&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;onMounted()&lt;/code&gt;가 호출되는 시점에는 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt; 의 &lt;code class=&quot;language-text&quot;&gt;Home.vue&lt;/code&gt; 는 아직 mount되기 이전이었기 때문에 DOM에 접근할 수 없었던 것이다. 그에 반해 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;nav&gt;&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt; 내부에 있지 않고 &lt;code class=&quot;language-text&quot;&gt;App.vue&lt;/code&gt;에 독립적으로 존재하기 때문에 mount되는 시간이 훨씬 짧아 접근이 가능하다.&lt;/p&gt;
&lt;h2&gt;해결책은 router.isReady()&lt;/h2&gt;
&lt;p&gt;개발할 때는 워낙 빠릿하게 작동해서 눈치채기는 어렵지만 사실 router가 mount되기까지의 딜레이는 결코 무시할 수 없는 수준으로 꽤 긴 시간이다. 그렇다면 앞으로도 계속 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;으로 강제 딜레이를 넣어줘야 하는 걸까? 당연히 아니다.&lt;code class=&quot;language-text&quot;&gt;vue-router&lt;/code&gt;에서는 이런 문제가 발생할 줄 알고 미리 &lt;code class=&quot;language-text&quot;&gt;router.isReady()&lt;/code&gt;라는 비동기 함수를 만들어 놓았다.&lt;a href=&quot;https://router.vuejs.org/guide/migration/#replaced-onready-with-isready&quot;&gt;공식문서&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;문제를 해결한 코드를 먼저 보자.&lt;/p&gt;
&lt;h4&gt;App.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export default {
  components: { NavBar },
  setup() {
    onMounted(async () =&amp;gt; {
      await router.isReady() // Added!
      const homeEl = document.querySelector(&amp;quot;.home&amp;quot;)
      const navEl = document.querySelector(&amp;quot;nav&amp;quot;)

      console.log(homeEl) // found
      console.log(navEl) // found
    })
  },
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;코드는 &lt;code class=&quot;language-text&quot;&gt;querySelector&lt;/code&gt;로 찾기 전에 &lt;code class=&quot;language-text&quot;&gt;await router.isReady()&lt;/code&gt; 딱 한 줄만 추가했다.&lt;/p&gt;
&lt;p&gt;이 함수는 쉽게 얘기하면 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt; 내부의 파일들이 DOM으로 mount 될 때 까지 기다려주는 역할이다. 모두 mount가 완료되었다면 resolve 해줌으로써 &lt;code class=&quot;language-text&quot;&gt;querySelector&lt;/code&gt;로 접근할 수 있게 된다.&lt;/p&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue-router-isready-tlqd83?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;vue-router-isReady&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[vue-chart에서 비동기 통신 후 화면에 반영하기]]></title><description><![CDATA[2023-03-09에 작성된 원문을 수정한 버전입니다 문제상황 vue3 환경에서 chart.js 라이브러리를 사용하여 차트 데이터를 화면에 그리려고 한다. 그냥 바닐라 JS를 활용할 수도 있겠지만, 더 편리한 방법으로는 vue…]]></description><link>null/vue/230627-vue-async-data/</link><guid isPermaLink="false">null/vue/230627-vue-async-data/</guid><pubDate>Tue, 27 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-03-09에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/221&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;문제상황&lt;/h2&gt;
&lt;p&gt;vue3 환경에서 chart.js 라이브러리를 사용하여 차트 데이터를 화면에 그리려고 한다. 그냥 바닐라 JS를 활용할 수도 있겠지만, 더 편리한 방법으로는 vue 기반으로 래핑해놓은 &lt;a href=&quot;https://vue-chart-3.netlify.app/&quot;&gt;vue-chart-3&lt;/a&gt;를 활용하려고 한다. 그래서 공식문서 &lt;a href=&quot;https://codesandbox.io/s/demo-vue-chart-3-ugynm?from-embed=&amp;#x26;file=/src/App.vue&quot;&gt;데모 페이지&lt;/a&gt;에 나와있는 대로 따라하려고 하니 문제가 하나 생겼다.&lt;/p&gt;
&lt;p&gt;내가 화면에 보여줄 데이터는 서버와 비동기 통신을 통해서 받아온 다음에 그려야 한다. 그런데 데모 소스코드 상에서는 데이터가 아래와 같이 그냥 하드코딩 되어 있었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;    // &amp;lt;template&amp;gt;
    &amp;lt;DoughnutChart :chartData=&amp;quot;testData&amp;quot; /&amp;gt;
    ...

    // &amp;lt;script&amp;gt;
    const dataValues = ref([30, 40, 60, 70, 5]);
    const dataLabels = ref([&amp;quot;Paris&amp;quot;, &amp;quot;Nîmes&amp;quot;, &amp;quot;Toulon&amp;quot;, &amp;quot;Perpignan&amp;quot;, &amp;quot;Autre&amp;quot;]);
    const testData =  {
      labels: dataLabels.value,
      datasets: [
        {
          data: dataValues.value,
        },
      ],
    };&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;실제 chart.js를 활용하는 사례에서는 데이터를 하드코딩해서 넣는 경우보단, 비동기로 넣는 경우가 더 일반적이다. 하지만 chart.js는 차트를 그리는 데 필요한 데이터를 받으면 곧바로 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;canvas&gt;&lt;/code&gt;로 그려버리기 때문에, 그 이후에는 비동기로 데이터가 도착한다고 한들 차트가 변하지 않는다는 문제가 있다.&lt;/p&gt;
&lt;p&gt;예를 들어 아래 코드와 같이 비동기 통신을 가장한 &lt;code class=&quot;language-text&quot;&gt;fetchData&lt;/code&gt;함수가 &lt;code class=&quot;language-text&quot;&gt;onMounted&lt;/code&gt;에서 실행된다 하더라도 차트는 그려지지 않는다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const dataValues = ref([])
const dataLabels = ref([])

onMounted(() =&amp;gt; {
  fetchData().then(res =&amp;gt; {
    dataValues.value = res.map(item =&amp;gt; item.data)
    dataLabels.value = res.map(item =&amp;gt; item.label)
  })
})

const testData = {
  labels: dataLabels.value,
  datasets: [
    {
      data: dataValues.value,
    },
  ],
}

const fetchData = () =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; {
      resolve([
        { data: 10, label: &amp;quot;a&amp;quot; },
        { data: 30, label: &amp;quot;b&amp;quot; },
        { data: 15, label: &amp;quot;c&amp;quot; },
        { data: 5, label: &amp;quot;d&amp;quot; },
        { data: 20, label: &amp;quot;e&amp;quot; },
      ])
    }, 1000)
  })
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;해결방법&lt;/h2&gt;
&lt;p&gt;이를 해결하기 위해서는 차트의 props에 해당하는 &lt;code class=&quot;language-text&quot;&gt;testData&lt;/code&gt;에 반응성을 주입시켜야 한다. 그러면 &lt;code class=&quot;language-text&quot;&gt;fetchData&lt;/code&gt;에서 1초 뒤에 값을 받아오고 나서 &lt;code class=&quot;language-text&quot;&gt;testData&lt;/code&gt;도 받아온 값으로 업데이트된다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;testData&lt;/code&gt;에 반응성을 부여하려면 &lt;code class=&quot;language-text&quot;&gt;computed&lt;/code&gt; 를 사용하여 감싸주면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Before
const testData = {
  labels: dataLabels.value,
  datasets: [
    {
      data: dataValues.value,
    },
  ],
}

// After
const testData = computed(() =&amp;gt; {
  return {
    labels: dataLabels.value,
    datasets: [
      {
        data: dataValues.value,
      },
    ],
  }
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue-chart-3nbvlh?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;vue-chart&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[Vue 에서 스크롤 위치 저장]]></title><description><![CDATA[2023-03-09 에 작성된 원문을 수정한 버전입니다 SPA(Single Page Application)에서 이전 페이지의 스크롤 위치를 기억해두었다가 재방문 했을 때 그 자리에 위치해야 하는 경우가 있다. 이를 구현하기 위한 방법을 알아보자.…]]></description><link>null/vue/230626-save-scroll/</link><guid isPermaLink="false">null/vue/230626-save-scroll/</guid><pubDate>Mon, 26 Jun 2023 22:12:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-03-09 에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/220&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;SPA(Single Page Application)에서 이전 페이지의 스크롤 위치를 기억해두었다가 재방문 했을 때 그 자리에 위치해야 하는 경우가 있다. 이를 구현하기 위한 방법을 알아보자.&lt;/p&gt;
&lt;h2&gt;1. vue-router의 savedPosition 활용&lt;/h2&gt;
&lt;p&gt;vue-router의 &lt;code class=&quot;language-text&quot;&gt;createRouter()&lt;/code&gt;함수의 인자로 &lt;code class=&quot;language-text&quot;&gt;scrollBehavior&lt;/code&gt;함수를 넣을 수 있다.&lt;/p&gt;
&lt;p&gt;이 함수에서 return 해주는 값에 따라서 페이지를 이동할 때마다 해당 값만큼 스크롤이 이동하게 된다. (쉽게 얘기하면 &lt;code class=&quot;language-text&quot;&gt;window.scrollTo&lt;/code&gt; 함수가 페이지 이동할 때마다 호출된다고 생각하면 된다.)&lt;br&gt;
예를 들어 아래 코드와 같이 &lt;code class=&quot;language-text&quot;&gt;{top : 100}&lt;/code&gt;을 리턴하다면 매 페이지 이동 시 수직 스크롤이 100px 내려져 있는 상태가 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const router = createRouter({
  history: createWebHistory(),
  routes,
  scrollBehavior() {
    return { top: 100 }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;p&gt;그렇다면 스크롤 위치를 저장하고 해당 위치로 돌아가려면 어떻게 해야할까?&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;scrollBehavior&lt;/code&gt;함수는 아래와 같이 인자로 &lt;code class=&quot;language-text&quot;&gt;to&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;from&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;savedPosistion&lt;/code&gt; 이렇게 3개를 받는다. &lt;code class=&quot;language-text&quot;&gt;to&lt;/code&gt;는 다음으로 이동할 페이지의 정보, &lt;code class=&quot;language-text&quot;&gt;from&lt;/code&gt;은 이전에 어느 페이지로부터 왔는지에 대한 정보이다.&lt;/p&gt;
&lt;p&gt;그리고 &lt;code class=&quot;language-text&quot;&gt;savedPosition&lt;/code&gt;에 우리가 원하는 정보가 들어있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const router = createRouter({
  history: createWebHistory(),
  routes,

  scrollBehavior(to, from, savedPosition) {
    // 기존 위치 존재하면 그 위치 반환
    if (savedPosition) {
      return savedPosition
    }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
영상으로 이 값의 정체를 직접 확인해보자.
&lt;br /&gt;
&lt;br /&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/hjhj97/blog.gatsby/main/content/blog/vue/images/save-scroll/save-scroll-1.gif&quot; height=&quot;600&quot;&gt;
&lt;/div&gt;
&lt;p&gt;콘솔로 &lt;code class=&quot;language-text&quot;&gt;savedPosition&lt;/code&gt;을 찍어보면 그 정체는 &lt;code class=&quot;language-text&quot;&gt;{top: number,left : number}&lt;/code&gt;형태라는 걸 알 수 있다.&lt;/p&gt;
&lt;p&gt;다만 &lt;code class=&quot;language-text&quot;&gt;savedPosition&lt;/code&gt; 값은 사용자가 &lt;strong&gt;뒤로가기/앞으로가기&lt;/strong&gt; 를 누를 때만 값이 활성화되고 vue-router를 활용하여 페이지 이동할 때는 값이 null값으로 반환되어서 위치를 저장할 수 없다. 만약 뒤로가기/앞으로가기 누를 때 뿐만 아니라 모든 경우에 대해서 스크롤 위치를 저장하기 위해서는 아래 2번 방법을 사용해야한다.&lt;/p&gt;
&lt;h2&gt;2. Web Storage(sessionStorage) 활용&lt;/h2&gt;
&lt;p&gt;두 번째 방법은 Web Storage를 활용하여 스크롤 위치를 동적으로 기억해 놓는 것이다. Web Storage는 크게 &lt;code class=&quot;language-text&quot;&gt;localStorage&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;sessionStorage&lt;/code&gt;가 있는데 차이는 브라우저를 닫았을 때 데이터가 날리느냐 마냐의 차이이다. 보통 웹사이트의 특정 기간동안 &apos;로그인상태 유지&apos; 기능이 활성화한다면 브라우저가 꺼져도 유지되야 하므로 &lt;code class=&quot;language-text&quot;&gt;localStorage&lt;/code&gt;에 저장하는게 적합하다. 스크롤 위치 정보의 경우 브라우저를 껐다가 다시 실행했을 경우에는 초기화 시키는게 적합하므로 &lt;code class=&quot;language-text&quot;&gt;sessionStorage&lt;/code&gt;에 저장하기로 했다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;페이지를 이동할 때마다 현재 페이지의 스크롤 위치를 저장해두어야 한다.
따라서 vue-router의 &lt;code class=&quot;language-text&quot;&gt;beforeEach()&lt;/code&gt;함수에서 떠나는 페이지(from)의 스크롤 위치인 &lt;code class=&quot;language-text&quot;&gt;window.scrollY&lt;/code&gt; 값을 &lt;code class=&quot;language-text&quot;&gt;sessionStorage&lt;/code&gt;에 key-value 형태로 저장한다. key값은 현재 페이지의 이름, value값은 스크롤 위치 값이다.&lt;/p&gt;
&lt;p&gt;이때 Web Storage에는 string형태의 데이터만 저장할 수 있으므로 저장할 때는 &lt;code class=&quot;language-text&quot;&gt;JSON.stringify()&lt;/code&gt;로, 값을 꺼낼 때는 &lt;code class=&quot;language-text&quot;&gt;JSON.parse()&lt;/code&gt;함수를 거쳐야 한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;router.beforeEach((_, from) =&amp;gt; {
  const prevInfo = JSON.parse(window.sessionStorage.getItem(&amp;quot;scrollInfo&amp;quot;))

  const key = from.name
  if (key) {
    const scrollObj = { [key]: window.scrollY }
    window.sessionStorage.setItem(
      &amp;quot;scrollInfo&amp;quot;,
      JSON.stringify({ ...prevInfo, ...scrollObj })
    )
  }
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 페이지에 진입하면 &lt;code class=&quot;language-text&quot;&gt;scrollInfo&lt;/code&gt;에서 이전에 저장되어 있는 스크롤 위치가 있는지 확인한 후, 있다면 그 위치로 이동시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const router = createRouter({
  history: createWebHistory(),
  routes,
  scrollBehavior(to) {
    const prevInfo = JSON.parse(window.sessionStorage.getItem(&amp;quot;scrollInfo&amp;quot;))
    if (!prevInfo) return
    const savedPosition = prevInfo[to.name] || 0

    return { top: savedPosition }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;콘솔로 &lt;code class=&quot;language-text&quot;&gt;prevInfo&lt;/code&gt;를 찍어보면 다음과 아래와 같이 나온다.&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/hjhj97/blog.gatsby/main/content/blog/vue/images/save-scroll/save-scroll-2.gif&quot; height=&quot;600&quot;&gt;
&lt;/div&gt;
&lt;p&gt;즉 &lt;code class=&quot;language-text&quot;&gt;prevInfo&lt;/code&gt;에 저장된 value값을 받아서 &lt;code class=&quot;language-text&quot;&gt;scrollBehavior&lt;/code&gt;함수의 top값으로 리턴해주게 되면 이전에 저장되었던 스크롤 위치로 복귀할 수 있게 되는 원리이다.&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;(&lt;a href=&quot;https://in0407.tistory.com/11&quot;&gt;https://in0407.tistory.com/11&lt;/a&gt;)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[프로젝트 회고]]></title><description><![CDATA[2023-02-18에 작성된 원문을 수정한 버전입니다 1. 프론트는 항상 맨 먼저 쳐맞는다. '어 이거 안되는데요? 프론트에서 확인 좀 해주세요' 이런 말을 프로젝트하면서 일주일에 1…]]></description><link>null/230625-project-review/</link><guid isPermaLink="false">null/230625-project-review/</guid><pubDate>Sun, 25 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-02-18에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/219&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;1. 프론트는 항상 맨 먼저 쳐맞는다.&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&apos;어 이거 안되는데요? 프론트에서 확인 좀 해주세요&apos;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이런 말을 프로젝트하면서 일주일에 10번도 넘게 들었다. 에러의 원인이 차라리 내(프론트) 문제라면 오히려 낫다. 하지만 백엔드 문제, 혹은 네이티브 문제인 경우도 있다. 하지만 사용자에게 가장 앞단에 보이는 부분은 결국 프론트이다. 일단 누구의 문제이든간에 내가 먼저 버그 issue를 접수받고나서 어느 파트의 문제인지 파악한 다음, 다시 그 파트의 개발자에게 해당 이슈를 토스해야 하는 입장이다.&lt;/p&gt;
&lt;p&gt;프론트 개발자 입장에서는 좀 억울하지만 어쩔 수 없는 숙명이다. 사용자는 백엔드가 어떻건, 네이티브가 어떻건은 신경쓰지 않는다. 지금 당장 자신에게 보이는 화면이 에러로 나온다면 일단 프론트 문제처럼 비춰질 수밖에 없다.그래서 나는 이 상황에 대해 &apos;제 잘못이 아닌데요&apos;라고 책임회피를 하려기보다는 그냥 침착하게 &apos;파악해보고 알려드리겠습니다&apos; 라고 대응하는게 더 현명한 방법이라고 결론내렸다.&lt;/p&gt;
&lt;h3&gt;2. 에러처리(fallback)가 성가시지만 정말 중요하다.&lt;/h3&gt;
&lt;p&gt;백엔드 API에서 어떤 데이터를 받아온다고 하자.&lt;br&gt;
백엔드에서 보내주는 형식은 &lt;code class=&quot;language-text&quot;&gt;res.data.result.list&lt;/code&gt; 라는 구조안에 내가 원하는 데이터가 들어있다. 총 4겹으로 감싸져 있는 구조이다. 여기서 중요한 점은, 한 겹을 벗길 때마다 반드시 유효성 검증을 해줘야 한다는 점이다. 하지만 예전의 나같은 경우에는 단순무식하게&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Before
const res = await axios.get(&amp;quot;/someApiAddress&amp;quot;);
const myList = res.data.result.list;
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런 식으로 한 번에 꺼내오려고 했을 것이다. 하지만 위 코드는 서버가 100% 정상 작동할때만 보장되는 코드이다. 만약 서버가 잠시 에러가 났다거나, 아니면 데이터 구조가 바뀌게 되면 위 코드는 여지없이 에러를 내뿜고 말 것이다.&lt;/p&gt;
&lt;p&gt;예전의 나라면 &lt;code class=&quot;language-text&quot;&gt;그런-상황이-프론트개발자-잘못은-아닌거-같은데요&lt;/code&gt;라고 했겠지만, 지금은 생각이 바뀌었다. 설령 백엔드 단에서 에러가 발생했다 할지라도 그 문제 상황이 프론트(사용자가 보는 화면)단까지 역류해서는 안된다. 최소한 사용자가 보기에 에러가 발생해서 아무것도 없는 흰 화면만 보여주기보다는, &apos;에러가 발생했습니다&apos;라는 텍스트 한 줄이라도 적혀있는 페이지로 리다이렉트 시켜주는게 프론트 개발자가 해야하는 최소한의 예의이다.&lt;/p&gt;
&lt;p&gt;가장 훌륭한 방법은 백엔드에서 에러가 발생하여 데이터가 예상과는 다르게 오더라도 이를 잘 핸들링 할 수 있어야 한다. 다시 위의 예시를 들자면&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// After
const res = await axios.get(&amp;quot;/someApiAddress&amp;quot;).catch(fail=&amp;gt;handleFail())
if (res) {
  const myList = res?.data?.result?.list
  if(myList){
    ...
  } else{
    handleFail();
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런식으로 데이터의 유효성 검증을 반드시 거쳐야 한다. 처음에는 이런 식의 코딩이 비효율적이고 미관상으로도 보기에 좋지 않다고 생각했었는데 ,이건 아무래도 내가 이전까지 코딩을 하던 습관이 주로 Problem solving에 머물러 있었기 때문이라고 생각한다.&lt;/p&gt;
&lt;p&gt;PS에서의 코딩을 할 때는 서버랑 통신하지 않고 데이터의 구조를 내가 직접 지정하다보니, 데이터의 유효성을 굳이 검증할 필요를 느끼지 못했다. 하지만 웹개발에서 프론트-백엔드가 맞물리는 작업에서는 반대쪽 진영에서 데이터를 어떻게 보낼 것인지에 대해서는 항상 보수적이고 안정적인 방향으로 코드를 짜야한다.&lt;/p&gt;
&lt;h3&gt;3. 사용자가 시도할 만한 모든 행동을 테스트하라.&lt;/h3&gt;
&lt;p&gt;휴대폰 본인인증을 위한 기능을 추가한다고 생각해보자.&lt;br&gt;
사용자가 문자를 받으면 번호를 입력하고 인증 버튼을 눌러주면 참 좋겠지만, 안타깝게도 사용자는 내가 의도한대로만 행동하지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;첫 번째, 사용자가 전화번호를 잘못 입력했을 수도 있다.&lt;/strong&gt;&lt;br&gt;
이 상황은 그나마 낫다. 문자를 보내기 전에 서버에서 유효하지 않은 정보라고 에러를 보내주기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;두 번째, 인증번호를 잘못 입력할 수도 있다.&lt;/strong&gt;&lt;br&gt;
이 상황도 충분히 일어날 수 있으며 서버에서도 에러를 띄워주기 때문에 처리하기엔 어렵지 않다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;하지만 세 번째, 사용자가 &apos;인증 요청&apos;버튼을 광클한다.&lt;/strong&gt;&lt;br&gt;
휴대폰 인증의 경우, 각 요청마다 고유한 인증 ID값이 부여되기 때문에 3번 클릭을 하면 3개의 별개의 인증 ID가 부여되고 3개의 문자가 전송되며 당연히 사용자에게 전송되는 인증번호도 다르다. 그리고 인증과정은 대개 가장 마지막 요청을 기준으로만 유효하기 때문에 사용자는 세 번째 인증번호를 입력해야 하는 상황이다.&lt;/p&gt;
&lt;p&gt;여기서 성질 급한 사용자는 세 번째 문자가 오기 전에 첫 번째 인증번호 문자를 입력하고 확인 버튼을 누를 것이다. 인증 결과는 당연히 실패. 당황한 사용자는 세 번째 문자를 기다리는게 아닌, &apos;인증 재요청&apos;버튼을 누를 것이다. 네 번째 문자 요청인 셈이다. 그 순간 사용자에게 두 번째, 혹은 세 번째 인증문자가 도착하고 사용자는 또 다시 인증에 실패한다. 그리고 사용자는 영문도 모르고 이 웹페이지를 만든 개발자(아마 나)를 욕하고 있을 것이다.&lt;/p&gt;
&lt;p&gt;누구의 잘못일까? 버튼을 세번 광클한 사용자인가, 그런 행동도 예측 못한 개발자인가. 프로젝트가 진행될수록 느끼는 점은 개발자가 더 신경써야 한다는 것이다. 사용자가 왜 그런 터무니없는 행동을 할까에 대해 원망을 하기 보다, 내가 한발 먼저 터무니없는 행동을 막아야 한다. 이 문제의 경우에는 &lt;code class=&quot;language-text&quot;&gt;debounce&lt;/code&gt;함수나 &lt;code class=&quot;language-text&quot;&gt;throttle&lt;/code&gt;함수를 이용하여 단 하나의 요청만 전송되도록 처리되도록 해야할 것이다.&lt;/p&gt;
&lt;p&gt;이 외에도 시간제한(3분)을 지나서 확인 버튼을 누른다거나 하는 등 내가 의도한 베스트 시나리오에서 벗어나는 행동을 얼마든지 있을 수 있다. 단순 베스트 시나리오만 처리한다면 코드를 단 30줄만 작성하면 된다. 하지만 위에서 언급한 예외적인 사용자의 행동까지 처리하기 위해서는 거의 300줄을 써야 한다. 예전에는 이런 에러 상황 처리로 인해 코드 길이가 길어지는게 현타가 오기도 했는데, 이제는 받아들이기로 했다. 그것이...프론트의 숙명이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;추후에 나는 이 일을 계기로 TDD,테스트코드의 중요성을 깨닫게 되었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;4. 안드로이드와 iOS를 동시에 고려해야한다&lt;/h3&gt;
&lt;p&gt;웹뷰 기반의 하이브리드 앱을 개발하면 프론트 개발자는 반드시 안드로이드(AOS)와 iOS를 동시에 고려해야한다. 대부분의 기능은 하나의 코드로도 양쪽에서 잘 작동하지만, 일부 기능들은 AOS에서만 작동한다거나, 반대로 iOS에서만 작동하는 기능들도 있다.&lt;/p&gt;
&lt;p&gt;이런 경우에는 어쩔 수 없이 if문을 이용하여 사용자의 기기를 식별한 다음 분기처리 해주어야 한다. 나는 아이폰을 사용하기 때문에 앱을 만들면서 iOS에서는 정상 작동을 잘 확인하였으나 안드로이드(사실상 갤럭시)에서는 동작이 다르거나 아예 실행되지 않는 케이스도 있었다.&lt;/p&gt;
&lt;p&gt;예를 들어 Javascript web share API의 경우, ios에서는 &lt;code class=&quot;language-text&quot;&gt;window.navigator.share()&lt;/code&gt; 함수만 호출하면 되는 반면에, AOS에서는 별도의 네이티브 함수를 호출해야만 공유하기 기능을 활용할 수 있다. 게다가 javascript의 문제뿐만이 아니라 css에서도 레이아웃이 다르게 보이는 경우가 있다.&lt;br&gt;
(예를 들어 safari에서는 border-radius가 들어간 element에는 outline 속성이 먹지 않는 문제)&lt;/p&gt;
&lt;p&gt;그래서 개발할 때는 항상 chrome창과 safari창을 동시에 켜놓고 작업하면서 두 브라우저에서 모두 잘 나타는지 확인해야했다.&lt;/p&gt;
&lt;h3&gt;5. 데이터 가공은 가급적 백엔드에 맡겨라&lt;/h3&gt;
&lt;p&gt;이 문제의 원인 역시 PS에서의 습관이 묻어있었기 때문이다.&lt;/p&gt;
&lt;p&gt;PS에서는 문제를 풀 때 데이터를 정렬하는 일은 정말 비일비재하므로 웹개발에서 나도 모르게 sort()함수를 하고 있는 나 자신을 발견한다. 하지만 기본적인 시간순 정렬이나, 기간조회 같은 기능들은 프론트가 직접 필터링하기보다는 백엔드 API를 통해서 값을 받아오는게 낫다. 나는 백엔드 통신을 최소화해야만 극한의 최적화를 이룰 수 있다는 강박이 있었는데, 오히려 스크립트가 연산하는 작업이 더 큰 오버헤드 일 수도 있다.&lt;/p&gt;
&lt;p&gt;어차피 백엔드는 db에서 값을 꺼내오는 과정이 포함되어있고, 백엔드 자체적으로 가공을 거친 후 보내준다 해도 그렇게 큰 시간 손실은 아니다. 상황에 따라서 데이터 가공을 프론트가 해야할 지 백엔드가 해야할 지를 잘 정해야 한다.&lt;/p&gt;
&lt;h3&gt;6. 어디까지 나의 &apos;주관적 판단&apos;을 개입시켜야 하는가&lt;/h3&gt;
&lt;p&gt;내가 프론트 개발을 할 때는 보통 와이어프레임 형태로 되어있는 기획서와 디자이너가 퍼블리싱한 문서를 기반으로 작업한다. 이 둘을 참고해가며 개발하다보면 모호한 부분이 생길 때가 있다. 이를테면 프론트단에서 구현할 수 없는 기능이거나, 왜 필요한 지 알 수 없는 기능이거나 할 때가 있다.&lt;/p&gt;
&lt;p&gt;이런 상황에서 어떻게 대처할 지 난처해진다. 잘못된 것 같아도 기획서를 그대로 따라갈 것인지, 아니면 나의 주관을 개입시켜서 기획서와 다르게 개발을 해야할지 말이다. 나는 전자와 후자의 방법 모두를 시행해보았는데 결론적으로 두 번 모두 태클을 받았다.&lt;/p&gt;
&lt;p&gt;전자의 방법을 따를 경우,
&lt;code class=&quot;language-text&quot;&gt;&apos;기획서가 좀 잘못되더라도 개발하다가 이상하다 느꼈으면 융통성 있게 수정해주세요&apos;&lt;/code&gt;
라는 말을 듣고,&lt;br&gt;
후자의 방법을 따를 경우
&lt;code class=&quot;language-text&quot;&gt;&apos;그냥 기획서에 나와 있는 그대로만 개발해주세요&apos;&lt;/code&gt;
라는 말을 듣는다. 결국에는 정답이 없다. 나의 주관을 정말 &lt;strong&gt;&apos;적절하게&apos;&lt;/strong&gt; 개입시켜야 한다.&lt;/p&gt;
&lt;h3&gt;7. 개발 자체보다, 사람과의 소통이 더 어렵다&lt;/h3&gt;
&lt;p&gt;어쩌면 가장 중요한 교훈이다. 개발은 그냥 하면 된다. 모르면 구글링으로 찾아보기도 하고 버그가 발생하면 될 때까지 부딪히다 보면 된다.&lt;/p&gt;
&lt;p&gt;하지만 사람과의 소통은 그렇지 않다. 검색을 해도 나오지도 않고 계속 부딪힐 수도 없는 문제이다. 똑같은 의도를 전달하더라도, 내가 사용하는 단어에 따라서 상대방의 대답이 달라지기도 한다.&lt;/p&gt;
&lt;p&gt;나는 코드만 잘 짜기만 하면 사람들간의 트러블은 전혀 없을 줄 알았다. 하지만 이번 프로젝트를 통해서 깨닫게 된 점은 결국 프로그램을 만드는 것도 사람, 이용하는 것도 사람이다. 내가 아무리 환상적이게 작동하는 코드를 잘 짜놓았다고 한들 상대방이 납득하지 못한다면 아무 소용없는 일이다.&lt;/p&gt;
&lt;p&gt;내가 중점적으로 신경쓴 점은 &apos;나는 어떤 문제상황을 이렇게 받아 들였고, 이런 방식으로 해결하려고 했다.&apos;를 주장하고,&lt;br&gt;
상대방에게 업무를 요청할 때는 &apos;현재 프론트에 이러이러한 문제가 있는데, 이 부분이 원인인 것 같다. 백엔드에서 다른 방식으로 개선해달라&apos; 방식의 의사소통으로 다듬어가고 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[CSS,JS를 이용한 룰렛 구현]]></title><description><![CDATA[2022-11-1…]]></description><link>null/vue/230624-vue-roulette/</link><guid isPermaLink="false">null/vue/230624-vue-roulette/</guid><pubDate>Sat, 24 Jun 2023 22:12:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2022-11-12 에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/214&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;룰렛 이벤트&lt;/h2&gt;
&lt;p&gt;다들 온라인이나 오프라인에서 룰렛(회전판)을 돌려서 나온 상품을 추첨받는 경험 한 번씩 있을 것이다. 현실에서의 룰렛은 공평한 물리법칙에 내 운명을 맡기면 되지만, 웹페이지(프론트엔드)상에서 구현할 때는 룰렛을 어떻게 돌아가게 만들고 어떤 영역을 가리키도록 해야할까? 마침 진행 중인 프로젝트에서 룰렛을 구현해야 했는데 구글링이나 오픈소스에는 내가 원하는 기능이 없어서 직접 구현하게 되었다.&lt;/p&gt;
&lt;h4&gt;요구조건&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;사용자가 버튼을 누르면 백엔드 API가 호출되고 리턴값으로 당첨영역을 받는다. 이 영역의 위치에 따라 회전 각도를 조절해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현실에서 룰렛이 회전하는 것처럼, 처음에는 천천히 돌다가 점점 가속도가 붙어서 빨라지고 마지막에는 느려지다 멈춘다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;구현 방식&lt;/h4&gt;
&lt;p&gt;가장 쉽게 생각해볼 수 있는 방법은 css animation을 활용하여 rotate시키는 방법이다.
아래와 같이 &lt;code class=&quot;language-text&quot;&gt;spin&lt;/code&gt;이라는 keyframs를 정의하고 &lt;code class=&quot;language-text&quot;&gt;rotate(360deg)&lt;/code&gt;를 부여하면 한 element를 한바퀴 돌릴 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;/* roulette.css */
.roulette_content {
  animation-name: spin;
  @keyframes spin {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 &lt;strong&gt;요구조건 1&lt;/strong&gt;에서 언급했다시피 당첨영역, 즉 회전 각도는 고정된 값이 아니라 서버에서 리턴받는 값에 따라서 동적으로 변해야 한다. 그래서 나는 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt;단에서 css keyframes에 접근하여 rotate각도를 직접 수정할 수 있는지를 찾아보았다. 예를 들어 DOM element의 &lt;code class=&quot;language-text&quot;&gt;backgroundColor&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;fontSize&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;querySelector()&lt;/code&gt;함수를 이용해 접근할 수 있는 것처럼 animation도 그런 작업이 가능한 지 궁금했다.&lt;/p&gt;
&lt;p&gt;결론부터 얘기하자면, 가능은 하지만 방법이 너무 복잡했다.&lt;a href=&quot;https://stackoverflow.com/questions/59573722/how-can-i-set-a-css-keyframes-in-javascript&quot;&gt;(링크)&lt;/a&gt;&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;insertRule()&lt;/code&gt;함수를 이용해서 넣는 방식이었는데 keyframe부분을 직접 문자열로 하드코딩해야하기 때문에 너무 억지인 것 같아서 다른 방법을 찾아보기로 하였다.&lt;/p&gt;
&lt;h4&gt;css var()를 활용한 방식&lt;/h4&gt;
&lt;p&gt;다른 방법으로 생각해낸 건 아래와 같이 css의 var()를 활용해서 :root에서 선언해놓은 변수 값을 keyframes에서 갖다 쓰는 방식이다. root 영역의 값은 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt;단에서 &lt;code class=&quot;language-text&quot;&gt;setProperty()&lt;/code&gt;함수를 활용해서 조작할 수 있기 때문에 이 방식이 더 낫다고 판단하였다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;/*roulette.css*/
.roulette_content {
  animation-name: spin;
  @keyframes spin {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(var(--roulette-angle));
    }
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;룰렛의 파라미터&lt;/h4&gt;
&lt;p&gt;룰렛을 돌리기 전에 결정되어야 할 파라미터가 몇 가지가 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;룰렛을 최소 몇 바퀴 돌릴 것인지&lt;/li&gt;
&lt;li&gt;룰렛을 몇 초 동안 돌릴 것인지&lt;/li&gt;
&lt;li&gt;룰렛 안에 채워져 있는 컨텐츠&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 3가지가 채워지고나면 룰렛을 돌릴 수 있게 된다.&lt;/p&gt;
&lt;p&gt;원리는 간단하다. 룰렛의 중심각이 360도이다. 따라서 &lt;code class=&quot;language-text&quot;&gt;360/(영역의 개수)&lt;/code&gt; 를 계산하면 룰렛의 각 영역당 중심각의 크기&lt;code class=&quot;language-text&quot;&gt;(=degPerSection)&lt;/code&gt;를 구할 수 있다.&lt;br&gt;
그리고 당첨된 영역&lt;code class=&quot;language-text&quot;&gt;(=pick)&lt;/code&gt;이 (반시계방향 기준)몇 번째인지 구하여 &lt;code class=&quot;language-text&quot;&gt;degPerSection * pick&lt;/code&gt; 값이 룰렛을 회전시켜야하는 각도 값&lt;code class=&quot;language-text&quot;&gt;(=rouletteAngle)&lt;/code&gt;이 된다.
이 값을 root에 &lt;code class=&quot;language-text&quot;&gt;--roulette-angle&lt;/code&gt;로 저장시키면 &lt;code class=&quot;language-text&quot;&gt;var()&lt;/code&gt;함수를 이용하여 keyframes에서도 이 값을 가져다 쓸 수 있는 방식이다.&lt;/p&gt;
&lt;p&gt;그래서 &lt;code class=&quot;language-text&quot;&gt;startRoulette()&lt;/code&gt;함수를 실행시키면 &lt;code class=&quot;language-text&quot;&gt;rouletteAngle&lt;/code&gt;값이 정해지고 이 값은 다시 :root의 &lt;code class=&quot;language-text&quot;&gt;roulette-angle&lt;/code&gt;으로 채워져서 spin animation이 작동하게 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const useRoulette = () =&amp;gt; {
  const POINT_ARRAY = [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;yellow&amp;quot;]
  // 룰렛의 내용, 12시 방향부터 반시계방향
  const MIN_ROTATION = 3
  // 룰렛을 최소 몇 바퀴 돌릴 것인지
  const ROTATION_SECOND = 2
  // 몇 초동안 돌릴 것인지

  const numberOfSection = POINT_ARRAY.length
  // 룰렛에 적힌 영역의 개수
  const degPerSection = 360 / numberOfSection
  // 하나의 섹션당 각도가 몇 도인지 계산함.
  let pickedSection
  // 당첨된 영역

  const setRouletteProperty = () =&amp;gt; {
    const pick = Math.floor(Math.random() * numberOfSection)
    // [0, section - 1]범위에 랜덤한 인덱스를 뽑음, 서버에서 영역을 정해준다면 필요없음
    pickedSection = POINT_ARRAY[pick]
    // 당첨된 영역 값 대입
    const rouletteAngle = 360 * MIN_ROTATION + degPerSection * pick
    // 최소 MIN_ROTATION만큼은 돌고난 후에, pick 영역을 가르키도록 함

    document.documentElement.style.setProperty(
      &amp;quot;--roulette-angle&amp;quot;,
      rouletteAngle + &amp;quot;deg&amp;quot;
    )
    //css의 root에 선언해놓은 변수에 값 할당함.

    const rouletteEl = document.querySelector(&amp;quot;.roulette_content&amp;quot;)
    rouletteEl.style.animationDuration = `${ROTATION_SECOND * 1000}ms`
    // 애니메이션(룰렛회전) 지속시간 적용
  }

  const startRoulette = () =&amp;gt; {
    setRouletteProperty()

    const toId = setTimeout(() =&amp;gt; {
      alert(pickedSection)
      clearTimeout(toId)
    }, ROTATION_SECOND * 1000)
  }
  return {
    startRoulette,
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;/* roulette.css */
.roulette_content {
  animation-name: spin;
  animation-timing-function: ease-in-out;
  animation-fill-mode: forwards;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(var(--roulette-angle));
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue3-roulette-cu4617?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;Vue3-roulette&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[블로그 꾸미기 일지]]></title><description><![CDATA[블로그 템플릿 블로그를 이제 막 개설해서인지 아직은  프레임워크가 어떻게 동작하는지 파악하고 있는 단계다. 그러면서도 블로그 꾸미기는 빼먹을 수 없는데, 이는 역시 내가 프론트엔드 개발자이기도 하고 velog나 medium…]]></description><link>null/230622-blog-decoration/</link><guid isPermaLink="false">null/230622-blog-decoration/</guid><pubDate>Thu, 22 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;블로그 템플릿&lt;/h2&gt;
&lt;p&gt;블로그를 이제 막 개설해서인지 아직은 &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt; 프레임워크가 어떻게 동작하는지 파악하고 있는 단계다. 그러면서도 블로그 꾸미기는 빼먹을 수 없는데, 이는 역시 내가 프론트엔드 개발자이기도 하고 velog나 medium 같은 플랫폼보다 커스텀할 수 있는 폭이 넓은 gatsby를 기술 블로그로 선택한 이상 꾸미기는 선택이 아닌 거의 필수라고 생각한다.&lt;/p&gt;
&lt;p&gt;첫 글에서도 언급했다시피 다른 개발자분들의 gatsby 블로그를 구경다니면서도 한 가지 의아했던 점 중 하나는, UI가 하나같이 매우 흡사하다는 점이었다. 상단에는 full-width의 top-fixed-header가 존재하고 바로 밑에는 자신의 프로필과 간단한 소개글, 그 밑에 포스팅이 나열되는 방식이었다. 이게 무슨 정해진 규칙같은 게 있는 건 지, 아니면 이런 형식으로 제공되는 템플릿이 있는 지는 모르겠는데 일단 나는 나만의 방식으로 꾸미기로 했다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(나중에 알게된 사실인데, &lt;a href=&quot;https://jbee.io&quot;&gt;Jbee&lt;/a&gt;님이 배포하시는 &lt;a href=&quot;https://github.com/JaeYeopHan/gatsby-starter-bee&quot;&gt;gatsby-starter-bee&lt;/a&gt;가 있었다. 아마 내가 구경한 블로그의 상당수는 이를 fork한 것으로 보인다. 이 블로그도 fork해서 만드는 걸 고려해보긴 했지만, 일단은 제로베이스부터 만들고 싶었다. 대신에 각종 기능을 어떻게 구현했는지에 대한 코드는 많이 참고하고 있다. Jbee님 감사합니다.)&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;어떻게 꾸밀까&lt;/h2&gt;
&lt;p&gt;나는 &lt;code class=&quot;language-text&quot;&gt;gatsby-starter-blog&lt;/code&gt;를 fork해서 갖고왔다. 처음 &lt;code class=&quot;language-text&quot;&gt;npm run develop&lt;/code&gt; 커맨드로 실행하게 되면 뿌듯함과 함께 어떻게 꾸며야할까에 대한 막막함이 몰려온다.
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/fe18827134b205b6948d96e3ca7f53b5/0c1ff/blog-history-1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 77.84810126582278%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABjklEQVR42q2TzXLaMBSF8/6vwppFugF2rGEDoZ4mzjSAsfUvG//xdaTgmZCWMqQ9M3dkW9Lne6R7HwBOp1MY0FqzWq3YbDakacr3JCFJEtbrNcvlMs4P64c9n/XwEbjf7/j2+Mh4PGY2mzGfz5lMJkynU0ajEYvFIq7r+55rugDuDoqfu4K2bdHGYaynbhqatqVtO7wvsdZhjI1xE/iavpBsnnDWkhcC4yuauqGOUccfdV0X4WG8ChzUn6Bqe9yxwx1buv7EvXrP8Pyyk47Fc8bqTfG01RH6JeCgY1WipcA7i7MGpRRCSAohEVLFY5Dy/ZtS+o+XcwHU1pNuD7zuc9JtThYASiGVjqDwrLVBSIlz/rblzFSst4pUeH7kDlM1fJy/23LpPXmWoaRAKxUt53lxti0oChHthyzLsroNtL7iLStiFEKhjUHpcygdI9gPtXmtuC8s57aKN5zsLWXd3m33twzDQWfZIRbw5579W/9eBYbqPx7rc7t19F8t7EEhs5Cl857ClJR192/A/6FfblHhRO9cVYoAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;첫 상태&quot;
        title=&quot;&quot;
        src=&quot;/static/fe18827134b205b6948d96e3ca7f53b5/f058b/blog-history-1.png&quot;
        srcset=&quot;/static/fe18827134b205b6948d96e3ca7f53b5/c26ae/blog-history-1.png 158w,
/static/fe18827134b205b6948d96e3ca7f53b5/6bdcf/blog-history-1.png 315w,
/static/fe18827134b205b6948d96e3ca7f53b5/f058b/blog-history-1.png 630w,
/static/fe18827134b205b6948d96e3ca7f53b5/40601/blog-history-1.png 945w,
/static/fe18827134b205b6948d96e3ca7f53b5/78612/blog-history-1.png 1260w,
/static/fe18827134b205b6948d96e3ca7f53b5/0c1ff/blog-history-1.png 2192w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;div align=center&gt;
&lt;em&gt;
처음으로 블로그를 실행하면 마주하게 되는 화면.사실상 허허벌판 상태이다.
&lt;/em&gt;
&lt;/div&gt;
&lt;br /&gt;
&lt;p&gt;일단 해야할 일을 정해보자.&lt;/p&gt;
&lt;h4&gt;1. primary-color 정하기&lt;/h4&gt;
&lt;p&gt;UI의 통일성을 위해서는 꼭 필요하다. 내가 평소에 좋아하는 색인 &lt;code class=&quot;language-text&quot;&gt;DodgerBlue&lt;/code&gt; 계열의 색을 rgb-picker로 찍어왔다.&lt;/p&gt;
&lt;h4&gt;2. 내 소개글(profile) 작성하기&lt;/h4&gt;
&lt;p&gt;이건 간단하다. 한두줄 정도의 소개글과 프로필사진만 업로드하면 된다.&lt;/p&gt;
&lt;h4&gt;3. 헤더 스타일 변경하기&lt;/h4&gt;
&lt;p&gt;다른 사람들의 블로그의 헤더가 모두 top-fixed에 full-width인 걸 보아하니, 나도 왠지 그래야만 할 것 같은 기분이 들었다. background-color는 primary-color로 적용하니 꽤 볼만해졌다. 그렇지만 점점 갈수록 다른 블로그들이랑 너무 비슷해져가는데...? 이럴거면 그냥 처음부터 &lt;code class=&quot;language-text&quot;&gt;gatsby-start-bee&lt;/code&gt;를 받아서 쓸 걸 그랬나...&lt;/p&gt;
&lt;p&gt;여기까지 적용해본 결과, 아래와 같이 나온다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/104decd28c6c747339e89b9fc13397e9/26781/blog-history-2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 60.75949367088608%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABH0lEQVR42q1STUsDMRDtnxcRjyqK4LHQav+JePDkUZC6WtvtZpJMPjd5sllbKCzYVgceA0Py5s2bGZ3ePOHs9hkn1484v3vB1X2Ni8myx7TH5XS1N0b45xjllJFzRkoJKeVSfK0Ibx8NqvcK83mFtm23H/Im52HsKOyIuxiPJ5g9zCBI4XPxBSEIgiSaRoDZwBgL5/2wwqGiswzDDOdbhBjhQ0AIEd77ojblvG3+K2H3jnQ3/pEeDhWV0jDGbG3YxRGEQkYs6ogVdSPnvyskqctCpGJo5rIIrX8yM6x1+3vYBRsPkgakDNhYWGvLZq1zMNYihHCYwrpxWK4D1tTChVSub+Nhf6899lfIGiQJSklIKSGICqRURaVzHjHGQcJvx8ag/VPYq0AAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;두 번째 상태&quot;
        title=&quot;&quot;
        src=&quot;/static/104decd28c6c747339e89b9fc13397e9/f058b/blog-history-2.png&quot;
        srcset=&quot;/static/104decd28c6c747339e89b9fc13397e9/c26ae/blog-history-2.png 158w,
/static/104decd28c6c747339e89b9fc13397e9/6bdcf/blog-history-2.png 315w,
/static/104decd28c6c747339e89b9fc13397e9/f058b/blog-history-2.png 630w,
/static/104decd28c6c747339e89b9fc13397e9/40601/blog-history-2.png 945w,
/static/104decd28c6c747339e89b9fc13397e9/78612/blog-history-2.png 1260w,
/static/104decd28c6c747339e89b9fc13397e9/26781/blog-history-2.png 2664w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;참고 볼 만한 수준은 되었지만, 아직 이정도로는 부족하다.&lt;/p&gt;
&lt;h4&gt;4. 댓글 작성 기능&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;utterance&lt;/code&gt;를 활용하면 된다. 블로그 댓글을 위한 별도의 public 레포지토리를 만들고나서 연동을 하면 해당 레포지토리의 issue에 글이 올라가게 되고, 이를 댓글처럼 활용할 수 있는 방식이다.&lt;/p&gt;
&lt;h4&gt;5. 폰트 변경하기&lt;/h4&gt;
&lt;p&gt;기본으로 깔려있는 폰트는 별로 예쁘지가 않았다. 구글링으로 폰트 변경하는 법을 찾아보니, &lt;code class=&quot;language-text&quot;&gt;@fontsource&lt;/code&gt;에서 제공해주는 폰트를 &lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;기반으로 설치할 수 있다고 하더라. 기본 제공되는 한글 폰트는 가짓수가 그리 많지는 않지만 나는 가장 무난한 &lt;code class=&quot;language-text&quot;&gt;Noso Sans&lt;/code&gt;를 선택했다.&lt;/p&gt;
&lt;h4&gt;6. 코드블럭 스타일 변경하기&lt;/h4&gt;
&lt;p&gt;코드블럭 역시 기본으로 제공되는 스타일이 마음에 들지 않았다. 구글링해보니 &lt;code class=&quot;language-text&quot;&gt;gatsby-remark-highlight-code&lt;/code&gt;라는 플러그인을 제공해주고 있더라. 이런 문제들을 미리 만나고 해결해주시고 블로그에 글을 남겨주신 모든 분들께 감사드린다.&lt;/p&gt;
&lt;h4&gt;7. 모바일 환경도 신경쓰기&lt;/h4&gt;
&lt;p&gt;PC 환경에서는 잘 보이는데, 모바일에서 확인해보니 스타일이 깨지는 부분이 많았다. 사실 기술블로그를 주로 읽는 독자들의 대다수는 PC로 접속할 것으로 예상은 되지만, 그렇다고 모바일을 소홀히 할 변명이 되지는 않는다. 당연히 모바일에서도 잘 보여야한다. 헤더의 z-index나 element들의 간격을 조정해서 해결하였다.&lt;/p&gt;
&lt;h4&gt;8. 나만의 독특함(?)은 뭐가 있을까&lt;/h4&gt;
&lt;p&gt;사실 여기까지만 진행해도 나름 그럴싸한 UI가 완성되었다. 그렇지만 뭔가 좀 아쉽다. 다른 블로그를 너무 열심히 참고하는 바람에 내 블로그만의 특색이 사라졌다고나 할까? 그래도 나름 뭔가 좀 hooking 한 무언가 있었으면 좋겠다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;음, 생각을 해보자... 나만의 무언가....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그러다가 문득 나의 닉네임이 Neon 이니, 네온사인같은 효과를 적용해보면 좋겠다는 생각이 떠올랐다. 바로 &lt;code class=&quot;language-text&quot;&gt;neon sign effect in css&lt;/code&gt;로 검색해보니 아니나 다를까, 수많은 구현 방법이 나와있었다. 기본적으로 text-shadow를 활용해서 뒤에 어두운 배경을 갖다대면 네온사인처럼 주변을 밝히는 효과를 낼 수 있었다. 더 참신한 건 animation,keyframes을 이용해서 네온사인이 깜빡이는 효과까지 만들 수 있다!&lt;br&gt;
처음 이걸 본 순간 확 꽂혀서 바로 내 블로그에 도입해보고 싶다는 생각이 들었다. 어려운 테크닉이 들어간 방식도 아니어서 단번에 보고 따라할 수 있었다. 혹시나 코드가 궁금하신 분들은 &lt;code class=&quot;language-text&quot;&gt;header-effect.css&lt;/code&gt;를 참고하면 된다.&lt;br&gt;
대신에 깜빡이는 효과는 눈이 아프거나 정신 사납다고 느낄 수도 있으니 독자에게 비활성화할 수 있는 방법은 제공해야되겠다고 생각했다. 상태관리 라이브러리를 써야하나 고민했는데 그렇게 복잡할 필요는 없을 것 같다고 판단하여 그냥 localStorage단에서 boolean값을 저장하여 제어하는 방식을 선택했다.&lt;/p&gt;
&lt;h2&gt;앞으로 적용해 볼 기능들&lt;/h2&gt;
&lt;h4&gt;카테고리&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;gatsby-starter-bee&lt;/code&gt;에서는 기본으로 제공해주는 기능인데, 나는 직접 구현해야한다. 구현 원리는 슥 봤는데 어느정도는 이해하긴 했다. 카테고리 목록을 &lt;code class=&quot;language-text&quot;&gt;string[]&lt;/code&gt;형태의 constant로 미리 선언해놓고, &lt;code class=&quot;language-text&quot;&gt;content/blog/&lt;/code&gt;밑의 경로에 선언해둔 카테고리를 디렉토리로 만들어서 포스팅을 집어 넣는다. 그리고 &lt;code class=&quot;language-text&quot;&gt;useCategory&lt;/code&gt; hook을 호출해서 특정 카테고리 밑에 있는 포스팅들을 다 묶어주는 방식인 것 같다. 머리로는 이해했는데 구현은 한번 해봐야 할 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2023.06.23 적용&lt;/strong&gt;&lt;br&gt;
오늘 하루를 꼬박 투자해서 카테고리 기능을 구현해냈다. 위에 적은 예상 구현 방법은 반은 맞고 반은 틀렸다. 카테고리 리스트는 constant로 미리 선언해둘 필요 없이, 글의 &lt;code class=&quot;language-text&quot;&gt;frontmatter&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;category&lt;/code&gt;라는 속성을 적어주기만 하면 된다. 그러면 &lt;code class=&quot;language-text&quot;&gt;index.js&lt;/code&gt;에서 모든 글의 &lt;code class=&quot;language-text&quot;&gt;frontmatter&lt;/code&gt;정보를 긁어와서 map형태로 만들고 &lt;code class=&quot;language-text&quot;&gt;unique&lt;/code&gt;함수를 거쳐서 유일하게 만들어주면 된다.&lt;br&gt;
여기까지는 &lt;em&gt;Jbee&lt;/em&gt; 님이 구현한 방식을 참고했는데, 나는 여기서 더 나아가 카테고리별 글의 &apos;개수&apos;까지 보여주고 싶었다. 기존 방식은 post의 카테고리를 &lt;code class=&quot;language-text&quot;&gt;map()&lt;/code&gt;함수로 뽑아낸 다음, &lt;code class=&quot;language-text&quot;&gt;lodash&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;uniq&lt;/code&gt;함수를 실행하기 때문에 글의 개수와 관련된 정보는 날라가버린다. 그래서 나는 글의 개수를 보존하기 위해 자료구조 &lt;code class=&quot;language-text&quot;&gt;Map&lt;/code&gt;을 활용하여 key값은 카테고리 이름, value값은 해당 카테고리 글의 개수를 저장했다.&lt;/p&gt;
&lt;h4&gt;다크모드&lt;/h4&gt;
&lt;p&gt;카테고리 기능만큼 우선순위가 높은 기능은 아니라고 생각한다. 이 역시도 gatsby-theme과 관련된 플러그인이 있는 것 같던데, 나중에 적용할 마음이 생기면 찾아보려고 한다.&lt;/p&gt;
&lt;h4&gt;오픈그래프(검색최적화)&lt;/h4&gt;
&lt;p&gt;이 부분에 관해서는 나도 아직 모르는 부분이 많아서 차차 공부해가면서 적용해보려고 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[첫 번째 글]]></title><description><![CDATA[블로그 이사 기존에 4년 반 동안 운영하던 티스토리 블로그에서 이곳 Gatsby 블로그로 이사하였다. 이사하게된 배경에는 여러가지가 있지만, 가장 중요한 이유는 '개발과 관련된' 포스팅에 더 집중하기 위해서다. 티스토리 블로그는 이름과 URL…]]></description><link>null/essay/230621-first.article/</link><guid isPermaLink="false">null/essay/230621-first.article/</guid><pubDate>Wed, 21 Jun 2023 22:12:00 GMT</pubDate><content:encoded>&lt;h2&gt;블로그 이사&lt;/h2&gt;
&lt;p&gt;기존에 4년 반 동안 운영하던 &lt;a href=&quot;https://ps-hjhj97.tistory.com&quot;&gt;티스토리 블로그&lt;/a&gt;에서 이곳 Gatsby 블로그로 이사하였다.&lt;/p&gt;
&lt;p&gt;이사하게된 배경에는 여러가지가 있지만, 가장 중요한 이유는 &apos;개발과 관련된&apos; 포스팅에 더 집중하기 위해서다. 티스토리 블로그는 이름과 URL에서부터 짐작되다시피, PS(Problem Solving)를 하면서 얻은 지식이나 문제 풀이 위주의 글들로 이루어져 있다. 처음 블로그를 개설할 당시만 하더라도 나는 아주 PS만 공부하고 있었으므로 추후에 개발 블로그로서 발전될 가능성을 염두에 두지 않았다.&lt;/p&gt;
&lt;p&gt;그러다 시간이 흘러 내가 취업전선에 뛰어들게 되면서 점점 PS보다는 개발 공부에 투자하는 비중이 더 많아졌다. 처음에는 개발 공부에서 얻은 지식들도 기존 티스토리 블로그에 포스팅할 예정이었으나, 그 당시에는 익숙치 않아서인지 개발 포스팅은 글을 어떻게 써야할 지 감이 잡히지 않았다.&lt;br&gt;
문제풀이 글의 경우에는 &apos;문제요약&apos; &gt; &apos;문제접근&apos; &gt; &apos;나의 생각&apos; &gt;&apos;코드구현&apos; 이라는 명확한 기승전결 포맷이 갖춰져 있음에 비해, 개발관련 글은 주제가 자유분방하다보니 이걸 어떻게 설명해야할지 도무지 갈피를 못잡았던 것 같다. 그래서 개발 포스팅은 차일피일 계속 미뤄지다가 작년에 회사 인턴을 시작하면서 &apos;이제는 진짜 해야한다&apos;라는 위기감을 느껴서 개발 포스트 몇 개 정도는 발행할 수 있었다.&lt;br&gt;
하지만 그럼에도 문제는 여전히 있었다. 일단 개발 포스팅을 스스로가 습관화하지는 못해서 업로드 주기가 불규칙하였으며(당초 목표는 한달에 약 3개 발행), 어쩌다가 의무감때문에 글을 쓰더라도 (지금 다시 읽어보면) 글의 퀄리티가 영 마음에 들지 않았기 때문이다.&lt;/p&gt;
&lt;p&gt;마음 속에는 &apos;열심히 글 써야지&apos;라는 추상화된 생각이 자리잡고 있는데, 현실 속에서 이를 구현하고 있지 못하는 상황이었다. 고민 끝에 내린 해결책이 바로 &apos;기술 블로그는 따로 분리하자&apos; 였다. 아무래도 티스토리 블로그에는 이미 PS 글들로 가득 차 있었고, 자잘한 블로그 테마나 스킨들도 이에 맞춰져 있었기 때문인지 개발 글을 써도 뭔가 기술 블로그처럼 보이지가 않았다. 고민에 고민을 거듭한 끝에 결국 내가 떠올린 해결책은 바로..&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이건...블로그를 옮겨야 해...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;완전히 새로운 마음으로 제로베이스부터 다시 시작해야 되겠다고 마음을 먹었다. PS를 위한 티스토리 블로그는 PS를 위한 글만 작성하도록 스스로 원칙을 정했다. 블로그 운영에도 &lt;code class=&quot;language-text&quot;&gt;단일 책임 원칙&lt;/code&gt;을 적용했다고 보면 된다.&lt;/p&gt;
&lt;h2&gt;왜 하필 Gatsby?&lt;/h2&gt;
&lt;p&gt;새로운 개발 블로그를 개설할 때에는 여러가지 옵션이 있었다. 가장 간단한 방법은 다른 도메인의 개발용 티스토리 블로그를 개설할 수도 있었다. 하지만 또 다시 티스토리에서 운영하면 똑같은 나태함의 수순을 반복할 것 같아서 완전히 다른 플랫폼으로 옮겨야되겠다고 마음먹었다. 그래서 티스토리를 제외하고 보통 사람들이 운영하는 개발 블로그의 종류에는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brunch&lt;/li&gt;
&lt;li&gt;velog&lt;/li&gt;
&lt;li&gt;medium&lt;/li&gt;
&lt;li&gt;github page&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;등이 있는데, 앞의 3가지는 플랫폼에서 미리 제공해주는 템플릿이 있고, 유저는 오직 글 작성에만 집중하면 되는 방식이다.
하지만 나는.... 나름 명색이 &lt;strong&gt;프론트엔드 개발자&lt;/strong&gt;이다. 그렇다면 내가 직접 커스텀하고 개발할 수 있는 폭이 넓은 &apos;github page&apos;를 선택해야 하지 않을까? 하는 &lt;code class=&quot;language-text&quot;&gt;근거는-없지만-당연히-그래야-할-것-같은-기분&lt;/code&gt;이 들었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;좋아, 그러면 일단 github page로 결정!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;github page에서도 크게 선택이 두 가지로 나뉘는데 &lt;code class=&quot;language-text&quot;&gt;jekyll&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt;이다. 둘 다 정적 웹사이트 생성기이지만 약간의 차이는 있다. 내가 차이점에 대해서 정확히 조사한 건 아니지만 대략 찾아보고 느낀 점은 &lt;code class=&quot;language-text&quot;&gt;jekyll&lt;/code&gt;은 좀 불편하고, &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;react&lt;/code&gt;기반이면서 커스텀할 수 있는 여지도 더 넓다는 것이다. 그리고 무엇보다 결정적인 요인은, 내가 다른 개발자분들의 기술 블로그를 &lt;del&gt;염탐&lt;/del&gt; 구경해보면서 &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt;기반의 기술블로그가 훨씬 더 많았다는 점이다. 이쯤 되니 아, 나는 어쩔 수없이 &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt;를 선택해야 할 운명이야- 가 되어 버렸다.&lt;br&gt;
그래서 이틀 전에 구글링으로 &apos;gatsby 블로그 만드는 방법&apos; 찾아보면서 후다닥 만들고 git에 배포까지 완료했다. 게다가 야심차게 가비아에서 &lt;code class=&quot;language-text&quot;&gt;juheon.dev&lt;/code&gt; 도메인까지 구입해서 연결했다. 1년에 3만원 남짓한 금액이지만 아무튼 내 돈주고 운영하는 블로그인만큼 조금의 강제성은 부여되지 않을까 기대해본다.&lt;/p&gt;
&lt;h2&gt;앞으로 어떻게 운영해야할까&lt;/h2&gt;
&lt;p&gt;우선 나 스스로 블로그에 글을 쓴다는 심리적인 허들을 낮출 필요가 있다. 현재 나는 은근히 글을 쓰는 데에 부담감을 짋어지고 있는 듯 하다. 좋은 글을 써야 한다는 압박 때문인지 주제는 정해놓고서도 쉽사리 글을 적지는 못하고 있다.&lt;br&gt;
사실 다른 개발자분들의 기술블로그를 구경하면서 다들 글을 너무 잘 쓰길래 스스로 기가 죽은 것 같은 기분을 느낀다. 그렇지만 처음부터 잘 쓰는 사람이 어디 있을까, 짧고 간결한 글이라도 좋으니깐 일단 글을 쓰는 일을 &apos;습관화&apos;하는 일이 1순위이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[테스트 글]]></title><description><![CDATA[이건 테스트 글입니다. Codeblock javascript typescript html c jsx vue JSON]]></description><link>null/230620-test-article/</link><guid isPermaLink="false">null/230620-test-article/</guid><pubDate>Tue, 20 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;이건 테스트 글입니다.&lt;/p&gt;
&lt;h2&gt;Codeblock&lt;/h2&gt;
&lt;h4&gt;javascript&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// this is javascript
const a = 1
const b = 2
const sum = () =&amp;gt; {
  return a + b
}
sum()&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;typescript&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// this is typecript
const a: number = 1
const b: number = 2
const sum: number = () =&amp;gt; {
  return a + b
}
sum()&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;html&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;!-- this is html --&amp;gt;
&amp;lt;div&amp;gt;Hello&amp;lt;/div&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;c&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;c&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// this is c
int a=1;
int b=2;
function sum(){
  return a + b;
}
sum();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;jsx&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const App = () =&amp;gt; {
  const [value, setValue] = useState(0)
  return &amp;lt;div&amp;gt;Hello {value}&amp;lt;/div&amp;gt;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// this is vue
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;Hello {{a}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;


&amp;lt;script&amp;gt;
  export default{
    setup(){
      const a = ref(1);
      return{
        a
      }
    }
  }
  &amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;JSON&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;string&amp;quot;: &amp;quot;hello&amp;quot;,
  &amp;quot;number&amp;quot;: 1,
  &amp;quot;isValid&amp;quot;: true,
  &amp;quot;array&amp;quot;: [1, 2, 3]
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;</content:encoded></item><item><title><![CDATA[New Beginnings]]></title><description><![CDATA[Far far away, behind the word mountains, far from the countries Vokalia and
Consonantia, there live the blind texts. Separated they live in…]]></description><link>null/new-beginnings/</link><guid isPermaLink="false">null/new-beginnings/</guid><pubDate>Thu, 28 May 2015 22:40:32 GMT</pubDate><content:encoded>&lt;p&gt;Far far away, behind the word mountains, far from the countries Vokalia and
Consonantia, there live the blind texts. Separated they live in Bookmarksgrove
right at the coast of the Semantics, a large language ocean. A small river named
Duden flows by their place and supplies it with the necessary regelialia.&lt;/p&gt;
&lt;h2&gt;On deer horse aboard tritely yikes and much&lt;/h2&gt;
&lt;p&gt;The Big Oxmox advised her not to do so, because there were thousands of bad
Commas, wild Question Marks and devious Semikoli, but the Little Blind Text
didn’t listen. She packed her seven versalia, put her initial into the belt and
made herself on the way.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This however showed weasel&lt;/li&gt;
&lt;li&gt;Well uncritical so misled
&lt;ul&gt;
&lt;li&gt;this is very interesting&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Goodness much until that fluid owl&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When she reached the first hills of the &lt;strong&gt;Italic Mountains&lt;/strong&gt;, she had a last
view back on the skyline of her hometown &lt;em&gt;Bookmarksgrove&lt;/em&gt;, the headline of
&lt;a href=&quot;http://google.com&quot;&gt;Alphabet Village&lt;/a&gt; and the subline of her own road, the Line
Lane. Pityful a rhetoric question ran over her cheek, then she continued her
way. On her way she met a copy.&lt;/p&gt;
&lt;h3&gt;Overlaid the jeepers uselessly much excluding&lt;/h3&gt;
&lt;p&gt;But nothing the copy said could convince her and so it didn’t take long until a
few insidious Copy Writers ambushed her, made her drunk with
&lt;a href=&quot;http://google.com&quot;&gt;Longe and Parole&lt;/a&gt; and dragged her into their agency, where
they abused her for their projects again and again. And if she hasn’t been
rewritten, then they are still using her.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Far far away, behind the word mountains, far from the countries Vokalia and
Consonantia, there live the blind texts. Separated they live in Bookmarksgrove
right at the coast of the Semantics, a large language ocean.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It is a paradisematic country, in which roasted parts of sentences fly into your
mouth. Even the all-powerful Pointing has no control about the blind texts it is
an almost unorthographic life One day however a small line of blind text by the
name of Lorem Ipsum decided to leave for the far World of Grammar.&lt;/p&gt;
&lt;h3&gt;According a funnily until pre-set or arrogant well cheerful&lt;/h3&gt;
&lt;p&gt;The Big Oxmox advised her not to do so, because there were thousands of bad
Commas, wild Question Marks and devious Semikoli, but the Little Blind Text
didn’t listen. She packed her seven versalia, put her initial into the belt and
made herself on the way.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;So baboon this&lt;/li&gt;
&lt;li&gt;Mounted militant weasel gregariously admonishingly straightly hey&lt;/li&gt;
&lt;li&gt;Dear foresaw hungry and much some overhung&lt;/li&gt;
&lt;li&gt;Rash opossum less because less some amid besides yikes jeepers frenetic
impassive fruitlessly shut&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;When she reached the first hills of the Italic Mountains, she had a last view
back on the skyline of her hometown Bookmarksgrove, the headline of Alphabet
Village and the subline of her own road, the Line Lane. Pityful a rhetoric
question ran over her cheek, then she continued her way. On her way she met a
copy.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The copy warned the Little Blind Text, that where it came from it would have
been rewritten a thousand times and everything that was left from its origin
would be the word &quot;and&quot; and the Little Blind Text should turn around and
return to its own, safe country.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;But nothing the copy said could convince her and so it didn’t take long until a
few insidious Copy Writers ambushed her, made her drunk with Longe and Parole
and dragged her into their agency, where they abused her for their projects
again and again. And if she hasn’t been rewritten, then they are still using
her. Far far away, behind the word mountains, far from the countries Vokalia and
Consonantia, there live the blind texts.&lt;/p&gt;
&lt;h4&gt;Silent delightfully including because before one up barring chameleon&lt;/h4&gt;
&lt;p&gt;Separated they live in Bookmarksgrove right at the coast of the Semantics, a
large language ocean. A small river named Duden flows by their place and
supplies it with the necessary regelialia. It is a paradisematic country, in
which roasted parts of sentences fly into your mouth.&lt;/p&gt;
&lt;p&gt;Even the all-powerful Pointing has no control about the blind texts it is an
almost unorthographic life One day however a small line of blind text by the
name of Lorem Ipsum decided to leave for the far World of Grammar. The Big Oxmox
advised her not to do so, because there were thousands of bad Commas, wild
Question Marks and devious Semikoli, but the Little Blind Text didn’t listen.&lt;/p&gt;
&lt;h5&gt;Wherever far wow thus a squirrel raccoon jeez jaguar this from along&lt;/h5&gt;
&lt;p&gt;She packed her seven versalia, put her initial into the belt and made herself on
the way. When she reached the first hills of the Italic Mountains, she had a
last view back on the skyline of her hometown Bookmarksgrove, the headline of
Alphabet Village and the subline of her own road, the Line Lane. Pityful a
rhetoric question ran over her cheek, then she continued her way. On her way she
met a copy.&lt;/p&gt;
&lt;h6&gt;Slapped cozy a that lightheartedly and far&lt;/h6&gt;
&lt;p&gt;The copy warned the Little Blind Text, that where it came from it would have
been rewritten a thousand times and everything that was left from its origin
would be the word &quot;and&quot; and the Little Blind Text should turn around and return
to its own, safe country. But nothing the copy said could convince her and so it
didn’t take long until a few insidious Copy Writers ambushed her, made her drunk
with Longe and Parole and dragged her into their agency, where they abused her
for their projects again and again.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[My Second Post!]]></title><description><![CDATA[Wow! I love blogging so much already. Did you know that "despite its name, salted duck eggs can also be made from
chicken eggs, though the…]]></description><link>null/my-second-post/</link><guid isPermaLink="false">null/my-second-post/</guid><pubDate>Wed, 06 May 2015 23:46:37 GMT</pubDate><content:encoded>&lt;p&gt;Wow! I love blogging so much already.&lt;/p&gt;
&lt;p&gt;Did you know that &quot;despite its name, salted duck eggs can also be made from
chicken eggs, though the taste and texture will be somewhat different, and the
egg yolk will be less rich.&quot;?
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Salted_duck_egg&quot;&gt;Wikipedia Link&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Yeah, I didn&apos;t either.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Hello World]]></title><description><![CDATA[This is my first post on my new fake blog! How exciting! I'm sure I'll write a lot more interesting things in the future. Oh, and here's a…]]></description><link>null/hello-world/</link><guid isPermaLink="false">null/hello-world/</guid><pubDate>Fri, 01 May 2015 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;This is my first post on my new fake blog! How exciting!&lt;/p&gt;
&lt;p&gt;I&apos;m sure I&apos;ll write a lot more interesting things in the future.&lt;/p&gt;
&lt;p&gt;Oh, and here&apos;s a great quote from this Wikipedia on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Salted_duck_egg&quot;&gt;salted duck eggs&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A salted duck egg is a Chinese preserved food product made by soaking duck
eggs in brine, or packing each egg in damp, salted charcoal. In Asian
supermarkets, these eggs are sometimes sold covered in a thick layer of salted
charcoal paste. The eggs may also be sold with the salted paste removed,
wrapped in plastic, and vacuum packed. From the salt curing process, the
salted duck eggs have a briny aroma, a gelatin-like egg white and a
firm-textured, round yolk that is bright orange-red in color.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/8058f3f26913fea3b6a89a73344fe94a/e1596/salty_egg.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 75.31645569620254%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAMB/8QAFwEAAwEAAAAAAAAAAAAAAAAAAAEEBf/aAAwDAQACEAMQAAABgik0dXC//8QAGRABAAMBAQAAAAAAAAAAAAAAAQACERIy/9oACAEBAAEFAkqW7B5Zox9t8n//xAAXEQEAAwAAAAAAAAAAAAAAAAAAERJB/9oACAEDAQE/AdVl/8QAFhEBAQEAAAAAAAAAAAAAAAAAABEC/9oACAECAQE/AYun/8QAGxAAAQQDAAAAAAAAAAAAAAAAAAECESEiMTL/2gAIAQEABj8CvRjaHMkvIQo//8QAGxAAAwEBAAMAAAAAAAAAAAAAAREhAEGBobH/2gAIAQEAAT8hsTTH203YINmYDPHckkPzQiGHv//aAAwDAQACAAMAAAAQyC//xAAXEQEBAQEAAAAAAAAAAAAAAAABABEh/9oACAEDAQE/EBHDK6y//8QAFxEBAQEBAAAAAAAAAAAAAAAAAQAhUf/aAAgBAgEBPxA6hNC//8QAHBABAQACAwEBAAAAAAAAAAAAAREAMSFhgUHh/9oACAEBAAE/EEbOLQ0eYOEu0eQv0RxZl4JUnWRxGhWneURhyeMTUgiXf5M//9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Chinese Salty Egg&quot;
        title=&quot;&quot;
        src=&quot;/static/8058f3f26913fea3b6a89a73344fe94a/828fb/salty_egg.jpg&quot;
        srcset=&quot;/static/8058f3f26913fea3b6a89a73344fe94a/ff44c/salty_egg.jpg 158w,
/static/8058f3f26913fea3b6a89a73344fe94a/a6688/salty_egg.jpg 315w,
/static/8058f3f26913fea3b6a89a73344fe94a/828fb/salty_egg.jpg 630w,
/static/8058f3f26913fea3b6a89a73344fe94a/0ede0/salty_egg.jpg 945w,
/static/8058f3f26913fea3b6a89a73344fe94a/3ac88/salty_egg.jpg 1260w,
/static/8058f3f26913fea3b6a89a73344fe94a/e1596/salty_egg.jpg 2048w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;You can also write code blocks here!&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const saltyDuckEgg = &amp;quot;chinese preserved food product&amp;quot;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Number&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Title&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;Year&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Harry Potter and the Philosopher’s Stone&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Harry Potter and the Chamber of Secrets&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2002&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Harry Potter and the Prisoner of Azkaban&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2004&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&quot;https://raw.github.com/adamschwartz/github-markdown-kitchen-sink/master/README.md&quot;&gt;View raw (TEST.md)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is a paragraph.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;This is a paragraph.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h1&gt;Header 1&lt;/h1&gt;
&lt;h2&gt;Header 2&lt;/h2&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;Header 1
========

Header 2
--------&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h1&gt;Header 1&lt;/h1&gt;
&lt;h2&gt;Header 2&lt;/h2&gt;
&lt;h3&gt;Header 3&lt;/h3&gt;
&lt;h4&gt;Header 4&lt;/h4&gt;
&lt;h5&gt;Header 5&lt;/h5&gt;
&lt;h6&gt;Header 6&lt;/h6&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;# Header 1
## Header 2
### Header 3
#### Header 4
##### Header 5
###### Header 6&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h1&gt;Header 1&lt;/h1&gt;
&lt;h2&gt;Header 2&lt;/h2&gt;
&lt;h3&gt;Header 3&lt;/h3&gt;
&lt;h4&gt;Header 4&lt;/h4&gt;
&lt;h5&gt;Header 5&lt;/h5&gt;
&lt;h6&gt;Header 6&lt;/h6&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;# Header 1 #
## Header 2 ##
### Header 3 ###
#### Header 4 ####
##### Header 5 #####
###### Header 6 ######&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;blockquote&gt;
&lt;p&gt;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;gt; Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;blockquote&gt;
&lt;h2&gt;This is a header.&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;This is the first list item.&lt;/li&gt;
&lt;li&gt;This is the second list item.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here&apos;s some example code:&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;Markdown.generate();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;gt; ## This is a header.
&amp;gt; 1. This is the first list item.
&amp;gt; 2. This is the second list item.
&amp;gt;
&amp;gt; Here&amp;#39;s some example code:
&amp;gt;
&amp;gt;     Markdown.generate();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;ul&gt;
&lt;li&gt;Red&lt;/li&gt;
&lt;li&gt;Green&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Red&lt;/li&gt;
&lt;li&gt;Green&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Red&lt;/li&gt;
&lt;li&gt;Green&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ul&gt;
&lt;deckgo-highlight-code language=&quot;markdown&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;- Red
- Green
- Blue

* Red
* Green
* Blue

- Red
- Green
- Blue&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;code goes&lt;/code&gt; here in this line&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bold&lt;/strong&gt; goes here&lt;/li&gt;
&lt;/ul&gt;
&lt;deckgo-highlight-code language=&quot;markdown&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;- `code goes` here in this line
- **bold** goes here&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;ol&gt;
&lt;li&gt;Buy flour and salt&lt;/li&gt;
&lt;li&gt;Mix together with water&lt;/li&gt;
&lt;li&gt;Bake&lt;/li&gt;
&lt;/ol&gt;
&lt;deckgo-highlight-code language=&quot;markdown&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;1. Buy flour and salt
1. Mix together with water
1. Bake&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;code goes&lt;/code&gt; here in this line&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bold&lt;/strong&gt; goes here&lt;/li&gt;
&lt;/ol&gt;
&lt;deckgo-highlight-code language=&quot;markdown&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;1. `code goes` here in this line
1. **bold** goes here&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;Paragraph:&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;Code&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;!-- --&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;Paragraph:

    Code&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;* * *

***

*****

- - -

---------------------------------------&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;This is &lt;a href=&quot;http://example.com&quot; title=&quot;Example&quot;&gt;an example&lt;/a&gt; link.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;This link&lt;/a&gt; has no title attr.&lt;/p&gt;
&lt;p&gt;This is &lt;a href=&quot;http://example.com&quot; title=&quot;Optional Title&quot;&gt;an example&lt;/a&gt; reference-style link.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;This is [an example](http://example.com &amp;quot;Example&amp;quot;) link.

[This link](http://example.com) has no title attr.

This is [an example] [id] reference-style link.

[id]: http://example.com &amp;quot;Optional Title&amp;quot;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;em&gt;single asterisks&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;double underscores&lt;/strong&gt;&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;*single asterisks*

_single underscores_

**double asterisks**

__double underscores__&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;This paragraph has some &lt;code class=&quot;language-text&quot;&gt;code&lt;/code&gt; in it.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;This paragraph has some `code` in it.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;img src=&quot;https://via.placeholder.com/200x50&quot; alt=&quot;Alt Text&quot; title=&quot;Image Title&quot;&gt;&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;![Alt Text](https://via.placeholder.com/200x50 &amp;quot;Image Title&amp;quot;)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;</content:encoded></item></channel></rss>