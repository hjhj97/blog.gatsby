{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/241102-canvas-gpt-quiz-1-of-3/","result":{"data":{"site":{"siteMetadata":{"title":"하주헌 개발 블로그"}},"markdownRemark":{"id":"8ec35700-c0c3-547a-9d78-fb86ae83b626","excerpt":"…","html":"<h2>배경</h2>\n<p>고전 게임 중에서 캐치마인드 라는 그림을 그리는 게임이 있다. 매턴마다 돌아가면서 그림을 그리는 사람이 정해진다. 자기 차례가 돌아오면 특정 키워드가 랜덤으로 주어지며, 그 그림에 맞게 그림을 그리는 것이다. 나머지 사람들은 그 그림을 보고 키워드를 맞추면 점수를 얻는 방식이다.</p>\n<p><img src=\"https://github.com/user-attachments/assets/94b015c3-a47d-4f93-92f1-eb702f15e5c1\" alt=\"catch-mind\">\n<em>출처 : 캐치마인드 개드립 걸작선 게시판</em></p>\n<p>이 게임 방식에서 착안하여 웹 페이지에서 그림 퀴즈를 내는 것이 가능할까 생각하게 되었다. 그래서 이번 사이드 프로젝트에서는 캐치마인드 게임을 웹 페이지에서 구현해보려고 한다. 그런데 나는 한가지 변주를 주려고 한다. 실제 캐치마인드 게임에서는 게임이 진행되기 위해서는 최소 3명이 있어야 한다. 하지만 바쁜 현대사회에서 사는 우리들은 3명을 기다릴 여유가 없다. 싱글플레이가 가능한 캐치마인드를 만들어 보려고 한다. 그럼 누가 문제를 맞추냐고? 그래서 그림을 맞추는 주체를 '사람' 이 아니라 GPT 로 바꿔보려고 한다.</p>\n<p>좀 더 기술적으로 풀어서 설명하자면, Web Canvas API(+React.js)를 활용하여 웹페이지에서 그림을 그린 다음, JPG나 PNG 파일로 저장하고 이를 OpenAI API에 전달하여 키워드를 추론하게 하는 방법이다.</p>\n<h2>프로젝트 준비</h2>\n<p>프론트엔드에서는 Vanilla JS 만으로도 Canvas API를 활용하여 그림을 그릴 수도 있지만, React.js를 활용하면 좀 더 편하게 그림을 그릴 수 있다. 또한, React.js를 활용하면 컴포넌트 단위로 관리할 수 있어서 코드의 가독성도 좋아진다. 따라서 이번 프로젝트에서는 React.js를 활용하여 그림을 그리는 방법을 사용하였다.</p>\n<p>백엔드에서는 Node.js(+Express)를 활용하였다. 사실 프론트엔드 -> OpenAI API를 직접 호출해서 결과를 받아오는 것도 가능하지만 이를 위해선 호출 할 때 API_KEY를 넣어줘야 한다. 다음 포스팅에서도 언급하겠지만,현재 OpenAI에서 무료 크레딧을 제공하는 정책이 막힌 것으로 보여, API를 호출하기 위해서는 현재로선 과금을 할 수 밖에 없는 상태이다(나는 이번 프로젝트를 위해 실제로 과금을 진행했다).</p>\n<p>브라우저에서 API_KEY를 넣게 되면 사용자에게 노출될 수 밖에 없기 때문에, 별도의 백엔드 서버를 두어서 호출하기로 했다. 따라서 이번 프로젝트에서는 백엔드에서 Node.js(+Express)를 활용하여 호출하는 방법을 사용하였다.</p>\n<h2>React로 프론트엔드 페이지 구성</h2>\n<p>내가 프로젝트를 끌고나가는 방식 중에 선호하는 방식은, 처음에는 가장 쉽고 간단한 기능만 구현해본다. 이후에 조금 더 복잡한 기능을 덧붙여 나가는 방식이다. 따라서 이번 프로젝트에서는 가장 먼저 캔버스를 구성하는 방법을 설명하고, 이후에 조금 더 다양한 기능(색상 선택, 지우개, 이미지 저장, GPT 연동)을 덧붙여 나가는 방법을 설명하려고 한다.</p>\n<h3>Step 1. 기본 캔버스 구성</h3>\n<p>가장 먼저 캔버스, 즉 그림을 그릴 수 있는 영역을 구성해야 한다. 이를 위해서는 <code class=\"language-text\">&lt;canvas></code> 태그를 사용하면 된다. 캔버스 태그는 그림을 그리는 영역을 정의하는 태그로, 웹 페이지에서 그림을 그리는 데 사용된다.</p>\n<p><img src=\"https://github.com/user-attachments/assets/0178547a-c7a1-41cb-a795-3982d913a9e9\" alt=\"step-1\"></p>\n<details>\n<summary>\n<code>Canvas.tsx</code>\n</summary>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">// Canvas.tsx\nimport React, { useRef, useEffect, useState } from &quot;react&quot;\n\ninterface CanvasProps {\n  width?: number\n  height?: number\n}\n\nconst Canvas: React.FC&lt;CanvasProps&gt; = ({ width = 800, height = 600 }) =&gt; {\n  const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null)\n  const [isDrawing, setIsDrawing] = useState&lt;boolean&gt;(false)\n  const [context, setContext] = useState&lt;CanvasRenderingContext2D | null&gt;(null)\n\n  useEffect(() =&gt; {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const ctx = canvas.getContext(&quot;2d&quot;)\n    if (!ctx) return\n\n    ctx.strokeStyle = &quot;black&quot;\n    ctx.lineWidth = 2\n    ctx.lineCap = &quot;round&quot;\n    setContext(ctx)\n  }, [])\n\n  const startDrawing = (e: React.MouseEvent&lt;HTMLCanvasElement&gt;): void =&gt; {\n    if (!context) return\n\n    const { offsetX, offsetY } = e.nativeEvent\n    context.beginPath()\n    context.moveTo(offsetX, offsetY)\n    setIsDrawing(true)\n  }\n\n  const draw = (e: React.MouseEvent&lt;HTMLCanvasElement&gt;): void =&gt; {\n    if (!isDrawing || !context) return\n\n    const { offsetX, offsetY } = e.nativeEvent\n    context.lineTo(offsetX, offsetY)\n    context.stroke()\n  }\n\n  const stopDrawing = (): void =&gt; {\n    if (!context) return\n\n    context.closePath()\n    setIsDrawing(false)\n  }\n\n  return (\n    &lt;canvas\n      ref={canvasRef}\n      width={width}\n      height={height}\n      onMouseDown={startDrawing}\n      onMouseMove={draw}\n      onMouseUp={stopDrawing}\n      onMouseOut={stopDrawing}\n    /&gt;\n  )\n}\n\nexport default Canvas</code>\n        </deckgo-highlight-code>\n</details>\n<h3>Step 2. 색상 선택 기능</h3>\n<p>아직까지는 검정색으로만 그림을 그릴 수 있다. 하지마 이는 너무 단조로우므로 색상을 선택할 수 있는 기능을 추가해보자. 이를 위해서는 <code class=\"language-text\">&lt;input type=\"color\"></code> 태그를 사용하여 색상을 선택할 수 있는 영역을 만들고, 이를 통해 선택한 색상을 캔버스에 적용하면 된다.</p>\n<p><img src=\"https://github.com/user-attachments/assets/fe033773-a234-457b-84e0-4d0e6414af08\" alt=\"step-2\"></p>\n<details>\n<summary>\n<code>Canvas.tsx</code>\n</summary>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">import React, { useRef, useEffect, useState } from &quot;react&quot;\n\ninterface CanvasProps {\n  width?: number\n  height?: number\n}\n\nconst Canvas: React.FC&lt;CanvasProps&gt; = ({ width = 800, height = 600 }) =&gt; {\n  const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null)\n  const [isDrawing, setIsDrawing] = useState&lt;boolean&gt;(false)\n  const [context, setContext] = useState&lt;CanvasRenderingContext2D | null&gt;(null)\n  const [currentColor, setCurrentColor] = useState&lt;string&gt;(&quot;#000000&quot;)\n\n  useEffect(() =&gt; {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const ctx = canvas.getContext(&quot;2d&quot;)\n    if (!ctx) return\n\n    ctx.strokeStyle = currentColor\n    ctx.lineWidth = 2\n    ctx.lineCap = &quot;round&quot;\n    setContext(ctx)\n  }, [])\n\n  useEffect(() =&gt; {\n    if (!context) return\n    context.strokeStyle = currentColor\n  }, [currentColor, context])\n\n  const startDrawing = (e: React.MouseEvent&lt;HTMLCanvasElement&gt;): void =&gt; {\n    if (!context) return\n\n    const { offsetX, offsetY } = e.nativeEvent\n    context.beginPath()\n    context.moveTo(offsetX, offsetY)\n    setIsDrawing(true)\n  }\n\n  const draw = (e: React.MouseEvent&lt;HTMLCanvasElement&gt;): void =&gt; {\n    if (!isDrawing || !context) return\n\n    const { offsetX, offsetY } = e.nativeEvent\n    context.lineTo(offsetX, offsetY)\n    context.stroke()\n  }\n\n  const stopDrawing = (): void =&gt; {\n    if (!context) return\n\n    context.closePath()\n    setIsDrawing(false)\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;div style={{ marginBottom: &quot;1rem&quot; }}&gt;\n        &lt;label htmlFor=&quot;colorPicker&quot; style={{ marginRight: &quot;0.5rem&quot; }}&gt;\n          색상 선택:\n        &lt;/label&gt;\n        &lt;input\n          id=&quot;colorPicker&quot;\n          type=&quot;color&quot;\n          value={currentColor}\n          onChange={e =&gt; setCurrentColor(e.target.value)}\n        /&gt;\n      &lt;/div&gt;\n      &lt;canvas\n        ref={canvasRef}\n        width={width}\n        height={height}\n        onMouseDown={startDrawing}\n        onMouseMove={draw}\n        onMouseUp={stopDrawing}\n        onMouseOut={stopDrawing}\n      /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default Canvas</code>\n        </deckgo-highlight-code>\n</details>\n<h3>Step 3. 지우개 기능</h3>\n<p>현재까지는 그림을 그리는 기능만 있기 때문에 잘못 그리게 되면 페이지를 새로고침 해야하는 번거로움이 있다. 그래서 지울 수 있는 기능을 제공해보자. 지우개 기능이 활성화 되면 <code class=\"language-text\">context.globalCompositeOperation</code> 을 <code class=\"language-text\">destination-out</code> 으로 설정하여 지우개 모드를 활성화 한다.\n<img src=\"https://github.com/user-attachments/assets/592135d9-00f4-4ca8-a338-cfcd6a4a5eb3\" alt=\"step-3\"></p>\n<details>\n<summary>\n<code>Canvas.tsx</code>\n</summary>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">import React, { useRef, useEffect, useState } from &quot;react&quot;\n\ninterface CanvasProps {\n  width?: number\n  height?: number\n}\n\ntype DrawingMode = &quot;draw&quot; | &quot;erase&quot;\n\nconst Canvas: React.FC&lt;CanvasProps&gt; = ({ width = 800, height = 600 }) =&gt; {\n  const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null)\n  const [isDrawing, setIsDrawing] = useState&lt;boolean&gt;(false)\n  const [context, setContext] = useState&lt;CanvasRenderingContext2D | null&gt;(null)\n  const [currentColor, setCurrentColor] = useState&lt;string&gt;(&quot;#000000&quot;)\n  const [drawingMode, setDrawingMode] = useState&lt;DrawingMode&gt;(&quot;draw&quot;)\n\n  useEffect(() =&gt; {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const ctx = canvas.getContext(&quot;2d&quot;)\n    if (!ctx) return\n\n    ctx.strokeStyle = currentColor\n    ctx.lineWidth = 2\n    ctx.lineCap = &quot;round&quot;\n    setContext(ctx)\n  }, [])\n\n  useEffect(() =&gt; {\n    if (!context) return\n\n    if (drawingMode === &quot;erase&quot;) {\n      context.globalCompositeOperation = &quot;destination-out&quot;\n      context.strokeStyle = &quot;rgba(0,0,0,1)&quot;\n    } else {\n      context.globalCompositeOperation = &quot;source-over&quot;\n      context.strokeStyle = currentColor\n    }\n  }, [drawingMode, currentColor, context])\n\n  const startDrawing = (e: React.MouseEvent&lt;HTMLCanvasElement&gt;): void =&gt; {\n    if (!context) return\n\n    const { offsetX, offsetY } = e.nativeEvent\n    context.beginPath()\n    context.moveTo(offsetX, offsetY)\n    setIsDrawing(true)\n  }\n\n  const draw = (e: React.MouseEvent&lt;HTMLCanvasElement&gt;): void =&gt; {\n    if (!isDrawing || !context) return\n\n    const { offsetX, offsetY } = e.nativeEvent\n    context.lineTo(offsetX, offsetY)\n    context.stroke()\n  }\n\n  const stopDrawing = (): void =&gt; {\n    if (!context) return\n\n    context.closePath()\n    setIsDrawing(false)\n  }\n\n  const toggleMode = () =&gt; {\n    setDrawingMode(prev =&gt; (prev === &quot;draw&quot; ? &quot;erase&quot; : &quot;draw&quot;))\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;div&gt;\n        &lt;div&gt;\n          &lt;label htmlFor=&quot;colorPicker&quot; style={{ marginRight: &quot;0.5rem&quot; }}&gt;\n            색상 선택:\n          &lt;/label&gt;\n          &lt;input\n            id=&quot;colorPicker&quot;\n            type=&quot;color&quot;\n            value={currentColor}\n            onChange={e =&gt; setCurrentColor(e.target.value)}\n            disabled={drawingMode === &quot;erase&quot;}\n          /&gt;\n        &lt;/div&gt;\n\n        &lt;button onClick={toggleMode}&gt;\n          {drawingMode === &quot;draw&quot; ? &quot;지우개 모드&quot; : &quot;그리기 모드&quot;}\n        &lt;/button&gt;\n      &lt;/div&gt;\n\n      &lt;canvas\n        ref={canvasRef}\n        width={width}\n        height={height}\n        style={{\n          border: &quot;1px solid black&quot;,\n          cursor: drawingMode === &quot;erase&quot; ? &quot;crosshair&quot; : &quot;default&quot;,\n        }}\n        onMouseDown={startDrawing}\n        onMouseMove={draw}\n        onMouseUp={stopDrawing}\n        onMouseOut={stopDrawing}\n      /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default Canvas</code>\n        </deckgo-highlight-code>\n</details>\n<h3>Step 4. 이미지 저장 기능, hook으로 분리</h3>\n<p>캔버스에 그린 그림의 이미지를 저장하는 기능을 추가해보자. 이를 위해서는 <code class=\"language-text\">canvas.toDataURL()</code> 메서드를 사용하면 된다. 이 메서드는 캔버스에 그려진 이미지를 PNG 형식의 데이터로 변환된다. 그래서 '이미지 저장' 버튼을 누르면 로컬 저장소에 이미지가 저장된다.</p>\n<p>그리고 점점 캔버스에서 처리해야하는 비즈니스 로직이 늘어남에 따라 <code class=\"language-text\">Canvas.tsx</code> 파일이 복잡해지는 것을 방지하기 위해 <code class=\"language-text\">useCanvas</code> 이라는 훅으로 만들어서 분리하기로 했다.</p>\n<details>\n<summary>\n<code>Canvas.tsx</code>\n</summary>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">// Canvas.tsx\nimport React from &quot;react&quot;\nimport { useCanvas } from &quot;../hooks/useCanvas&quot;\n\ninterface CanvasProps {\n  width?: number\n  height?: number\n}\n\nconst Canvas: React.FC&lt;CanvasProps&gt; = ({ width = 800, height = 600 }) =&gt; {\n  const {\n    canvasRef,\n    currentColor,\n    drawingMode,\n    startDrawing,\n    draw,\n    stopDrawing,\n    setCurrentColor,\n    toggleMode,\n    saveImage,\n  } = useCanvas({ width, height })\n\n  return (\n    &lt;div&gt;\n      &lt;div&gt;\n        &lt;div&gt;\n          &lt;label htmlFor=&quot;colorPicker&quot; style={{ marginRight: &quot;0.5rem&quot; }}&gt;\n            색상 선택:\n          &lt;/label&gt;\n          &lt;input\n            id=&quot;colorPicker&quot;\n            type=&quot;color&quot;\n            value={currentColor}\n            onChange={e =&gt; setCurrentColor(e.target.value)}\n            disabled={drawingMode === &quot;erase&quot;}\n          /&gt;\n        &lt;/div&gt;\n\n        &lt;button onClick={toggleMode}&gt;\n          {drawingMode === &quot;draw&quot; ? &quot;지우개 모드&quot; : &quot;그리기 모드&quot;}\n        &lt;/button&gt;\n\n        &lt;button onClick={saveImage}&gt;이미지 저장&lt;/button&gt;\n      &lt;/div&gt;\n\n      &lt;canvas\n        ref={canvasRef}\n        width={width}\n        height={height}\n        style={{\n          border: &quot;1px solid black&quot;,\n        }}\n        onMouseDown={startDrawing}\n        onMouseMove={draw}\n        onMouseUp={stopDrawing}\n        onMouseOut={stopDrawing}\n      /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default Canvas</code>\n        </deckgo-highlight-code>\n</details>\n<details>\n<summary>\n<code>useCanvas.ts</code>\n</summary>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// useCanvas.ts\nimport { useRef, useState, useEffect } from &quot;react&quot;\n\ntype DrawingMode = &quot;draw&quot; | &quot;erase&quot;\n\ninterface UseCanvasProps {\n  width: number\n  height: number\n}\n\nexport const useCanvas = ({ width, height }: UseCanvasProps) =&gt; {\n  const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null)\n  const [isDrawing, setIsDrawing] = useState&lt;boolean&gt;(false)\n  const [context, setContext] = useState&lt;CanvasRenderingContext2D | null&gt;(null)\n  const [currentColor, setCurrentColor] = useState&lt;string&gt;(&quot;#000000&quot;)\n  const [drawingMode, setDrawingMode] = useState&lt;DrawingMode&gt;(&quot;draw&quot;)\n\n  useEffect(() =&gt; {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const ctx = canvas.getContext(&quot;2d&quot;)\n    if (!ctx) return\n\n    ctx.strokeStyle = currentColor\n    ctx.lineWidth = 2\n    ctx.lineCap = &quot;round&quot;\n    setContext(ctx)\n  }, [])\n\n  useEffect(() =&gt; {\n    if (!context) return\n\n    if (drawingMode === &quot;erase&quot;) {\n      context.globalCompositeOperation = &quot;destination-out&quot;\n      context.strokeStyle = &quot;rgba(0,0,0,1)&quot;\n    } else {\n      context.globalCompositeOperation = &quot;source-over&quot;\n      context.strokeStyle = currentColor\n    }\n  }, [drawingMode, currentColor, context])\n\n  const startDrawing = (e: React.MouseEvent&lt;HTMLCanvasElement&gt;): void =&gt; {\n    if (!context) return\n\n    const { offsetX, offsetY } = e.nativeEvent\n    context.beginPath()\n    context.moveTo(offsetX, offsetY)\n    setIsDrawing(true)\n  }\n\n  const draw = (e: React.MouseEvent&lt;HTMLCanvasElement&gt;): void =&gt; {\n    if (!isDrawing || !context) return\n\n    const { offsetX, offsetY } = e.nativeEvent\n    context.lineTo(offsetX, offsetY)\n    context.stroke()\n  }\n\n  const stopDrawing = (): void =&gt; {\n    if (!context) return\n\n    context.closePath()\n    setIsDrawing(false)\n  }\n\n  const toggleMode = () =&gt; {\n    setDrawingMode(prev =&gt; (prev === &quot;draw&quot; ? &quot;erase&quot; : &quot;draw&quot;))\n  }\n\n  const saveImage = () =&gt; {\n    if (!canvasRef.current) return\n\n    const date = new Date()\n    const fileName = `drawing-${date.getFullYear()}${(date.getMonth() + 1)\n      .toString()\n      .padStart(2, &quot;0&quot;)}${date.getDate().toString().padStart(2, &quot;0&quot;)}-${date\n      .getHours()\n      .toString()\n      .padStart(2, &quot;0&quot;)}${date.getMinutes().toString().padStart(2, &quot;0&quot;)}${date\n      .getSeconds()\n      .toString()\n      .padStart(2, &quot;0&quot;)}`\n\n    const image = canvasRef.current.toDataURL(&quot;image/png&quot;)\n    const link = document.createElement(&quot;a&quot;)\n    link.download = `${fileName}.png`\n    link.href = image\n    link.click()\n  }\n\n  return {\n    canvasRef,\n    currentColor,\n    drawingMode,\n    startDrawing,\n    draw,\n    stopDrawing,\n    setCurrentColor,\n    toggleMode,\n    saveImage,\n  }\n}</code>\n        </deckgo-highlight-code>\n</details>\n<h2>그 이후 구현</h2>\n<p>이 이후에는 본인의 입맛에 맞춘 스타일링과 기능등을 추가하면 될 것이다. 나는 우선 <code class=\"language-text\">tailwindcss</code>를 활용하여 최소한의 스타일링을 하고, 그 외에 '색상 팔레트'와 '전체 지우기' 기능을 추가하였다. 각종 버튼을 담당하는 UI는 별도 컴포넌트인 <code class=\"language-text\">CanvasController.tsx</code> 파일로 분리했다.</p>\n<details>\n<summary>\n<code>Canvas.tsx</code>\n</summary>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">// Canvas.tsx\nimport { useCanvas } from &quot;../hooks/useCanvas&quot;\nimport { CanvasController } from &quot;./CanvasController&quot;\n\ninterface CanvasProps {\n  width?: number\n  height?: number\n}\n\nconst Canvas: React.FC&lt;CanvasProps&gt; = ({ width = 800, height = 600 }) =&gt; {\n  const {\n    canvasRef,\n    currentColor,\n    drawingMode,\n    startDrawing,\n    draw,\n    stopDrawing,\n    setCurrentColor,\n    toggleMode,\n    saveImage,\n    clearCanvas,\n  } = useCanvas({ width, height })\n\n  return (\n    &lt;div className=&quot;flex flex-col gap-4&quot;&gt;\n      &lt;canvas\n        ref={canvasRef}\n        width={width}\n        height={height}\n        className={`\n          border border-gray-300 rounded-lg\n          ${drawingMode === &quot;erase&quot; ? &quot;cursor-cell&quot; : &quot;cursor-crosshair&quot;}\n        `}\n        onMouseDown={startDrawing}\n        onMouseMove={draw}\n        onMouseUp={stopDrawing}\n        onMouseOut={stopDrawing}\n      /&gt;\n      &lt;CanvasController\n        currentColor={currentColor}\n        drawingMode={drawingMode}\n        setCurrentColor={setCurrentColor}\n        toggleMode={toggleMode}\n        saveImage={saveImage}\n        clearCanvas={clearCanvas}\n      /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default Canvas</code>\n        </deckgo-highlight-code>\n</details>\n<details>\n<summary>\n<code>useCanvas.ts</code>\n</summary>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// useCanvas.ts\nimport { useRef, useState, useEffect } from &quot;react&quot;\n\ntype DrawingMode = &quot;draw&quot; | &quot;erase&quot;\n\ninterface UseCanvasProps {\n  width: number\n  height: number\n}\n\n// 색상 상수 추가\nexport const COLORS = {\n  BLACK: &quot;#000000&quot;,\n  RED: &quot;#FF0000&quot;,\n  BLUE: &quot;#0000FF&quot;,\n  GREEN: &quot;#008000&quot;,\n  YELLOW: &quot;#FFD700&quot;,\n} as const\n\nexport const useCanvas = ({ width, height }: UseCanvasProps) =&gt; {\n  const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null)\n  const [isDrawing, setIsDrawing] = useState&lt;boolean&gt;(false)\n  const [context, setContext] = useState&lt;CanvasRenderingContext2D | null&gt;(null)\n  const [currentColor, setCurrentColor] = useState&lt;string&gt;(COLORS.BLACK)\n  const [drawingMode, setDrawingMode] = useState&lt;DrawingMode&gt;(&quot;draw&quot;)\n\n  useEffect(() =&gt; {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const ctx = canvas.getContext(&quot;2d&quot;)\n    if (!ctx) return\n\n    ctx.strokeStyle = currentColor\n    ctx.lineWidth = 2\n    ctx.lineCap = &quot;round&quot;\n    setContext(ctx)\n  }, [])\n\n  useEffect(() =&gt; {\n    if (!context) return\n\n    if (drawingMode === &quot;erase&quot;) {\n      context.globalCompositeOperation = &quot;destination-out&quot;\n      context.strokeStyle = &quot;rgba(0,0,0,1)&quot;\n    } else {\n      context.globalCompositeOperation = &quot;source-over&quot;\n      context.strokeStyle = currentColor\n    }\n  }, [drawingMode, currentColor, context])\n\n  const startDrawing = (e: React.MouseEvent&lt;HTMLCanvasElement&gt;): void =&gt; {\n    if (!context) return\n\n    const { offsetX, offsetY } = e.nativeEvent\n    context.beginPath()\n    context.moveTo(offsetX, offsetY)\n    setIsDrawing(true)\n  }\n\n  const draw = (e: React.MouseEvent&lt;HTMLCanvasElement&gt;): void =&gt; {\n    if (!isDrawing || !context) return\n\n    const { offsetX, offsetY } = e.nativeEvent\n    context.lineTo(offsetX, offsetY)\n    context.stroke()\n  }\n\n  const stopDrawing = (): void =&gt; {\n    if (!context) return\n\n    context.closePath()\n    setIsDrawing(false)\n  }\n\n  const toggleMode = () =&gt; {\n    setDrawingMode(prev =&gt; (prev === &quot;draw&quot; ? &quot;erase&quot; : &quot;draw&quot;))\n  }\n\n  const saveImage = () =&gt; {\n    if (!canvasRef.current) return\n\n    const date = new Date()\n    const fileName = `drawing-${date.getFullYear()}${(date.getMonth() + 1)\n      .toString()\n      .padStart(2, &quot;0&quot;)}${date.getDate().toString().padStart(2, &quot;0&quot;)}-${date\n      .getHours()\n      .toString()\n      .padStart(2, &quot;0&quot;)}${date.getMinutes().toString().padStart(2, &quot;0&quot;)}${date\n      .getSeconds()\n      .toString()\n      .padStart(2, &quot;0&quot;)}`\n\n    const image = canvasRef.current.toDataURL(&quot;image/png&quot;)\n    const link = document.createElement(&quot;a&quot;)\n    link.download = `${fileName}.png`\n    link.href = image\n    link.click()\n  }\n\n  const clearCanvas = () =&gt; {\n    if (!context || !canvasRef.current) return\n\n    // 캔버스 전체 지우기\n    context.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height)\n  }\n\n  return {\n    canvasRef,\n    currentColor,\n    drawingMode,\n    startDrawing,\n    draw,\n    stopDrawing,\n    setCurrentColor,\n    toggleMode,\n    saveImage,\n    clearCanvas,\n  }\n}</code>\n        </deckgo-highlight-code>\n</details>\n<details>\n<summary>\n<code>CanvasController.tsx</code>\n</summary>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">// CanvasController.tsx\nimport React from &quot;react&quot;\nimport { COLORS } from &quot;../hooks/useCanvas&quot;\nimport { useCanvasController } from &quot;../hooks/useCanvasController&quot;\n\ninterface ColorButtonProps {\n  color: string\n  isSelected: boolean\n  onClick: () =&gt; void\n  disabled?: boolean\n}\n\nconst ColorButton: React.FC&lt;ColorButtonProps&gt; = ({\n  color,\n  isSelected,\n  onClick,\n  disabled,\n}) =&gt; (\n  &lt;button\n    onClick={onClick}\n    disabled={disabled}\n    className={`\n      w-8 h-8 rounded-full transition-all\n      ${isSelected ? &quot;ring-2 ring-offset-2 ring-gray-400&quot; : &quot;&quot;}\n      ${disabled ? &quot;opacity-50 cursor-not-allowed&quot; : &quot;hover:scale-110&quot;}\n    `}\n    style={{ backgroundColor: color }}\n    aria-label={`Select ${color} color`}\n  /&gt;\n)\n\ninterface CanvasControllerProps {\n  currentColor: string\n  drawingMode: &quot;draw&quot; | &quot;erase&quot;\n  setCurrentColor: (color: string) =&gt; void\n  toggleMode: () =&gt; void\n  saveImage: () =&gt; void\n  clearCanvas: () =&gt; void\n}\n\nexport const CanvasController: React.FC&lt;CanvasControllerProps&gt; = props =&gt; {\n  const {\n    currentColor,\n    drawingMode,\n    setCurrentColor,\n    toggleMode,\n    saveImage,\n    clearCanvas,\n  } = useCanvasController(props)\n\n  return (\n    &lt;div className=&quot;flex items-center gap-4&quot;&gt;\n      &lt;div className=&quot;flex items-center gap-2&quot;&gt;\n        &lt;span className=&quot;mr-2&quot;&gt;색상:&lt;/span&gt;\n        &lt;div className=&quot;flex gap-2&quot;&gt;\n          {Object.entries(COLORS).map(([name, color]) =&gt; (\n            &lt;ColorButton\n              key={color}\n              color={color}\n              isSelected={currentColor === color}\n              onClick={() =&gt; setCurrentColor(color)}\n              disabled={drawingMode === &quot;erase&quot;}\n            /&gt;\n          ))}\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      &lt;button\n        onClick={toggleMode}\n        className={`\n          px-4 py-2 rounded-md text-white transition-colors\n          ${\n            drawingMode === &quot;erase&quot;\n              ? &quot;bg-red-500 hover:bg-red-600&quot;\n              : &quot;bg-blue-500 hover:bg-blue-600&quot;\n          }\n        `}\n      &gt;\n        {drawingMode === &quot;draw&quot; ? &quot;지우개 모드&quot; : &quot;그리기 모드&quot;}\n      &lt;/button&gt;\n\n      &lt;button\n        onClick={saveImage}\n        className=&quot;px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-md transition-colors&quot;\n      &gt;\n        이미지 저장\n      &lt;/button&gt;\n\n      &lt;button\n        onClick={clearCanvas}\n        className=&quot;px-4 py-2 bg-yellow-500 hover:bg-yellow-600 text-white rounded-md transition-colors&quot;\n      &gt;\n        전체 지우기\n      &lt;/button&gt;\n    &lt;/div&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n</details>\n<p>프론트엔드 페이지의 Github은 <a href=\"https://github.com/hjhj97/gpt-drawing-quiz.frontend\">이곳</a>에서 확인해 볼 수 있다.</p>\n<p>다음 포스팅에서부터는 OpenAI API를 사이트에서 API_KEY를 발급받고 express를 기반으로 간단한 API 서버를 구성할 것이다. 이를 통해 캔버스에 그린 그림을 저장하고, 이를 OpenAI API에 전달하여 키워드를 추론하는 방법을 설명하려고 한다.</p>","frontmatter":{"title":"Web Canvas API 활용하여 GPT와 캐치마인드 하기 (1 of 3)","date":"2024-11-02","description":"프론트엔트 페이지 만들기","category":"React"}},"previous":{"fields":{"slug":"/vue/241018-nuxt-rendering-mode/"},"frontmatter":{"title":"Nuxt3의 렌더링 모드"}},"next":{"fields":{"slug":"/react/241103-canvas-gpt-quiz-2-of-3/"},"frontmatter":{"title":"Web Canvas API 활용하여 GPT와 캐치마인드 하기 (2 of 3)"}}},"pageContext":{"id":"8ec35700-c0c3-547a-9d78-fb86ae83b626","previousPostId":"cce155a3-20d6-574d-8f44-6cc12c5000ad","nextPostId":"ea91a92b-aca0-5ed1-a269-ab0179efeb70"}},"staticQueryHashes":["2841359383","3821306223"],"slicesMap":{}}