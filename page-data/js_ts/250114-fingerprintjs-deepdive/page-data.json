{"componentChunkName":"component---src-templates-blog-post-js","path":"/js_ts/250114-fingerprintjs-deepdive/","result":{"data":{"site":{"siteMetadata":{"title":"하주헌 개발 블로그"}},"markdownRemark":{"id":"352e7161-09ff-5089-92e5-49e6036fa460","excerpt":"fingerprint 기법 fingerprint 기법은 브라우저에서 유저를 식별하는 방법 중 하나로 유저의 브라우저 정보, 운영체제, 화면 해상도, 폰트 등을 조합하여 유저를 식별해준다. 신뢰성을 10…","html":"<h2>fingerprint 기법</h2>\n<p>fingerprint 기법은 브라우저에서 유저를 식별하는 방법 중 하나로 유저의 브라우저 정보, 운영체제, 화면 해상도, 폰트 등을 조합하여 유저를 식별해준다. 신뢰성을 100% 보장할 수는 없기 때문에 식별에 실패하더라도 큰 지장이 없는 광고 타겟팅을 위한 용도로 사용되곤 한다.</p>\n<p>fingerprint 기법을 구현한 대표적인 오픈소스가 바로 <a href=\"https://fingerprint.com/\"><code class=\"language-text\">fingerprint.js</code></a>이다. 이 외에도 npmjs에서 찾아보면 여러가지 라이브러리가 존재한다. 이 글에서는 fingerprint.js에 대해 알아보고 어떤 원리로 동작하는지, 어떤 문제가 있는지 알아보고자 한다.</p>\n<p>참고로, <code class=\"language-text\">fingerprint.js</code>와 유료버전인 fingerprint Pro 의 데모 페이지는 <a href=\"https://fingerprintjs-vue3-demo.vercel.app/\">이곳</a>에서 확인할 수 있다.\n(유료 버전은 free-trial 기간이 지나면 비활성화 될 수도 있다).</p>\n<h2>어떤 원리로 동작하는가?</h2>\n<p><code class=\"language-text\">fingerprint.js</code>는 <a href=\"https://github.com/fingerprintjs/fingerprintjs\">github</a> 에 공개되어 있기 때문에 이를 분석해보며 어떻게 동작하는지 대략적으로 살펴보도록 하자.\n공식문서에 나와있는 예시 코드는 아래와 같다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">import FingerprintJS from &quot;@fingerprintjs/fingerprintjs&quot;\nexport const getFingerprint = async () =&gt; {\n  const fp = await FingerprintJS.load()\n  const { visitorId, confidence, components } = await fp.get()\n  return { visitorId, confidence, components }\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">load</code> 함수를 통해 유저를 식별하는 함수를 비동기로 실행한 후, <code class=\"language-text\">get</code> 함수를 통해 받아오고 있다. 가장 먼저 프로젝트의 엔트리 포인트인 <code class=\"language-text\">/src/index.ts</code>를 찾아보자.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// /src/index.ts\nimport { load, ... } from &#39;./agent&#39;\n...</code>\n        </deckgo-highlight-code>\n<p>역시나 엔트리 포인트에서 <code class=\"language-text\">load</code> 함수를 찾을 수 있다. 계속해서 <code class=\"language-text\">agent.ts</code> 파일을 찾아보자.</p>\n<p><code class=\"language-text\">/src/agent.ts</code> 파일을 찾아보면 <code class=\"language-text\">load</code> 함수를 찾을 수 있다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// /src/agent.ts\n...\nexport async function load(\n  options: Readonly&lt;LoadOptions&gt; = {}\n): Promise&lt;Agent&gt; {\n  if ((options as { monitoring?: boolean }).monitoring ?? true) {\n    monitor()\n  }\n  const { delayFallback, debug } = options\n  await prepareForSources(delayFallback)\n  const getComponents = loadBuiltinSources({ cache: {}, debug })\n  return makeAgent(getComponents, debug)\n}\n</code>\n        </deckgo-highlight-code>\n<p>여러가지 처음 보는 함수와 변수들이 등장하여 혼란스럽지만 주목해서 봐야할 것은 <code class=\"language-text\">loadBuiltinSources</code> 함수이다. 이 함수를 통해 브라우저 정보, 운영체제, 화면 해상도, 폰트 등을 조합하여 유저를 식별하게 해준다. <code class=\"language-text\">loadBuiltinSources</code> 함수가 위치해 있는 <code class=\"language-text\">/src/sources/index.ts</code> 파일을 찾아보자.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// /src/sources/index.ts\n...\nexport default function loadBuiltinSources(options: BuiltinSourceOptions): () =&gt; Promise&lt;BuiltinComponents&gt; {\n  return loadSources(sources, options, [])\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">loadBuiltinSources</code> 함수는 <code class=\"language-text\">loadSources</code> 함수를 호출하고 있다. 첫 번째 인자로 들어가는 <code class=\"language-text\">sources</code> 변수를 주목해서 봐야하는데, 코드의 양이 방대하여 접어놓도록 하겠다.</p>\n<details>\n<summary>./src/sources/index.ts</summary>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// /src/sources/index.ts\nimport getAudioFingerprint from &#39;./audio&#39;\nimport getFonts from &#39;./fonts&#39;\nimport getPlugins from &#39;./plugins&#39;\n...\n// import문 생략\n\nexport const sources = {\n  fonts: getFonts,\n  domBlockers: getDomBlockers,\n  fontPreferences: getFontPreferences,\n  audio: getAudioFingerprint,\n  screenFrame: getScreenFrame,\n\n  canvas: getCanvasFingerprint,\n  osCpu: getOsCpu,\n  languages: getLanguages,\n  colorDepth: getColorDepth,\n  deviceMemory: getDeviceMemory,\n  screenResolution: getScreenResolution,\n  hardwareConcurrency: getHardwareConcurrency,\n  timezone: getTimezone,\n  sessionStorage: getSessionStorage,\n  localStorage: getLocalStorage,\n  indexedDB: getIndexedDB,\n  openDatabase: getOpenDatabase,\n  cpuClass: getCpuClass,\n  platform: getPlatform,\n  plugins: getPlugins,\n  touchSupport: getTouchSupport,\n  vendor: getVendor,\n  vendorFlavors: getVendorFlavors,\n  cookiesEnabled: areCookiesEnabled,\n  colorGamut: getColorGamut,\n  invertedColors: areColorsInverted,\n  forcedColors: areColorsForced,\n  monochrome: getMonochromeDepth,\n  contrast: getContrastPreference,\n  reducedMotion: isMotionReduced,\n  reducedTransparency: isTransparencyReduced,\n  hdr: isHDR,\n  math: getMathFingerprint,\n  pdfViewerEnabled: isPdfViewerEnabled,\n  architecture: getArchitecture,\n  applePay: getApplePayState,\n  privateClickMeasurement: getPrivateClickMeasurement,\n  audioBaseLatency: getAudioContextBaseLatency,\n\n\n  webGlBasics: getWebGlBasics,\n  webGlExtensions: getWebGlExtensions,\n}\n...\nexport default function loadBuiltinSources(\n  options: BuiltinSourceOptions\n): () =&gt; Promise&lt;BuiltinComponents&gt; {\n  return loadSources(sources, options, [])\n}</code>\n        </deckgo-highlight-code>\n</details>\n<p>보다시피 <code class=\"language-text\">sources</code> 변수 안에는 유저를 식별하기 위한 수많은 파라미터들(함수)로 구성되어 있다. 이 함수들이 <code class=\"language-text\">loadSources</code> 함수를 통해 실행되면서 유저를 식별하는 데이터를 추출하게 된다.</p>\n<p>수많은 파라미터(판별 함수)가 있지만 이 글에서는 가장 대표적인 '설치된 폰트 판별' 과 'Canvas fingerprint' 에 대해 알아보도록 하겠다.</p>\n<h3>설치된 폰트 판별</h3>\n<p>디바이스마다 설치되어있는 폰트의 종류가 다르기 때문에(100%는 아니지만), 이를 통해 디바이스를 식별하려는 아이디어이다.</p>\n<p>그런데 사실 일개 브라우저가 디바이스에 설치되어 있는 폰트 리스트를 갖고 오는 행위는 보안상 문제로 인하여 불가능하다(폰트도 엄연한 시스템 레벨의 데이터다). 하지만 약간의 꼼수를 발휘하면 설치된 폰트를 유추할 수 있는 방법이 있다.<br>\n바로 test string을 HTML에 삽입하여 해당 문자열이 차지하는 영역의 <code class=\"language-text\">width</code>와 <code class=\"language-text\">height</code>값을 통해 폰트의 존재 여부를 판단하는 것이다. <strong>폰트의 종류별로 렌더링되는 영역의 크기가 다르기 때문에</strong>(100%는 아니지만) 이를 통해 특정 폰트의 설치 여부를 판단할 수 있다.</p>\n<p>'A'라는 폰트가 설치되어 있는지 판단한다고 해보자. 만약 'A' 폰트가 설치되어 있지 않다면 디바이스에서 기본으로 설치되어있는 폰트가 설정된다. fingerprint.js에서는 이를 <code class=\"language-text\">baseFonts</code> 라고 부르며 <code class=\"language-text\">monospace</code>, <code class=\"language-text\">sans-serif</code>, <code class=\"language-text\">serif</code> 3종류의 폰트가 있다.<br>\ntest string을 렌더링한 HTML의 영역이 만약 <code class=\"language-text\">baseFonts</code> 폰트 3종류 중 어느 한개라도 차지하는 영역과 일치한다면 'A' 폰트는 설치되지 않았으며, <code class=\"language-text\">baseFonts</code>가 렌더링된 것으로 간주한다. 반대로 3종류의 <code class=\"language-text\">baseFonts</code> 폰트가 차지하는 영역과 일치하지 않는다면 'A' 폰트가 렌더링(설치)된 것으로 간주한다.</p>\n<p>이 로직을 머리에 담아두고 실제 <a href=\"https://github.com/fingerprintjs/fingerprintjs/blob/master/src/sources/fonts.ts\">소스코드</a>를 보자. <code class=\"language-text\">/src/sources/fonts.ts</code> 에서 찾을 수 있다.</p>\n<details>\n<summary>./src/sources/fonts.ts</summary>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// /src/sources/fonts.ts\n// 일부 주석은 삭제함\nimport { withIframe } from &quot;../utils/dom&quot;\n\nconst testString = &quot;mmMwWLliI0O&amp;1&quot;\nconst textSize = &quot;48px&quot;\nconst baseFonts = [&quot;monospace&quot;, &quot;sans-serif&quot;, &quot;serif&quot;] as const\n\nconst fontList = [\n  // This is android-specific font from &quot;Roboto&quot; family\n  &quot;sans-serif-thin&quot;,\n  &quot;ARNO PRO&quot;,\n  &quot;Agency FB&quot;,\n  &quot;Arabic Typesetting&quot;,\n  &quot;Arial Unicode MS&quot;,\n  &quot;AvantGarde Bk BT&quot;,\n  &quot;BankGothic Md BT&quot;,\n  &quot;Batang&quot;,\n  &quot;Bitstream Vera Sans Mono&quot;,\n  &quot;Calibri&quot;,\n  &quot;Century&quot;,\n  &quot;Century Gothic&quot;,\n  &quot;Clarendon&quot;,\n  &quot;EUROSTILE&quot;,\n  &quot;Franklin Gothic&quot;,\n  &quot;Futura Bk BT&quot;,\n  &quot;Futura Md BT&quot;,\n  &quot;GOTHAM&quot;,\n  &quot;Gill Sans&quot;,\n  &quot;HELV&quot;,\n  &quot;Haettenschweiler&quot;,\n  &quot;Helvetica Neue&quot;,\n  &quot;Humanst521 BT&quot;,\n  &quot;Leelawadee&quot;,\n  &quot;Letter Gothic&quot;,\n  &quot;Levenim MT&quot;,\n  &quot;Lucida Bright&quot;,\n  &quot;Lucida Sans&quot;,\n  &quot;Menlo&quot;,\n  &quot;MS Mincho&quot;,\n  &quot;MS Outlook&quot;,\n  &quot;MS Reference Specialty&quot;,\n  &quot;MS UI Gothic&quot;,\n  &quot;MT Extra&quot;,\n  &quot;MYRIAD PRO&quot;,\n  &quot;Marlett&quot;,\n  &quot;Meiryo UI&quot;,\n  &quot;Microsoft Uighur&quot;,\n  &quot;Minion Pro&quot;,\n  &quot;Monotype Corsiva&quot;,\n  &quot;PMingLiU&quot;,\n  &quot;Pristina&quot;,\n  &quot;SCRIPTINA&quot;,\n  &quot;Segoe UI Light&quot;,\n  &quot;Serifa&quot;,\n  &quot;SimHei&quot;,\n  &quot;Small Fonts&quot;,\n  &quot;Staccato222 BT&quot;,\n  &quot;TRAJAN PRO&quot;,\n  &quot;Univers CE 55 Medium&quot;,\n  &quot;Vrinda&quot;,\n  &quot;ZWAdobeF&quot;,\n] as const\n\nexport default function getFonts(): Promise&lt;string[]&gt; {\n  return withIframe(async (_, { document }) =&gt; {\n    const holder = document.body\n    holder.style.fontSize = textSize\n\n    // div to load spans for the default fonts and the fonts to detect\n    const spansContainer = document.createElement(&quot;div&quot;)\n    spansContainer.style.setProperty(&quot;visibility&quot;, &quot;hidden&quot;, &quot;important&quot;)\n\n    const defaultWidth: Partial&lt;Record&lt;string, number&gt;&gt; = {}\n    const defaultHeight: Partial&lt;Record&lt;string, number&gt;&gt; = {}\n\n    // creates a span where the fonts will be loaded\n    const createSpan = (fontFamily: string) =&gt; {\n      const span = document.createElement(&quot;span&quot;)\n      const { style } = span\n      style.position = &quot;absolute&quot;\n      style.top = &quot;0&quot;\n      style.left = &quot;0&quot;\n      style.fontFamily = fontFamily\n      span.textContent = testString\n      spansContainer.appendChild(span)\n      return span\n    }\n\n    // creates a span and load the font to detect and a base font for fallback\n    const createSpanWithFonts = (fontToDetect: string, baseFont: string) =&gt; {\n      return createSpan(`&#39;${fontToDetect}&#39;,${baseFont}`)\n    }\n\n    // creates spans for the base fonts and adds them to baseFontsDiv\n    const initializeBaseFontsSpans = () =&gt; {\n      return baseFonts.map(createSpan)\n    }\n\n    // creates spans for the fonts to detect and adds them to fontsDiv\n    const initializeFontsSpans = () =&gt; {\n      // Stores {fontName : [spans for that font]}\n      const spans: Record&lt;string, HTMLSpanElement[]&gt; = {}\n\n      for (const font of fontList) {\n        spans[font] = baseFonts.map(baseFont =&gt;\n          createSpanWithFonts(font, baseFont)\n        )\n      }\n\n      return spans\n    }\n\n    // checks if a font is available\n    const isFontAvailable = (fontSpans: HTMLElement[]) =&gt; {\n      return baseFonts.some(\n        (baseFont, baseFontIndex) =&gt;\n          fontSpans[baseFontIndex].offsetWidth !== defaultWidth[baseFont] ||\n          fontSpans[baseFontIndex].offsetHeight !== defaultHeight[baseFont]\n      )\n    }\n\n    // create spans for base fonts\n    const baseFontsSpans = initializeBaseFontsSpans()\n\n    // create spans for fonts to detect\n    const fontsSpans = initializeFontsSpans()\n\n    // add all the spans to the DOM\n    holder.appendChild(spansContainer)\n\n    // get the default width for the three base fonts\n    for (let index = 0; index &lt; baseFonts.length; index++) {\n      defaultWidth[baseFonts[index]] = baseFontsSpans[index].offsetWidth\n      defaultHeight[baseFonts[index]] = baseFontsSpans[index].offsetHeight\n    }\n\n    // check available fonts\n    return fontList.filter(font =&gt; isFontAvailable(fontsSpans[font]))\n  })\n}</code>\n        </deckgo-highlight-code>\n</details>\n<br />\n<p><code class=\"language-text\">fontList</code> 배열에 들어있는 폰트의 종류를 <code class=\"language-text\">testString</code> 문자열로 렌더링하여 <code class=\"language-text\">width</code>와 <code class=\"language-text\">height</code>를 측정한다.<br>\n그리고 <code class=\"language-text\">isFontAvailable</code>함수에서 이 측정값이 <code class=\"language-text\">baseFonts</code> 배열에 들어있는 폰트들의 <code class=\"language-text\">defaultWidth</code>와 <code class=\"language-text\">defaultHeight</code>와 하나라도 일치하지 않으면 <code class=\"language-text\">true</code>를 반환하여 해당 폰트는 설치된 것으로 간주한다.<br>\n만약 폰트가 설치되어 있지 않다면 <code class=\"language-text\">baseFonts</code>에 들어있는 폰트들의 <code class=\"language-text\">defaultWidth</code>와 <code class=\"language-text\">defaultHeight</code>가 모두 일치할 것이므로 <code class=\"language-text\">false</code>를 반환할 것이다.</p>\n<p>코드를 살펴보면 가질 수 있는 의문점이 하나 있다. HTML상에서 <code class=\"language-text\">testString</code> 이 렌더링 된다면 실제 사용자 눈에 직접 보일 수도 있지 않느냐 하는 점이다.<br>\n이를 방지해주는 함수가 <code class=\"language-text\">withIframe</code> 함수이다. 이 함수는 외부 스크립트를 실행하는 것이 아닌 <code class=\"language-text\">iframe</code> 내부에서 실행하여 외부 HTML에는 영향을 받지 않도록 해준다. <code class=\"language-text\">getFonts</code> 함수의 리턴값도 <code class=\"language-text\">withIframe</code> 함수를 통해 실행되므로 실제 사용자 눈에 보이지 않는다.</p>\n<p>이 방법의 장점 중 하나는 <strong>브라우저의 종류에 영향을 받지 않는다</strong>는 점이다. 아래 첨부한 이미지는 위에서부터 Chrome, Safari, Firefox 브라우저에서 내가 직접 개발하여 출시한 <code class=\"language-text\">font-fingerprint</code> <a href=\"https://github.com/hjhj97/font-fingerprint\">패키지</a>를 각각 실행한 결과이다. 보다시피 모든 브라우저에서 동일한 <code class=\"language-text\">Visitor ID</code>와 <code class=\"language-text\">font</code> 값이 나오고 있음을 확인할 수 있다.</p>\n<p><img src=\"https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737987532/blog/assets/demo.png\" alt=\"font-fingerprint\"></p>\n<p><a href=\"https://hjhj97.github.io/font-fingerprint/\">데모 페이지</a>는 이곳에서 확인해볼 수 있다.</p>\n<p>두 번째 방법인 Canvas fingerprint 에서도 언급하겠지만, 일부 fingerprint 에서 사용하는 파라미터는 같은 디바이스에서도 브라우저의 종류에 따라 결과값이 달라지기 때문에, 이로 인한 영향을 받지 않기 위해서는 설치된 폰트 리스트로만 판단하는 것이 좋다.</p>\n<h3>Canvas fingerprint</h3>\n<p>Canvas fingerprint는 브라우저의 Canvas API를 통해 캔버스를 그리는 방식을 판별하는 기법이다. 캔버스에 동일한 geometry를 그리더라도 브라우저의 종류, GPU 등에 따라서 픽셀 단위에서는 다르게 그려질 수 있다.</p>\n<p>fingerprint.js에서는 크게 <code class=\"language-text\">renderTextImage</code> 와 <code class=\"language-text\">renderGeometryImage</code> 2가지 함수를 통해 판별하고 있다. 이를 담당하고 있는 <a href=\"https://github.com/fingerprintjs/fingerprintjs/blob/master/src/sources/canvas.ts\">소스코드</a>는 <code class=\"language-text\">/src/sources/canvas.ts</code> 파일이다.</p>\n<details>\n<summary>./src/sources/canvas.ts</summary>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// /src/sources/canvas.ts\n// 일부 주석 제거\nimport { isSafariWebKit, isWebKit, isWebKit616OrNewer } from &quot;../utils/browser&quot;\n\nexport interface CanvasFingerprint {\n  winding: boolean\n  geometry: string\n  text: string\n}\n\nexport const enum ImageStatus {\n  Unsupported = &quot;unsupported&quot;,\n  Skipped = &quot;skipped&quot;,\n  Unstable = &quot;unstable&quot;,\n}\n\nexport default function getCanvasFingerprint(): CanvasFingerprint {\n  return getUnstableCanvasFingerprint(doesBrowserPerformAntifingerprinting())\n}\n\nexport function getUnstableCanvasFingerprint(\n  skipImages?: boolean\n): CanvasFingerprint {\n  let winding = false\n  let geometry: string\n  let text: string\n\n  const [canvas, context] = makeCanvasContext()\n  if (!isSupported(canvas, context)) {\n    geometry = text = ImageStatus.Unsupported\n  } else {\n    winding = doesSupportWinding(context)\n\n    if (skipImages) {\n      geometry = text = ImageStatus.Skipped\n    } else {\n      ;[geometry, text] = renderImages(canvas, context)\n    }\n  }\n\n  return { winding, geometry, text }\n}\n\nfunction makeCanvasContext() {\n  const canvas = document.createElement(&quot;canvas&quot;)\n  canvas.width = 1\n  canvas.height = 1\n  return [canvas, canvas.getContext(&quot;2d&quot;)] as const\n}\n\nfunction isSupported(\n  canvas: HTMLCanvasElement,\n  context?: CanvasRenderingContext2D | null\n): context is CanvasRenderingContext2D {\n  return !!(context &amp;&amp; canvas.toDataURL)\n}\n\nfunction doesSupportWinding(context: CanvasRenderingContext2D) {\n  context.rect(0, 0, 10, 10)\n  context.rect(2, 2, 6, 6)\n  return !context.isPointInPath(5, 5, &quot;evenodd&quot;)\n}\n\nfunction renderImages(\n  canvas: HTMLCanvasElement,\n  context: CanvasRenderingContext2D\n): [geometry: string, text: string] {\n  renderTextImage(canvas, context)\n  const textImage1 = canvasToString(canvas)\n  const textImage2 = canvasToString(canvas)\n\n  if (textImage1 !== textImage2) {\n    return [ImageStatus.Unstable, ImageStatus.Unstable]\n  }\n\n  renderGeometryImage(canvas, context)\n  const geometryImage = canvasToString(canvas)\n  return [geometryImage, textImage1]\n}\n\nfunction renderTextImage(\n  canvas: HTMLCanvasElement,\n  context: CanvasRenderingContext2D\n) {\n  canvas.width = 240\n  canvas.height = 60\n\n  context.textBaseline = &quot;alphabetic&quot;\n  context.fillStyle = &quot;#f60&quot;\n  context.fillRect(100, 1, 62, 20)\n\n  context.fillStyle = &quot;#069&quot;\n  context.font = &#39;11pt &quot;Times New Roman&quot;&#39;\n  const printedText = `Cwm fjordbank gly ${\n    String.fromCharCode(55357, 56835) /* 😃 */\n  }`\n  context.fillText(printedText, 2, 15)\n  context.fillStyle = &quot;rgba(102, 204, 0, 0.2)&quot;\n  context.font = &quot;18pt Arial&quot;\n  context.fillText(printedText, 4, 45)\n}\n\nfunction renderGeometryImage(\n  canvas: HTMLCanvasElement,\n  context: CanvasRenderingContext2D\n) {\n  canvas.width = 122\n  canvas.height = 110\n  context.globalCompositeOperation = &quot;multiply&quot;\n  for (const [color, x, y] of [\n    [&quot;#f2f&quot;, 40, 40],\n    [&quot;#2ff&quot;, 80, 40],\n    [&quot;#ff2&quot;, 60, 80],\n  ] as const) {\n    context.fillStyle = color\n    context.beginPath()\n    context.arc(x, y, 40, 0, Math.PI * 2, true)\n    context.closePath()\n    context.fill()\n  }\n\n  context.fillStyle = &quot;#f9c&quot;\n  context.arc(60, 60, 60, 0, Math.PI * 2, true)\n  context.arc(60, 60, 20, 0, Math.PI * 2, true)\n  context.fill(&quot;evenodd&quot;)\n}\n\nfunction canvasToString(canvas: HTMLCanvasElement) {\n  return canvas.toDataURL()\n}\n\nfunction doesBrowserPerformAntifingerprinting() {\n  // Safari 17\n  return isWebKit() &amp;&amp; isWebKit616OrNewer() &amp;&amp; isSafariWebKit()\n}</code>\n        </deckgo-highlight-code>\n</details>\n<br />\n<p>canvas를 그리기에 앞서 유저의 환경에서 canvas API를 지원하는지부터 판단한다.</p>\n<p>우선 <code class=\"language-text\">doesBrowserPerformAntifingerprinting</code> 함수는 브라우저가 fingerprint 를 차단하는지 판단한다. 함수 내부를 살펴보면 <code class=\"language-text\">webkit</code> 환경으로 이뤄져있는 safari 17버전 이상의 브라우저에서는 해당 조건을 만족하기 때문에 <code class=\"language-text\">ImageStatus</code>는 <code class=\"language-text\">Skipped</code> 로 설정된다.</p>\n<p>그런 다음 <code class=\"language-text\">isSupported</code> 함수를 통해서 <code class=\"language-text\">document</code> 객체에서 <code class=\"language-text\">canvas</code> 엘리먼트를 생성해주는지를 판단한다.</p>\n<p>마지막으로 <code class=\"language-text\">doesSupportWinding</code> 함수를 통해서 브라우저가 캔버스를 그리는 방식을 판단한다. <code class=\"language-text\">Winding</code>이란 canvas에서 경로의 내부와 외부를 정의하는 방식으로, 구형 브라우저에서는 지원하지 않을 수도 있는 속성이라고 한다.</p>\n<p>이제 본격적으로 canvas위에 그려보도록 하자.<code class=\"language-text\">renderTextImage</code> 함수를 살펴보면 다음과 같은 과정이 일어난다.</p>\n<ul>\n<li>캔버스의 크기를 240x60으로 설정한다.</li>\n<li>캔버스의 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textBaseline\">textBaseline</a>을 <code class=\"language-text\">alphabetic</code>로 설정한다.</li>\n<li>직사각형을 그리고 색상을 <code class=\"language-text\">#f60</code>으로 색칠한다.</li>\n<li>폰트의 크기,종류,색상을 설정하고 <code class=\"language-text\">printedText</code> 문자열을 캔버스에 그린다. 문자열 맨 끝에는 이모지를 붙인다.</li>\n<li>이후에 비슷한 과정을 한번 더 반복한다.</li>\n</ul>\n<p>일련의 과정을 거치고 나면 아래와 같은 이미지가 캔버스에 그려진다.\n<img src=\"https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983309/blog/assets/4d1c7159-9a23-4473-a039-7bfe3375bf2c_zjexik.png\" alt=\"image\"></p>\n<p>캔버스에 그려진 이미지를 <code class=\"language-text\">canvasToString</code> 함수 안에 <code class=\"language-text\">canvas.toDataURL</code> 함수를 통해 Base64 형태의 문자열로 변환한다. 내가 직접 크롬과 firefox 브라우저에서 각각 테스트해본 결과, 렌더링되는 이미지가 육안상으로는 동일하였으나 실제로 Base64로 인코딩된 데이터는 각기 다르게 나왔다.<br>\n찾아보니 동일한 canvas 코드라도 실행한 브라우저의 종류에 따라서 폰트 렌더링, 안티앨리어싱 등에 따라서 결과값이 달라질 수 있다고 한다.</p>\n<p>다음으로 <code class=\"language-text\">renderGeometryImage</code> 함수를 살펴보면 다음과 같은 과정이 일어난다.</p>\n<ul>\n<li>캔버스의 크기를 122x110으로 설정한다.</li>\n<li>3종류의 색상을 가진 원을 일부가 겹치도록 그려놓는다.(벤다이어그램처럼)</li>\n<li>큰 원과 작은원을 다시 겹쳐놓는다.</li>\n</ul>\n<p>이 과정을 거치면 아래와 같은 이미지가 캔버스에 그려진다.</p>\n<div>\n<img src=\"https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983310/blog/assets/35fca6b5-e801-4940-b341-cd2277f8bc41_glhkux.png\" alt=\"canvas-text-image\" style=\"width: 240px\">\n</div>\n<p>과정을 통해 '브라우저가 원을 처리하는 방식'과 각기 다른 색상이 겹쳤을 때 '색의 혼합을 어떻게 처리하는지'를 판단하게 된다. 이 또한 브라우저의 종류에 따라 결과값이 달라질 수 있다.</p>\n<h2>어떤 문제(한계)가 있는가?</h2>\n<p><code class=\"language-text\">fingerprint.js</code>의 가장 큰 한계(단점)은 바로 신뢰성이다.<br>\n공식문서나 레퍼런스/커뮤니티에서 말하는 fingerprint 기법의 신뢰도는 40~60% 라고 한다. fingerprint의 가장 이상적인 목표는 컴퓨터(혹은 스마트폰)을 사용하고 있는 유저가 이전에 접속한 사람과 동일인물인지 아닌지를 식별하는 것이다.</p>\n<p>하지만 위 2가지 판별함수에서 살펴보았다시피, 동일한 디바이스라 할지라도 브라우저의 종류에 따라 결과값이 달라질 수 있다. 즉 사용자가 마음만 먹으면 브라우저의 종류를 바꿈으로써 판별을 우회할 수 있다.<br>\n실제 npm에는 fingerprint-injector 와 같이 접속한 환경을 의도적으로 조작할 수 있는 패키지도 이미 출시되어있다. 뿐만 아니라 브라우저의 종류뿐만 아니라 화면의 해상도에 영향받기도 하며, 폰트를 새로 설치하거나 삭제하더라도 식별값이 달라질 수 있다.</p>\n<p>때문에 fingerprint.js의 유료 버전인 fingerprint Pro 에서는 신뢰도를 99%까지 끌어올려서 제공하고 있다. Pro 버전이 신뢰도가 높은 이유는 식별값을 클라이언트(브라우저)가 아닌 서버에서 생성하기 때문이다. 자세한 차이점은 <a href=\"https://github.com/fingerprintjs/fingerprintjs/blob/master/docs/comparison.md\">이곳</a>에서 확인해볼 수 있다.</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://hovav.net/ucsd/dist/canvas.pdf\">https://hovav.net/ucsd/dist/canvas.pdf</a></li>\n<li><a href=\"https://github.com/fingerprintjs/fingerprintjs\">https://github.com/fingerprintjs/fingerprintjs</a></li>\n<li><a href=\"https://dev.gmarket.com/94\">https://dev.gmarket.com/94</a></li>\n<li><a href=\"https://dev.fingerprint.com/docs/introduction#fingerprint-identification-vs-fingerprintjs\">https://dev.fingerprint.com/docs/introduction#fingerprint-identification-vs-fingerprintjs</a></li>\n</ul>","frontmatter":{"title":"fingerprint.js에 대해 알아보자","date":"2025-01-14","keywords":null,"description":"fingerprint.js는 어떻게 유저를 식별해낼까?","category":"JS/TS"}},"previous":{"fields":{"slug":"/vue/250106-vue-korean-input/"},"frontmatter":{"title":"Vue에서 한글을 입력할 때 생기는 2가지 이슈"}},"next":{"fields":{"slug":"/essay/250121-review-2024/"},"frontmatter":{"title":"2024년 회고"}}},"pageContext":{"id":"352e7161-09ff-5089-92e5-49e6036fa460","previousPostId":"40279e45-80d1-5c1f-afb2-63c3a437c673","nextPostId":"c2806575-fcee-5a81-b968-c63034107c77"}},"staticQueryHashes":["2841359383","3821306223"],"slicesMap":{}}