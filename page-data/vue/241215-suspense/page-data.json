{"componentChunkName":"component---src-templates-blog-post-js","path":"/vue/241215-suspense/","result":{"data":{"site":{"siteMetadata":{"title":"하주헌 개발 블로그"}},"markdownRemark":{"id":"67db4de0-9068-50c2-aa10-dbbe8686be56","excerpt":"컴포넌트 Vue에서 제공하는 내장 컴포넌트 중에서  가 있다. 비동기  혹은 비동기 컴포넌트의 데이터가 준비 완료되기 전까지  템플릿을 보여주는 기능으로, React 진영의  와 사실상 동일하다고 볼 수 있다. Vue 버전  기준으로 아직까지는 experimental…","html":"<h2><code class=\"language-text\">&lt;Suspense></code> 컴포넌트</h2>\n<p>Vue에서 제공하는 내장 컴포넌트 중에서 <code class=\"language-text\">&lt;Suspense></code> 가 있다. 비동기 <code class=\"language-text\">setup</code> 혹은 비동기 컴포넌트의 데이터가 준비 완료되기 전까지 <code class=\"language-text\">fallback</code> 템플릿을 보여주는 기능으로, React 진영의 <code class=\"language-text\">&lt;Suspense></code> 와 사실상 동일하다고 볼 수 있다.</p>\n<p>Vue 버전 <code class=\"language-text\">3.5.13</code> 기준으로 아직까지는 experimental 기능이지만, github에 올라오는 discussion 에 따르면 조만간 정식 기능으로서 추가될 것으로 보인다(2년동안 그러고 있다는 건 비밀).</p>\n<p>그렇다면 어떻게 사용하는지에 대해서 알아보자.</p>\n<p><a href=\"https://vuejs.org/guide/built-ins/suspense.html#suspense\">공식문서</a>에 따르면, <code class=\"language-text\">&lt;Suspense></code> 가 기다릴 수 있는 2가지 유형의 의존성이 있다. 사실 2가지로 나뉘어 있다기 보단, 1번 조건(<code class=\"language-text\">async setup</code>)을 만족하면 자동적으로 2번 조건(<code class=\"language-text\">async component</code>)이 충족된다에 가깝다.</p>\n<h3>1. <code class=\"language-text\">async setup</code></h3>\n<p>Vue3의 Composition API에서는 기본적으로 <code class=\"language-text\">setup(){...}</code> 함수 안에 비즈니스 로직을 작성하게 된다. 만약 함수 내부에서 <code class=\"language-text\">await</code> 문을 사용하여 비동기 함수를 호출하고 싶다면 <code class=\"language-text\">async setup</code> 와 같이 작성하면 된다. <code class=\"language-text\">script setup</code> 을 사용하고 있더라도 동일하게 <code class=\"language-text\">Top-level await</code> 를 하면 된다.</p>\n<details>\n<summary>예시코드</summary>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">  // AsyncChild.vue\n  &lt;script&gt;\n  export default {\n  \tasync setup(){\n  \t\tconst fetchData = () =&gt; {...}\n  \t\tawait fetchData();\n  \t}\n  \t...</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">  &lt;script setup&gt;\n  const fetchData = () =&gt; {...}\n  await fetchData();\n  ...</code>\n        </deckgo-highlight-code>\n</details>\n<h3>2. <code class=\"language-text\">async component</code> (비동기 컴포넌트)</h3>\n<p><code class=\"language-text\">defineAsyncComponent</code> 함수와 동적 <code class=\"language-text\">import</code> 문을 조합하면 비동기 컴포넌트를 얻을 수 있다. 비동기 컴포넌트를 <code class=\"language-text\">&lt;Suspense></code> 문의 default slot으로 넣게되면 로딩이 완료되기 전까지는 fallback slot 으로 넣은 템플릿을 보여주다가, 완료되면 비동기 컴포넌트를 보여준다.</p>\n<details>\n<summary>예시코드</summary>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// Parent.vue\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;Hello!&lt;/h2&gt;\n    &lt;Suspense&gt;\n      &lt;AsyncChild /&gt;\n      &lt;template #fallback&gt;\n        Loading...\n      &lt;/template&gt;\n    &lt;/Suspense&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { defineAsyncComponent } from &#39;vue&#39;;\n\nconst AsyncChild = defineAsyncComponent(() =&gt; import(&#39;./AsyncChild.vue&#39;))\n&lt;/script&gt;\n</code>\n        </deckgo-highlight-code>\n</details>\n<h2>로딩 UI 만들기</h2>\n<h3>단순 텍스트 UI</h3>\n<p>이를 토대로 서버로부터 API를 요청하고 응답받기까지 걸리는 시간동안 보여줄 로딩 UI를 구성해보자.\nAPI를 요청하는 <code class=\"language-text\">fetchData</code> 함수에서 로딩시간에 해당하는 3000ms 는 다음과 같이 모킹했다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">const fetchData = async () =&gt; {\n  await new Promise(resolve =&gt; setTimeout(resolve, 3000))\n  list.value = data\n}</code>\n        </deckgo-highlight-code>\n<p>그리고 나는 <code class=\"language-text\">async setup</code> 의 <code class=\"language-text\">Top-level await</code> 를 이용하여 부모 컴포넌트에서 <code class=\"language-text\">&lt;Suspense></code> 안에 집어넣었다.</p>\n<details>\n<summary>AsyncList.vue</summary>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// AsyncList.vue\n&lt;script setup&gt;\nimport {ref} from &#39;vue&#39;\n\nconst data = [\n{id : 0, title: &#39;This is first&#39;},\n {id : 1, title: &#39;This is second&#39;},\n {id : 2, title: &#39;This is third&#39;}]\nconst list = ref(null)\n\nconst fetchData = async() =&gt; {\n  await new Promise(resolve =&gt; setTimeout(resolve,3000))\n  list.value = data;\n}\nawait fetchData();\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;ul&gt;\n      &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;{{item.title}}&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code>\n        </deckgo-highlight-code>\n</details>\n<details>\n<summary>Parent.vue</summary>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// Parent.vue\n&lt;script setup&gt;\nimport { defineAsyncComponent } from &#39;vue&#39;;\n\nconst AsyncComponent = defineAsyncComponent(() =&gt; import(&#39;./AsyncList.vue&#39;))\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;Hello!&lt;/h2&gt;\n    &lt;Suspense&gt;\n      &lt;AsyncComponent /&gt;\n      &lt;template #fallback&gt;\n        Loading...\n      &lt;/template&gt;\n    &lt;/Suspense&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code>\n        </deckgo-highlight-code>\n</details>\n여기까지 구현하고 나서 결과물을 살펴보자.  페이지를 새로고침해보면 3초간 Loading...  텍스트가 표시되다가 데이터가 나오는 걸 확인할 수가 있다.\n<h3>작동영상</h3>\n<p><img src=\"https://github.com/user-attachments/assets/c65b5008-dad7-4c1a-aa33-6a6c52b9d3a2\" alt=\"suspense\"></p>\n<h3>Vue Playground</h3>\n<iframe src=\"https://play.vuejs.org/#eNqFU1Fv0zAQ/itHeGgqlaRsPJWs0oBJgCaYWN8IDya5tF5dO7KdtFOU/87ZabK2K1uUB/u7z77vzvc1wXVZRnWFwSxITKZ5acGgrcp5KvmmVNpCAzkWXOK1eZTZZ0WgRGmhhUKrDYzo7OhjKlOZKWksnLCuzh4OwzFczaFLEI6i2IdvubFOymg8TmUSd2pIB20sbkrBLNIOIMl57Re0XF3Mv6IQ6k0S03IP3lemRGlw7nYAHUr4ibb4NN5ngbcFE+Ivy9b7G913q1jO5TKKooEfH8lywJDZ64w7oUe8YBJYQ60q+DJ6MEpS3xtHToOMhHGB+mdpObUyDWbgIy5GctT2u8esrnDS49kKs/UZ/MHsHJYGdxoN6hrTYIhZppdou/DN/Q/c0XoIblReCWK/EPyFRonKaexonyqZk+wDnlf7zT8udWxhbnaWmtIX5YQ6Zuv5aUAv7t7kf6U/yb2MPvhzqWypi0cj88L0aiwOR/VpUnNmGc3n71Q2PIcZTCdguRU4g9FixQ3QX3Bt7MgL7Tjvn3MM0nX5IeniOcmuuCbOnz63IN2Um7SFshKC5r2PFGiz1ZdOGnMldlbx7WBbxi1I3MId1cMNhvS6StToGFT3gm9QVbZHJ5fT6dR5CXy+qGaiIqovnBxLfewuHFKGY2/kzhOvGBAywYy5cmMrLSOH0wD0NqjE4JtEcKjfFUoTk9MlwKUXkwYwW+PjHo14Tqebxq9979o2iQUffLW/8YyjgvYfHHmRWw==\" style=\"width:100%; height:800px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<h3>스켈레톤 UI</h3>\n<p>단순히 Loading 텍스트만 표시되는 건 심심하니 스켈레톤 UI를 적용하여 사용자에게 컨텐츠가 표시될 영역에 대한 힌트를 제공해주는 것 또한 가능하다.</p>\n<details>\n<summary>Skeleton.vue</summary>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">    // Skeleton.vue\n    &lt;template&gt;\n      &lt;div class=&quot;container&quot;&gt;\n        &lt;ul&gt;\n          &lt;li v-for=&quot;i in 3&quot; :key=&quot;i&quot; class=&quot;item&quot;&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n      &lt;/div&gt;\n    &lt;/template&gt;\n    &lt;style scoped&gt;\n    .container{\n      padding : 10px;\n      border-radius: 10px;\n      width : 100%;\n      background-color: #eaeaea;\n    }\n    ul{\n      display: flex;\n      flex-direction: column;\n      gap : 16px;\n    }\n    li{\n      width : 400px;\n      height: 30px;\n      background-color: #bcbcbc;\n      border-radius: 8px;\n      list-style-type: none;\n      animation: pulse 2s infinite;\n    }\n\n    @keyframes pulse{\n      0%{\n        background-color: #ccc;\n      }\n      50%{\n        background-color: #ddd;\n      }\n      100%{\n        background-color: #ccc;\n      }\n    }\n    &lt;/style&gt;</code>\n        </deckgo-highlight-code>\n</details>\n<h3>작동영상</h3>\n<p><img src=\"https://github.com/user-attachments/assets/2443c7f5-0f52-4493-b824-083586a5ddb6\" alt=\"skeleton\"></p>\n<h3>Vue Playground</h3>\n<iframe src=\"https://play.vuejs.org/#eNqtVdtuEzEQ/ZVhqyqp1FxoC0IhrShQCRCCivaN5cFdzyZuHXtle9NEUf6dsb27uTS9SKDNgz1zPHM8Z8ZZJOdF0Z2WmAySoc2MKBxYdGVxlioxKbRxsACOuVB4bucq+6TJqFA5WEJu9ARadLb1vgFf3aFEp1Xl7PZqg8/RSlWqMq2sg61gpztztNsHcHoGMXSbggX3d2FdiHZwkKphL5ImurRxOCkkc0g7gCEX07Cg5fjo7AtKqV8Ne7SsjFelLVBZPPM7gGgl+xa33ra/zgJ7OZPyhmV3VcQYta5Ar7EOexvEvKHJHZj2ItUNXHKYOEvFysWoe2u1IoEWHpwmGVETEs3PwgkqZpoMIHi8jwjp+2/B5kyJh7U9G2N2t8N+a2feliaXBi2aKaZJ43PMjNBF98XVD5zRunFONC8loZ9w/kKrZek5RtjHUnGivYYLbL8GeYUaXduLmaOi1JfyRD1yGfBpQpp7VR67+orucfcknEvVkqq40TRPtLnBfL2nV73KmWPUob9TtRAcBtA/BCecxAG0rsfCAv1yYaxrBaIR8/ohxiKF4+ugo4cgNxaGMH/q3JJ4U27i1lallNTxtSdHl40/R2rMXzEOSygHu2fCgcJ7uKT7CIttUlfLKXoE3ftaTFCXrrYeHvf7fT9NEPJ1p0yWBA0Xp9GmOsaATcr2AZmruj83gpBJZu2pb1vlGM04NUA9BqVczYgUMO3k2hBSUBAQKpBJExjc4byydgWn04tFWIfaLZfDnhTNXFURd04Uba2bSwQaqwI5WboNp1A2P8ojo6lNO5mW2gxgj6P/6Lbk1Yaj6RjGRWlJ4X4xC/aCcU7d21ioXKUM8biwlHs+gFxixPpFhwuDme/fAVCacqKCa8QK3zdHdQwpQgxfg06g3XHzglpF0asUDoxRjMaOur1JS0p4YLhqeEDWH1/q/P8lj9fmeE0YWtZRvDAU4MWaPKNIVVtfmLrcj8lwL7gbB2B/PwIfqonMf/+s0dstjerUJ/2azJY2O8ncZP7bdad31aHHtWf0arFIryilRTii14P+KhTVP1JL1QdSJzdsgjZiAtX+fvVe7iCUZZENnQZ48xSSc75C+oK/KOhGhybLv7jq1co=\" style=\"width:100%; height:800px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<h2>에러 핸들링</h2>\n<p><code class=\"language-text\">&lt;Suspense></code> 안에서 에러가 발생할 경우 어떻게 에러 핸들링을 해야 하는지도 알아보자.</p>\n<p>위에서 설명한 로딩 UI에서 <code class=\"language-text\">defineAsyncComponent</code> 함수를 사용할 때 인자로 동적 <code class=\"language-text\">import</code> 문을 사용했지만 <code class=\"language-text\">errorComponent</code> 속성 또는 <code class=\"language-text\">onError</code> 속성을 설정하면 에러를 핸들링 하는 것도 가능하다.</p>\n<p>그 밖의 속성들은 공식문서 상에서 아래와 같이 확인할 수 있다.</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">function defineAsyncComponent(\n  source: AsyncComponentLoader | AsyncComponentOptions\n): Component\n\ntype AsyncComponentLoader = () =&gt; Promise&lt;Component&gt;\n\ninterface AsyncComponentOptions {\n  loader: AsyncComponentLoader\n  loadingComponent?: Component\n  errorComponent?: Component\n  delay?: number\n  timeout?: number\n  suspensible?: boolean\n  onError?: (\n    error: Error,\n    retry: () =&gt; void,\n    fail: () =&gt; void,\n    attempts: number\n  ) =&gt; any\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code class=\"language-text\">errorComponent</code> 를 설정하면 에러가 발생했을 때 <code class=\"language-text\">loader</code> 에 넣은 비동기 컴포넌트 대신 다른 컴포넌트를 지정할 수 있다.</li>\n<li><code class=\"language-text\">onError</code> 는 에러가 발생했을 때 호출되는 콜백 함수이다. 인자로 4개를 받게 된다.\n<ul>\n<li><code class=\"language-text\">error</code> : <code class=\"language-text\">Error</code> 객체이다. 에러에 대한 정보를 담고 있다.</li>\n<li><code class=\"language-text\">retry</code> : 요청을 재시도한다.</li>\n<li><code class=\"language-text\">fail</code> : 더이상 <code class=\"language-text\">retry</code> 하지 않고 실패로 간주한다.</li>\n<li><code class=\"language-text\">attempts</code> : 현재까지 시도한 횟수이다.</li>\n</ul>\n</li>\n<li>그래서 아래 예시코드와 같이 최대 3번까지 <code class=\"language-text\">retry</code> 시도 후, 실패처리하는 로직을 작성할 수도 있다.</li>\n</ul>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">onError: (error, retry, fail, attempts) =&gt; {\n  alert(`error, ${attempts} times`)\n  if (attempts &lt; 3) {\n    // 최대 3번까지 재시도\n    retry()\n  } else fail()\n}</code>\n        </deckgo-highlight-code>\n<h3>Vue Playground</h3>\n<iframe src=\"https://play.vuejs.org/#eNqtVs1uI0UQfpXaWVYeS/4jXhAanIgFIgFCsCK5MUjbmamxO2n3jLp7nFiWpT1wQGIlXmDFlQsnJA68EslDUN09PXEcOxsEGsvuqfq66uv6a6+iF1U1WNQYJdFEZ4pXBjSaujpKJZ9XpTKwghwLLvGFXsrss5KEEqWBNRSqnEOH9nY+bsEnFyjQlLJRDoZBYH10WtixUqVqMe6tAaRyOISslNrAlsPDnTziuAuHR+DtxmTMqb/m2jiD3W4q/421VSoBRMlyVJCAt+1kAIrCoiRIvISXRJxrjGOFuhQL7Ck8x8w4NEXvlM+xrAM1r4s77pSdbg8ORqOR5WWNrnv2F63qllvi4+NUpfSxSgBiB+tZImrZg4Jx0QNmDM4rozeZ2gOXAgcOH79qtr23Ctg1GGKoXzUceBEHDUxg3G2sAFAmbv58e/3mNYyv//jp77/e3Pz2Gm5+/f3m57fXv/wYUI5OHM4DKDQ6bnGXysLK7Pc6lWuCTIa+xqi66MX6FMwgvQFMcr5wC1rODo6+QCHKJ5MhLRvhSa0rlBqPvNvgfrKV2OG2PniBpwUT4oxlF41FbzUU7LCVToZ3iFlB69sxHXqqd3BRLzKaAl/w6eBcl5L6ycUxjTKixgWqbyvDKTFplIQ8pRERKi+/cjKjanQZd3tmmF3skJ/rKytLo5dUeagWmEatzjA1RePVxyff4BWtW+W8zGtB6AeU39lari1HD/u0ljnR3sA5tl+6TuNyeqqPrwwFJRzKEnWpdvg0ovazWdl39Fu648HzUCIUxTv9+8BUUlhsjiBbUL7Rc2YYtff3qVzxnPpm1KNyNwIT6JzOuAb6FFxp03FEPeb9+xiNZC7fBB3cB5kZV4T5IfgWxJt8E7dY1kJQxQdNgSabfe6pMXvEjdnCLhk3uwdLMz32TZYGNG4niiUwWDBRo51w5I56kALrPbQcXGuG5nxHT0ImmNaHto6lYTQxqSJCX9TitmkEh0W/KBUhORkBLh2ZNILkApeNdMBz2r1aubUL5no9GQreNlpjcWeL0as2S4FAfVZhTpJBy8nF0fb2VJVUt/2sFKVK4GmO9nGD6KxUNNX7iuW81pTyUXXl5BXLcyrnVkLhqoWzl3NNvpcJFAI91i76OVeUEirohCatqOfSqaassoV0EGwI7u8SikHf0e6bZUW1I2lMuQ0z5NOZofJv3VImLNAd1U2UzcuTWuH/So/NzXgjMbQMVmxiyMCjc/KOjDSxtYEJ4d6Xhkuem5kDjp554P1sIrPPf87Rh1s5Cq6fjwKZrdzsJHOW2WfXmT5qNu3PPaMxxjy9qrYX5gGNE7o7JMXfU0vlJ5SdQjG6qD3GUR09awboDkJZ5tnQboAPHkLmeX6LtAF/lNE7FUrV2f5tuzelH3fNh0vV/9t5sv9qXf8DnjqTFg==\" style=\"width:100%; height:800px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=2-jQ1v6X7vA\">https://www.youtube.com/watch?v=2-jQ1v6X7vA</a></li>\n<li><a href=\"https://ko.vuejs.org/guide/components/async\">https://ko.vuejs.org/guide/components/async</a></li>\n<li><a href=\"https://ko.vuejs.org/guide/built-ins/suspense\">https://ko.vuejs.org/guide/built-ins/suspense</a></li>\n<li><a href=\"https://vuejs.org/api/general.html#defineasynccomponent\">https://vuejs.org/api/general.html#defineasynccomponent</a></li>\n</ul>","frontmatter":{"title":"Vue의 <Suspense> 컴포넌트 파헤치기","date":"2024-12-15","description":"Suspense 컴포넌트 사용법과 에러 핸들링","category":"Vue"}},"previous":{"fields":{"slug":"/vue/241212-v-memo/"},"frontmatter":{"title":"v-memo 개념과 활용법"}},"next":{"fields":{"slug":"/essay/241221-small-ux/"},"frontmatter":{"title":"소소하지만 확실한 UX"}}},"pageContext":{"id":"67db4de0-9068-50c2-aa10-dbbe8686be56","previousPostId":"b5fd72b7-30ca-5ee8-a4a0-1a33cc4aef06","nextPostId":"a9c59211-eec2-55c3-bdf7-1046b09cb558"}},"staticQueryHashes":["2841359383","3821306223"],"slicesMap":{}}