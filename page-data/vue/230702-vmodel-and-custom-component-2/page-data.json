{"componentChunkName":"component---src-templates-blog-post-js","path":"/vue/230702-vmodel-and-custom-component-2/","result":{"data":{"site":{"siteMetadata":{"title":"JuHeon's Dev Blog"}},"markdownRemark":{"id":"63ab404b-a503-57f0-b270-7ffba96de4d8","excerpt":"2023-04-0…","html":"<p><em>2023-04-04에 작성된 <a href=\"https://ps-hjhj97.tistory.com/226\">원문</a>을 수정한 버전입니다</em></p>\n<p><a href=\"https://juheon.dev/vue/230701-vmodel-and-custom-component-1/\">지난 포스팅</a>에서 <code class=\"language-text\">v-model</code>의 작동원리와 커스텀 컴포넌트를 만드는 방법에 대해서 살펴보았다. 이번 포스팅에서는 만들어진 컴포넌트에다 각각의 <code class=\"language-text\">input</code> 특성에 맞는 로직을 구현해보도록 하겠다.</p>\n<h2>기본 구조</h2>\n<p>부모 컴포넌트인 <code class=\"language-text\">MainPage.vue</code>와 전화번호를 위한 <code class=\"language-text\">InputContact.vue</code>, 이메일을 위한 <code class=\"language-text\">InputEmail.vue</code>를 자식 컴포넌트로 구성한다. 자식 컴포넌트는 지난 포스팅에서 다루었던 <code class=\"language-text\">MyInput.vue</code>를 베이스로 작성했다.</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">App.vue\n└── MainPage.vue\n  ├── InputContact.vue\n  └── InputEmail.vue</code>\n        </deckgo-highlight-code>\n<p>연락처와 이메일과 관련된 변수는 당연히 <code class=\"language-text\">MainPage.vue</code>에서만 관리하고, 두 <code class=\"language-text\">Input*.vue</code>에는 <code class=\"language-text\">props</code>로 전달하여 데이터 처리 로직 수행 후, <code class=\"language-text\">emit('update:modelValue')</code>로 가공된 데이터를 넘겨주는 방식이다.</p>\n<h2>전화번호를 위한 input</h2>\n<p>전화번호를 입력하는 <code class=\"language-text\">input</code>을 생각해보자. 우선적으로 필요한 기능은 전화번호 사이마다 '-'를 넣어주는 기능이다. 예를 들어 사용자가 <code class=\"language-text\">01012345678</code>를 입력한다면 <code class=\"language-text\">input</code>은 <code class=\"language-text\">010-1234-5678</code>로 표시되도록 해야한다.</p>\n<p>그래서 일단 전화번호 포맷팅을 수행하는 <code class=\"language-text\">formatContact()</code> 함수에 정규표현식을 사용하려고 한다. 전화번호 포맷팅 관련 정규표현식은 구글링을 해봐도 쉽게 찾을 수 있지만 내가 사용한 정규표현식은 아래와 같다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const formatContact = rawString =&gt; {\n  const formatted = rawString\n    .replace(/[^0-9]/g, &quot;&quot;) // 숫자만 필터링하기\n    .replace(/^(\\d{0,3})(\\d{0,4})(\\d{0,4})$/g, &quot;$1-$2-$3&quot;) // 3,4,4자리로 끊고 -로 구분\n    .replace(/(\\-{1,2})$/g, &quot;&quot;) //아직 숫자 입력되기 전의 -는 가려주기\n  return formatted\n}</code>\n        </deckgo-highlight-code>\n<p>이 <code class=\"language-text\">formatContact</code>함수를 <code class=\"language-text\">@input</code>의 콜백함수에 넣어주고, <code class=\"language-text\">emit</code>함수를 호출할 때도 <code class=\"language-text\">formatted</code>된 값을 부모 컴포넌트(<code class=\"language-text\">MainPage.vue</code>)에 넘겨야한다.</p>\n<h4>InputContact.vue</h4>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">...\n\nconst emit = defineEmits([&quot;update:modelValue&quot;]);\n\nconst onInput = (e) =&gt; {\n  const newValue = e.target.value;\n    const formatted = formatContact(newValue);\n    emit(&quot;update:modelValue&quot;, newValue);\n};\n\nconst formatContact = (rawString) =&gt; {\n  const formatted = rawString\n    .replace(/[^0-9]/g, &quot;&quot;) // 숫자만 필터링하기\n    .replace(/^(\\d{0,3})(\\d{0,4})(\\d{0,4})$/g, &quot;$1-$2-$3&quot;) // 3,4,4자리로 끊고 -로 구분\n    .replace(/(\\-{1,2})$/g, &quot;&quot;); //아직 숫자 입력되기 전의 -는 가려주기\n  return formatted;\n};\n</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">MainPage.vue</code>는 그냥 일반적인 <code class=\"language-text\">&lt;input></code> 태그를 다룰 때처럼만 작성하면 된다. 커스텀 컴포넌트로 변경했다고 한들, 부모 컴포넌트가 데이터 처리 로직에 관여해서 안되고 <code class=\"language-text\">Input*.vue</code>에서 <code class=\"language-text\">emit</code>되는 이벤트에만 의존하고 있어야 한다.</p>\n<h4>MainPage.vue</h4>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;InputContact v-model=&quot;contact&quot; /&gt;\n    &lt;p&gt;contact : {{ contact }}&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from &quot;vue&quot;;\nimport InputContact from &quot;@/components/InputContact.vue&quot;;\n\nconst contact = ref(&quot;&quot;);\n&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n<h4>선택적으로 포맷팅하고 싶다면?</h4>\n<p>위 코드에서는 전화번호가 항상 포맷팅되지만, 상황에 따라서는 포맷팅되지 않는 걸 원할 수도 있다. <code class=\"language-text\">props</code>로 <code class=\"language-text\">useFormat</code> 을 받아서 이 값이 <code class=\"language-text\">true</code>일 때만 포맷팅되도록 할 수도 있다.</p>\n<h4>InputContact.vue</h4>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">const props = defineProps({\n  modelValue: String,\n  useFormat: {\n    type: Boolean,\n    default: true,\n  },\n})\n\nconst emit = defineEmits([&quot;update:modelValue&quot;])\n\nconst onInput = e =&gt; {\n  const newValue = e.target.value\n  if (props.useFormat) {\n    const formatted = formatContact(newValue)\n    emit(&quot;update:modelValue&quot;, formatted)\n  } else {\n    emit(&quot;update:modelValue&quot;, newValue)\n  }\n}\n\nconst formatContact = rawString =&gt; {\n  const formatted = rawString\n    .replace(/[^0-9]/g, &quot;&quot;) // 숫자만 필터링하기\n    .replace(/^(\\d{0,3})(\\d{0,4})(\\d{0,4})$/g, &quot;$1-$2-$3&quot;) // 3자리,4자리,4자리로 끊고 -로 구분하기\n    .replace(/(\\-{1,2})$/g, &quot;&quot;) //아직 숫자 입력되기 전의 -는 가려주기\n  return formatted\n}</code>\n        </deckgo-highlight-code>\n<h4>MainPage.vue</h4>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">  &lt;InputContact :useFormat=&quot;true&quot; v-model=&quot;contact&quot; /&gt;</code>\n        </deckgo-highlight-code>\n<h2>이메일을 위한 input</h2>\n<p>이번에는 이메일을 입력받는 <code class=\"language-text\">InputEmail.vue</code>를 살펴볼텐데, 전화번호와는 다르게 유효성을 검증하는 기능을 하나 추가하려고 한다. 이메일 유효성을 검증하는데에도 역시 구글링해보면 정규표현식이 많이 나오긴 하지만 여기서는 편하게 <code class=\"language-text\">email-validator</code>라는 npm 패키지를 사용했다.</p>\n<p>큰 틀에서는 <code class=\"language-text\">InputContact.vue</code>와 동일하나, <code class=\"language-text\">@input</code> 이벤트마다 유효성 검증을 거친 값을 부모 컴포넌트인 <code class=\"language-text\">MainPage.vue</code>에 <code class=\"language-text\">emit</code>으로 전달해주어야 한다. 따라서 나는 <code class=\"language-text\">emit('is-valid',유효성여부)</code>으로 지정했다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">&lt;template&gt;\n  &lt;input type=&quot;email&quot; :value=&quot;modelValue&quot; @input=&quot;onInput&quot; /&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from &quot;vue&quot;;\nimport * as EmailValidator from &quot;email-validator&quot;;\n\nconst props = defineProps({\n  modelValue: String,\n});\n\nconst emit = defineEmits([&quot;update:modelValue&quot;, &quot;is-valid&quot;]);\n\nconst onInput = (e) =&gt; {\n  const newValue = e.target.value;\n  const isEmailValid = checkEmailValid(newValue);\n  emit(&quot;is-valid&quot;, isEmailValid);\n  emit(&quot;update:modelValue&quot;, newValue);\n};\n\nconst checkEmailValid = (email) =&gt; {\n  return EmailValidator.validate(email);\n};\n&lt;/script&gt;\n</code>\n        </deckgo-highlight-code>\n<p>그러면 <code class=\"language-text\">MainPage.vue</code>에서는 <code class=\"language-text\">emit</code>으로 보낸 값을 <code class=\"language-text\">@is-valid</code>로 받고 콜백함수에서 유효성 여부를 인자로 받을 수 있다. 콜백함수를 위한 별도의 함수를 하나 만들어도 되긴 하는데, 예제 상에서는 만들지 않고 <code class=\"language-text\">isEmailValid</code>라는 변수에 직접 넣어주는 방식을 선택하였다.</p>\n<h4>MainPage.vue</h4>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;InputEmail v-model=&quot;email&quot; @is-valid=&quot;(data) =&gt; (isEmailValid = data)&quot; /&gt;\n    &lt;p&gt;email : {{ email }}&lt;/p&gt;\n    &lt;p&gt;valid : {{ isEmailValid }}&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from &quot;vue&quot;;\nimport InputEmail from &quot;@/components/InputEmail.vue&quot;;\n\nconst email = ref(&quot;&quot;);\n\nconst isEmailValid = ref(null);\n&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n<h2>구현</h2>\n<iframe src=\"https://codesandbox.io/embed/vue-custom-input-2-mcx2wv?fontsize=14&hidenavigation=1&theme=dark\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"vue-custom-input-2\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>","frontmatter":{"title":"v-model 원리와 커스텀 컴포넌트 만들기 (2 of 2)","date":"2023-07-02","description":null}},"previous":{"fields":{"slug":"/vue/230701-vmodel-and-custom-component-1/"},"frontmatter":{"title":"v-model 원리와 커스텀 컴포넌트 만들기 (1 of 2)"}},"next":{"fields":{"slug":"/vue/230703-start-pinia/"},"frontmatter":{"title":"pinia 소개 및 도입 후기"}}},"pageContext":{"id":"63ab404b-a503-57f0-b270-7ffba96de4d8","previousPostId":"79eae8b6-2cbe-538d-9ebd-70ce13b2a65f","nextPostId":"4cfd0013-23d8-5eeb-9570-2cc56fef66cf"}},"staticQueryHashes":["2841359383","3821306223"],"slicesMap":{}}