{"componentChunkName":"component---src-templates-blog-post-js","path":"/vue/230701-vmodel-and-custom-component-1/","result":{"data":{"site":{"siteMetadata":{"title":"JuHeon's Dev Blog"}},"markdownRemark":{"id":"79eae8b6-2cbe-538d-9ebd-70ce13b2a65f","excerpt":"2023-04-0…","html":"<p><em>2023-04-04에 작성된 <a href=\"https://ps-hjhj97.tistory.com/226\">원문</a>을 수정한 버전입니다</em></p>\n<h2>반복되는 <code class=\"language-text\">input</code> 태그</h2>\n<p>사용자에게 입력을 받기 위해서는<code class=\"language-text\">input</code>태그가 필요한데, 입력 받는 데이터의 종류와 특성에 따라 제공되는 기능이 달라질 수 있다. 예를 들어 '오늘의 집'의 주문 페이지를 살펴보자.</p>\n<div align=\"center\" height=\"600\">\n<img src=\"https://raw.githubusercontent.com/hjhj97/blog.gatsby/main/content/blog/vue/230701-vmodel-and-custom-component-1/input-tag-1.png\" height=\"600\">\n</div>\n<!--![](./input-tag-1.png)-->\n<ul>\n<li>\n<p>이름이나 주소같은 단순한 텍스트 : <code class=\"language-text\">&lt;input type=\"text\"></code></p>\n</li>\n<li>\n<p>문자가 아닌 오직 숫자만 입력받을 경우(상품 수량) <code class=\"language-text\">&lt;input type=\"number\"></code></p>\n</li>\n<li>\n<p>전화번호 형식 <code class=\"language-text\">&lt;input type=\"tel\"></code></p>\n</li>\n<li>\n<p>이메일 형식 <code class=\"language-text\">&lt;input type=\"email\"></code></p>\n<p>이처럼 같은 <code class=\"language-text\">input</code>태그라도 각각의 특성과 수행해야 될 기능이 다르다.<br>\n이름이나 주소의 경우에는 빈 문자열이어서는 안된다거나 최소/최대 글자수 제한이 있을 수 있고, 전화번호나 이메일은 유효성 검증을 거쳐야 할 수도 있다.</p>\n<p><code class=\"language-text\">type</code>속성으로으로도 어느정도 해결할 수는 있지만, 이러한 기능을 가진 <code class=\"language-text\">input</code> 태그들이 프로젝트에서 반복적으로 사용된다면 컴포넌트로 분리시켜 공통화하고 싶다는 생각이 든다. 그러면 각 <code class=\"language-text\">&lt;Input></code> 컴포넌트별로 특정 기능에만 집중할 수 있다. 그렇다면 커스텀 컴포넌트화 시키려면 어떻게 해야하는지 살펴볼 건데, 그 전에 <code class=\"language-text\">v-model</code>의 작동원리에 대해서 알아보자.</p>\n</li>\n</ul>\n<h2><code class=\"language-text\">v-model</code>의 작동원리</h2>\n<p>vue의 <code class=\"language-text\">v-model</code>은 양방향 데이터바인딩(two-way binding) 기능을 제공하는 <code class=\"language-text\">directive</code>이다.<br>\n양방향 바인딩이란, 화면상에 보이는 <code class=\"language-text\">&lt;input></code>에 데이터를 입력(수정)할 때마다 <code class=\"language-text\">Javascript</code>에서도 실시간으로 변화를 감지하여 값이 업데이트 되는 기능이다.</p>\n<p>SPA 라이브러리를 vue로 처음 입문한 사람에게는 <code class=\"language-text\">v-model</code>이 왜 편리한 기능인지 이해하기 어려울 수 있지만, react를 접한 뒤에 <code class=\"language-text\">v-model</code>을 만난다면 그 편리함에 감탄할 것이다. 왜냐하면 react에서 양방향 바인딩을 구현하기 위해서는 <code class=\"language-text\">&lt;input></code>태그에 다음와 같이 작성해야만 했다.</p>\n<h4>react</h4>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">const [text, setText] = useState(&quot;&quot;)\nconst onInputChange = e =&gt; {\n  setText(e.target.value)\n}\n...\nreturn &lt;input onChange={onInputChange} value={text} /&gt;</code>\n        </deckgo-highlight-code>\n<p>하지만 이를 vue에서 <code class=\"language-text\">v-model</code>로 구현한다면 간단하게 구현할 수 있다.</p>\n<h4>vue</h4>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// &lt;template&gt;\n&lt;input v-model=&quot;text&quot;&gt;\n// &lt;script setup&gt;\nconst text = ref(&#39;&#39;);</code>\n        </deckgo-highlight-code>\n<p>두 코드 사이에서 주목해야 할 점은 react의 경우에 <code class=\"language-text\">&lt;input></code> 태그에 <code class=\"language-text\">onChange</code>와 <code class=\"language-text\">value</code> 2개가 필요한 반면에, vue에서는 <code class=\"language-text\">v-model</code> 단 하나만 필요하다는 점이다. 단순히 생각해보더라도 <code class=\"language-text\">v-model</code>이 <code class=\"language-text\">onChange</code>와 <code class=\"language-text\">value</code> 2개의 역할을 동시에 수행하고 있으리라 예상할 수 있다.<br>\n사실은 vue도 <code class=\"language-text\">v-model</code>을 사용하지 않고 양방향 바인딩을 구현해보자면 아래와 같이 구현해야 했다.</p>\n<h4>vue</h4>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// &lt;template&gt;\n&lt;input @change=&quot;onChangeInput&quot; :value=&quot;text&quot;&gt;\n// &lt;script setup&gt;\nconst text = ref(&#39;&#39;);\nconst onChangeInput = (e) =&gt; {\n  text.value = e.target.value\n}</code>\n        </deckgo-highlight-code>\n<p>하지만 매번 두 개의 속성을 적어주는 건 성가신 일이기 때문에 이를 하나로 합쳐서 <code class=\"language-text\">v-model</code>이 탄생하게 된 것이다.\nvue에서는 이처럼 tag 레벨에서 자주 쓰이는 기능들은 하나의 공통 함수로 묶게 되었는데 이게 바로 vue의 <code class=\"language-text\">directive</code>이다.</p>\n<blockquote>\n<p>필자 개인의견 : <code class=\"language-text\">v-model</code>이 react와 vue가 추구하는 방향성의 다름을 가장 잘 보여주는 대목이다. react는 코드 뒷편에서 무슨 일이 일어나는지 최대한 개발자에게 숨기지 않고 드러내려는 반면, vue는 '이 기능은 라이브러리에서 책임질테니, 무슨 일이 일어나는 지는 신경쓰지 마'라고 말하는 인상이 들었다.</p>\n</blockquote>\n<h2>커스텀 컴포넌트로 만들기</h2>\n<p><code class=\"language-text\">&lt;input></code>을 컴포넌트화 시켜서 부모-자식간의 관계가 형성되면 부모 컴포넌트에서 자식 컴포넌트로<code class=\"language-text\">v-model</code>를 별도로 연결시켜주어야만 양방향 데이터 바인딩 기능을 유지할 수 있다.</p>\n<p>방법은 어렵지 않다. 부모 컴포넌트 입장에서는 컴포넌트화하기 이전 코드와 동일하게 <code class=\"language-text\">v-model=\"data\"</code>를 걸어주기만 하면 된다. 이렇게만 하면 자식 컴포넌트의 <code class=\"language-text\">props</code>에서 자동으로 <code class=\"language-text\">modelValue</code>라는 (미리 정해진)이름으로 받을 수 있게 된다.</p>\n<p>다만 자식 컴포넌트에서는 별도로 처리해줘야 한다. <code class=\"language-text\">v-model=\"modelValue\"</code>로 받을 수 있을 것 같지만 아쉽게도 불가능하다. 왜냐하면 <code class=\"language-text\">v-model</code>은 <code class=\"language-text\">@input=\"() => modelValue = e.target.value\"</code>가 생략되어있는데, vue에서 자식 컴포넌트가 받은 <code class=\"language-text\">props</code>값(여기서는 <code class=\"language-text\">modelValue</code>)의 직접 변형이 불가능하기 때문이다.</p>\n<p>이를 해결하기 위해서는 자식 컴포넌트에서는 input 이벤트가 발생하면 부모 컴포넌트에게 이를 알려야 한다.<br>\n자식컴포넌트가 부모컴포넌트에게 이벤트를 발생시키고 싶을 때 호출하는<code class=\"language-text\">emit</code>함수를 통해<br>\n<em>\"<code class=\"language-text\">modelValue</code>의 값이 <code class=\"language-text\">e.target.value</code>로 변했다\"</em><br>\n는 정보만 전달하고, 실질적인 변경된 값을 반영하는 과정은 부모 컴포넌트에서 진행되야 한다. 다행히도 그 과정은 이미 <code class=\"language-text\">update:modelValue</code>라는 이벤트로 미리 등록되어 있기 때문에 우리가 직접 구현할 필요는 없다.</p>\n<h4>MainPage.vue (parent)</h4>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;MyInput v-model=&quot;num&quot; /&gt;\n    &lt;p&gt;text : {{ num }}&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from &quot;vue&quot;;\nimport MyInput from &quot;@/components/MyInput.vue&quot;;\n\nconst num = ref(&quot;Hello&quot;);\n&lt;/script&gt;\n\n</code>\n        </deckgo-highlight-code>\n<h4>MyInput.vue (child)</h4>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">&lt;template&gt;\n  &lt;!-- 불가능 --&gt;\n  &lt;!-- &lt;input v-model=&quot;modelValue&quot; /&gt;  --&gt;\n\n  &lt;input :value=&quot;modelValue&quot; @input=&quot;onInput&quot; /&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nconst props = defineProps({\n  modelValue: String,\n});\n\nconst emit = defineEmits([&quot;update:modelValue&quot;]);\n\nconst onInput = (e) =&gt; {\n  const newValue = e.target.value;\n  emit(&quot;update:modelValue&quot;, newValue);\n};\n&lt;/script&gt;\n\n</code>\n        </deckgo-highlight-code>\n<h2>구현</h2>\n<iframe src=\"https://codesandbox.io/embed/vue-custom-input-3tnt3q?fontsize=14&hidenavigation=1&theme=dark\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"vue-custom-input\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>\n<p><em>다음 포스팅에서 'input 종류별로 기능 적용하기'를 소개하겠습니다</em></p>","frontmatter":{"title":"v-model 원리와 커스텀 컴포넌트 만들기 (1 of 2)","date":"2023-07-01","description":"v-model은 어떻게 작동할까?","category":"Vue"}},"previous":{"fields":{"slug":"/vue/230630-vue-named-route/"},"frontmatter":{"title":"react에는 named-route 없나요?(Feat. vue에는 있는데..)"}},"next":{"fields":{"slug":"/vue/230702-vmodel-and-custom-component-2/"},"frontmatter":{"title":"v-model 원리와 커스텀 컴포넌트 만들기 (2 of 2)"}}},"pageContext":{"id":"79eae8b6-2cbe-538d-9ebd-70ce13b2a65f","previousPostId":"feb10932-351b-5e77-ad03-cd875f2263d2","nextPostId":"63ab404b-a503-57f0-b270-7ffba96de4d8"}},"staticQueryHashes":["2841359383","3821306223"],"slicesMap":{}}