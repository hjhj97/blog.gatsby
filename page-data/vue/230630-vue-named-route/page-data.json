{"componentChunkName":"component---src-templates-blog-post-js","path":"/vue/230630-vue-named-route/","result":{"data":{"site":{"siteMetadata":{"title":"하주헌 개발 블로그"}},"markdownRemark":{"id":"feb10932-351b-5e77-ad03-cd875f2263d2","excerpt":"2023-05-05에 작성된 원문을 수정한 버전입니다 vue-router를 사용하는 두 가지 방법 vue…","html":"<p><em>2023-05-05에 작성된 <a href=\"https://ps-hjhj97.tistory.com/229\">원문</a>을 수정한 버전입니다</em></p>\n<h2>vue-router를 사용하는 두 가지 방법</h2>\n<p>vue에서는 <code class=\"language-text\">vue-router</code>에서 제공하는 <code class=\"language-text\">&lt;router-link></code> 컴포넌트로 페이지 이동을 하려면 크게 두 가지 방법이 있는데, 하나는 해당 페이지의 <code class=\"language-text\">pathname</code>을 직접 적는 방법과 다른 하나는 <code class=\"language-text\">router</code>에서 미리 정의해둔 <code class=\"language-text\">route name</code>을 적는 방법이다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// 방법 1\n&lt;router-link to=&quot;/&quot;&gt;홈&lt;/router-link&gt;\n&lt;router-link to=&quot;/about&quot;&gt;어바웃&lt;/router-link&gt;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// 방법 2\n&lt;router-link :to=&quot;{name : &#39;Home&#39;}&quot;&gt;홈&lt;/router-link&gt;\n&lt;router-link :to=&quot;{name : &#39;About&#39;}&quot;&gt;어바웃&lt;/router-link&gt;\n\n// 그리고 vue-router에서 미리 route별로 name을 지정해주어야 한다\nconst routes = [\n\t{\n\t\tpath: &#39;/&#39;,\n\t\tname: &#39;Home&#39;,\n\t\tcomponent: ...,\n\t},\n\t{\n\t\tpath: &#39;/about&#39;,\n\t\tname: &#39;About&#39;,\n\t\tcomponent: ...,\n\t},\n]</code>\n        </deckgo-highlight-code>\n<h2>하지만 오타가 난다면?</h2>\n<p>나는 개발할 때 주로 방법 2를 선호하는데 그 이유는 방법 1의 경우에는 경로명을 잘못 입력하더라도 에러로 검출해내지 못하고 클릭하면 <code class=\"language-text\">/abou</code>페이지로 이동시켜버리는 반면에, 방법 2는 아래와 같이 개발자 도구의 콘솔창에서 에러를 띄워주기 때문이다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// 방법 1\n&lt;router-link to=&quot;/&quot;&gt;홈&lt;/router-link&gt;\n&lt;router-link to=&quot;/abou&quot;&gt;어바웃&lt;/router-link&gt; // 오타, 에러 발생X</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// 방법 2\n&lt;router-link :to=&quot;{name : &#39;Home&#39;}&quot;&gt;홈&lt;/router-link&gt;\n&lt;router-link :to=&quot;{name : &#39;Abou&#39;}&quot;&gt;어바웃&lt;/router-link&gt; // 오타, 에러 발생함</code>\n        </deckgo-highlight-code>\n<p><img src=\"https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983320/blog/assets/named-route-error_gzcpws.png\" alt=\"\"></p>\n<p>방법 1은 오타가 발생하더라도 해당 라우터를 클릭해서 404 페이지가 뜨는 걸 확인하기 전까지는 찾기가 어렵다. 왜냐하면 사용자가 오타를 낸 건지, 아니면 정말로 <code class=\"language-text\">/abou</code>페이지로 이동하길 원하는지 라우터에게는 알 수 있는 정보가 없기 때문이다.</p>\n<p>반면에 방법 2에서는 라우터를 클릭하기 전에도 콘솔창에서 에러를 검출할 수 있다. <code class=\"language-text\">routes</code>에 들어있는 원소를 하나씩 뒤져보면서 name이 <code class=\"language-text\">Abou</code>와 일치하는 라우트를 찾아본다. 일치하는 라우트가 없으면 에러로 판별해낼 수 있는 단서가 제공된다는 뜻이다.</p>\n<p>이런 식으로 vue 에서는 <code class=\"language-text\">named-route</code>기반으로 페이지 이동이 가능하기 때문에 예상치 못한 오타 발생시 에러로 검출할 수 있는 반면에 react에서 <code class=\"language-text\">&lt;Link to={'/about'}</code> 또는 <code class=\"language-text\">useNavigate</code>훅의 <code class=\"language-text\">navigate('/about')</code>와 같이 <code class=\"language-text\">pathname</code> 기반으로만 이동할 수 있다.</p>\n<p>따라서 위의 언급한 방법 1처럼 오타로 인한 route 이동을 막을 수 있는 방법은 아직까지는 찾지 못하였다. 타입스크립트로 <code class=\"language-text\">pathname</code>을 <code class=\"language-text\">enum</code>이나 <code class=\"language-text\">type</code>으로 변수화시키는 방법이라면 가능할 지도 모르겠다는 생각은 드는데, 실무에서도 그렇게 개발할 지는 모르겠다.</p>\n<hr>\n<h2>현재 페이지 판별</h2>\n<p>위 주제와 비슷한 궁금증.</p>\n<p>리액트에서는 현재 접속해있는 페이지를 판별하는 방법에 대해서이다.\n예를 들어 현재 접속한 페이지와 일치하면 class에 <code class=\"language-text\">isMatched</code>를 붙여서 하이라이트 스타일을 주는 상황을 생각해보자.\nvue로 구현한다면 아래와 같다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">  &lt;router-link :to={name : &quot;Home&quot;} class=&quot;{ matched : $route.name === &#39;Home&#39;}&quot;&gt;\n    Home\n  &lt;/router-link&gt;\n  &lt;router-link :to={name : &quot;About&quot;} class=&quot;{ matched : $route.name === &#39;About&#39;}&quot;&gt;\n    About\n  &lt;/router-link&gt;</code>\n        </deckgo-highlight-code>\n<p>사실상 스크립트 코드를 하나도 작성하지 않고 template 레벨에서만 현재 라우트 일치 여부를 판별해낼 수 있다.</p>\n<p>이걸 react 로 작성해본다면</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">function Header() {\n  const { pathname: currentPath } = useLocation()\n  const isMatch = (path: string) =&gt; {\n    if (currentPath === path) return &quot;matched&quot;\n  }\n  return (\n    &lt;Nav&gt;\n      &lt;Link to=&quot;/&quot; className={currentPath === &quot;/&quot; ? &quot;matched&quot; : &quot;&quot;}&gt;\n        Home\n      &lt;/Link&gt;\n      &lt;Link to=&quot;/about&quot; className={isMatch(&quot;/about&quot;)}&gt;\n        About\n      &lt;/Link&gt;\n    &lt;/Nav&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<p>우선 <code class=\"language-text\">useLocation</code>훅을 통해서 현재의 <code class=\"language-text\">pathname</code>을 한번 뽑아와야하며, <code class=\"language-text\">&lt;Link></code>에서도 클래스를 동적으로 바인딩 할 때도 삼항연산자로 판별하거나, 코드를 줄이려면 <code class=\"language-text\">isMatch</code>함수를 하나 선언해서 인자로 현재 <code class=\"language-text\">&lt;Link></code>의 <code class=\"language-text\">To</code> 값을 그대로 넣어줘야 한다(물론 이건 vue도 마찬가지다).</p>\n<p>vue는 template 레벨에서 <code class=\"language-text\">$route.name</code> 으로 현재 라우트 정보를 한방에 가져올 수 있고, class-binding을 할 때에도 <code class=\"language-text\">:class={isMatched : someValue}</code> 에서 <code class=\"language-text\">someValue</code>값이 true면 곧바로 클래스 이름으로 붙일 수 있어 편리하다.</p>\n<p>vue는 <code class=\"language-text\">너한테-이런게-필요할거-같았어</code> 기능(함수)들이 미리 제공되어있는 반면에 react는 <code class=\"language-text\">너가-직접-구현하렴</code>같은 느낌이다.<br>\nreact는 기능에 대한 부품들만 던져준다면, vue는 그 부품으로 조립까지 해주는 느낌이랄까? 각 라이브러리가 추구하는 방향성의 차이를 알 수 있는 대목이다.</p>\n<p>각자 장단점이 있겠지만, 나 같이 vue를 먼저 익히고 난 뒤에 react에서는 그 기능을 어떻게 구현해야 하는지 찾아보는 입장에서는 조금 답답함이 느껴지는 것도 사실이다.</p>","frontmatter":{"title":"react에는 named-route 없나요?(Feat. vue에는 있는데..)","date":"2023-06-30","keywords":null,"description":null,"category":"Vue"}},"previous":{"fields":{"slug":"/vue/230629-vue-router-state/"},"frontmatter":{"title":"vue-router를 통한 페이지간 state 전달"}},"next":{"fields":{"slug":"/vue/230701-vmodel-and-custom-component-1/"},"frontmatter":{"title":"v-model 원리와 커스텀 컴포넌트 만들기 (1 of 2)"}}},"pageContext":{"id":"feb10932-351b-5e77-ad03-cd875f2263d2","previousPostId":"20c40df6-8265-5029-848d-0d48661ab441","nextPostId":"79eae8b6-2cbe-538d-9ebd-70ce13b2a65f"}},"staticQueryHashes":["2841359383","3821306223"],"slicesMap":{}}