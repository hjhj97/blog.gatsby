{"componentChunkName":"component---src-templates-blog-post-js","path":"/vue/230803-vue-modal-close/","result":{"data":{"site":{"siteMetadata":{"title":"하주헌 개발 블로그"}},"markdownRemark":{"id":"364a4960-e35f-5b0d-812b-b8d8f1dbd925","excerpt":"2023-03-0…","html":"<p><em>2023-03-09에 작성된 <a href=\"https://ps-hjhj97.tistory.com/222\">원문</a>을 수정한 버전입니다</em></p>\n<h2>모달 닫기</h2>\n<p>모바일 환경에서 모달창이 떠 있는 상태에서 모달을 닫는 방법은 여러가지가 있을 수 있다.</p>\n<p>첫 번째 방법은 모달 창 내부에 별도의 <code class=\"language-text\">X</code>버튼을 표시해서 이 영역을 터치하면 닫히게 하는 방법이 있다. 가장 직관적인 방법이지만 버튼을 위한 별도의 공간을 확보해야 하기 때문에 디자인상 의도치 않은 공간을 차지한다는 단점이 있다.</p>\n<p>이런 단점을 해결하기 위한 두 번째 방법은 모달 바깥의 영역을 터치를 감지했을 때 모달을 닫는 방법이 있다. 다만 이 방법 역시 명시적인 '닫기'버튼이 보이지 않기 때문에 이러한 UI/UX가 낯선 사용자에게는 모달을 어떻게 닫아야 하는지 헤맬 수도 있다는 단점이 있다.</p>\n<p>세 번째 방법은 (안드로이드 환경에서) 뒤로가기 버튼을 눌렀을 때 모달이 닫히게 하는 방법이다. 이 방법의 경우, 모달창과 직접적인 상호작용이 일어나지 않으므로 개발자 입장에서는 뒤로가기 이벤트를 감지해야 하는 등 꽤나 까다로운 작업이다. 이번 글에서는 그 방법에 대해서 설명하겠다.</p>\n<h2>뒤로가기</h2>\n<p>'뒤로가기'를 눌렀을 때 모달창이 닫히게 만들기 위해서는, 모달창이 열려있는 상태를 <code class=\"language-text\">window</code>객체의 <code class=\"language-text\">history</code>에 저장(push)해야 한다. 이때 사용하는 함수가 <code class=\"language-text\">window.history.pushState()</code>함수이다. 이 함수에 대한 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History/pushState\">자세한 설명</a>은 MDN을 참고하기 바란다.</p>\n<p><code class=\"language-text\">pushState()</code>함수의 첫 번째 인자로는 <code class=\"language-text\">state</code>를 전달해야 하는데, 정해진 양식이 있는 것이 아니라 개발자가 식별할 수 있는 정보를 담아서 객체 형태로 넘기기만 하면 된다. 나는 <code class=\"language-text\">{state : 'modal'}</code> 객체를 넣었다. 두 번째 인자는 아무 의미는 없지만 생략할 수는 없으므로 빈 문자열이나 <code class=\"language-text\">undefined</code>를 넣으면 된다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;p&gt;Hello World&lt;/p&gt;\n    &lt;button @click=&quot;openModal&quot;&gt;open&lt;/button&gt;\n\n    &lt;!-- Modal --&gt;\n    &lt;teleport to=&quot;#modal&quot; v-if=&quot;isModalOpen&quot;&gt;\n      &lt;Modal @close-modal=&quot;closeModal&quot; /&gt;\n    &lt;/teleport&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n  const isModalOpen = ref(false);\n\n  const openModal = () =&gt; {\n    isModalOpen.value = true;\n  };\n  const closeModal = () =&gt; {\n    isModalOpen.value = false;\n  };\n&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n<p>이전 포스팅에서 <code class=\"language-text\">&lt;teleport></code>안의 코드는 <code class=\"language-text\">Modal.vue</code>라는 별도의 컴포넌트로 분리해두었다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// Modal.vue\n&lt;template&gt;\n  &lt;div class=&quot;modal&quot;&gt;\n    &lt;div class=&quot;modal-content&quot;&gt;\n      &lt;p&gt;This is Modal&lt;/p&gt;\n      &lt;button @click=&quot;closeModal&quot;&gt;X&lt;/button&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script setup&gt;\n  const emit = defineEmits([&#39;close-modal&#39;]);\n  onMounted(() =&gt; {\n    window.history.pushState({ state: &#39;modal&#39; }, undefined);\n  });\n  const closeModal = () =&gt; {\n    emit(&#39;close-modal&#39;);\n  };\n&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n<br />\n<p>이제 버튼을 누르면 모달이 열리면서 <code class=\"language-text\">history</code>에 <code class=\"language-text\">{state:'modal'}</code>이 추가됨을 확인할 수 있다. 하지만 여기서 뒤로가기를 누르더라도 모달이 닫히지는 않는다. 왜냐하면 <code class=\"language-text\">isModalOpen</code>값은 여전히 <code class=\"language-text\">true</code>이기 때문이다. 따라서 '뒤로가기'가 실행되면 <code class=\"language-text\">closeModal</code>함수가 실행되게끔 만들어야 한다.</p>\n<h2>popstate</h2>\n<p>자바스크립트에서 뒤로가기 이벤트를 감지하려면 <code class=\"language-text\">popstate</code>라는 함수를 이벤트리스너에 등록해야 한다. 따라서 <code class=\"language-text\">onMounted</code>함수에 아래와 같이 추가한다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">onMounted(() =&gt; {\n  window.history.pushState({ state: &quot;modal&quot; }, undefined)\n  window.addEventListener(&quot;popstate&quot;, closeModal)\n})</code>\n        </deckgo-highlight-code>\n<p>이제 '뒤로가기'를 누르면 모달창도 닫힌고, <code class=\"language-text\">history</code>도 다시 <code class=\"language-text\">pop</code>된다.</p>\n<p><strong>하지만 아직 한 가지 문제점이 남아있다.</strong> '뒤로가기'를 누르지 않고 그냥 <code class=\"language-text\">X</code>버튼을 눌러서 닫게 되면 모달을 닫히지만, <code class=\"language-text\">history</code>가 <code class=\"language-text\">pop</code>되지 못하고 쌓여있게 된다. 즉 모달은 닫혀 있지만 <code class=\"language-text\">window.history</code>를 찍어보면 <code class=\"language-text\">{state:'modal'}</code>인 상태로 남아있다는 것이다.</p>\n<p>즉 모달이 닫힐 때 '뒤로가기'를 눌러서 닫힌 건지,<code class=\"language-text\">X</code>버튼을 눌러서 닫힌 건지 구분해주어야 한다. 따라서 <code class=\"language-text\">closeModal</code>함수의 인자로 뒤로가기가 눌렸는지를 확인하는 인자를 받도록 수정한다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">const closeModal = (isBackward = false) =&gt; {\n  if (!isBackward) {\n    history.back()\n  }\n  emit(&quot;close-modal&quot;)\n}</code>\n        </deckgo-highlight-code>\n<p>버튼을 눌러서 닫았다면 <code class=\"language-text\">isBackward</code>값이 <code class=\"language-text\">false</code>로 들어오고 <code class=\"language-text\">history.back()</code>를 호출하여 상태를 한단계 <code class=\"language-text\">pop</code>해주면 된다. 작동하는 모습은 아래와 같다.</p>\n<p><img src=\"https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737988551/blog/assets/vue-modal-backward_ibefok.gif\" alt=\"\"></p>\n<p>완성된 <code class=\"language-text\">Modal.vue</code>코드는 아래와 같다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// Modal.vue\n&lt;template&gt;\n  &lt;div class=&quot;modal&quot;&gt;\n    &lt;div class=&quot;modal-content&quot;&gt;\n      &lt;p&gt;This is Modal&lt;/p&gt;\n      &lt;button @click=&quot;closeModal(false)&quot;&gt;X&lt;/button&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n  const emit = defineEmits([&#39;close-modal&#39;]);\n\n  onMounted(() =&gt; {\n    window.history.pushState({ state: &#39;modal&#39; }, undefined);\n    window.addEventListener(&#39;popstate&#39;, () =&gt; closeModal(true));\n  });\n  onUnmounted(() =&gt; {\n    window.removeEventListener(&#39;popstate&#39;, () =&gt; closeModal(true));\n  });\n  const closeModal = (isBackward = false) =&gt; {\n    if (!isBackward) {\n      history.back();\n    }\n    emit(&#39;close-modal&#39;);\n  };\n&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n<h2>생각</h2>\n<p>사실 웹뷰 환경에서 모달창이 열려있는 상태를 굳이 '뒤로가기'를 통해서 닫히게 동작해야 할까에 대해 고민이 많았다. 웹뷰는 웹만의 고유한 동작 방식이 있기 때문에 네이티브 앱을 흉내내는 일에 대해서는 회의적이었다. 하지만 개발자가 아닌 일반 사용자 입장에서는 자신이 사용하는 앱이 웹 기반인지 네이티브 기반인지는 별 관심은 없을 것이고, 개인마다 여러 앱을 사용해오면서 축적되어온 경험('뒤로가기'하면 모달이 닫힘)이 그대로 적용되리라는 기대를 할 것이다.</p>\n<p>그래서 이번 개발을 계기로 유명하다싶은 앱은 모두 다운받아서 과연 '모달창이 뒤로가기로 닫히는가'를 시험해보았다(족히 30개의 앱으로 확인해보았다). 대략 90%의 앱이 네이티브 기반이었고, 이 앱들은 전부 다 뒤로가기를 통해 모달이 닫힘을 확인하였다. 나머지 10%의 웹뷰 기반 앱은 반반이었다. 어떤 앱은 뒤로가기를 누르면 모달이 닫힘과 함께 아예 이전 페이지로 이동해버리는 문제가 있었고, 이 경우의 사용자 예상과 다른 결과로 인하여 사용성이 떨어진다는 인상을 받았다.</p>\n<p>그래서 내가 내린 결론은 웹뷰는 사용자의 경험을 해치지 않는 선에서는 네이티브처럼 동작하게끔 최소한의 기대되는 동작은 구현해줘야 한다는 것이다.</p>","frontmatter":{"title":"모바일 환경에서 모달 닫기","date":"2023-08-03","keywords":null,"description":"(Feat. 뒤로가기와의 싸움)","category":"Vue"}},"previous":{"fields":{"slug":"/vue/230802-vue-modal-open/"},"frontmatter":{"title":"vue로 모달 구현하기"}},"next":{"fields":{"slug":"/essay/230812-why-i-become-developer/"},"frontmatter":{"title":"개발자가 된 이유"}}},"pageContext":{"id":"364a4960-e35f-5b0d-812b-b8d8f1dbd925","previousPostId":"72144528-65d0-5ed1-9b85-2088bb4a7aaa","nextPostId":"08e00d41-2a47-59ae-92ca-2af0cb006bbc"}},"staticQueryHashes":["2841359383","3821306223"],"slicesMap":{}}