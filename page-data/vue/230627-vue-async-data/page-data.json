{"componentChunkName":"component---src-templates-blog-post-js","path":"/vue/230627-vue-async-data/","result":{"data":{"site":{"siteMetadata":{"title":"하주헌 개발 블로그"}},"markdownRemark":{"id":"e4ac637f-ae01-51f1-9954-817f6580ddfd","excerpt":"2023-03-09에 작성된 원문을 수정한 버전입니다 문제상황 vue3 환경에서 chart.js 라이브러리를 사용하여 차트 데이터를 화면에 그리려고 한다. 그냥 바닐라 JS를 활용할 수도 있겠지만, 더 편리한 방법으로는 vue 기반으로 래핑해놓은 vue-chart-…","html":"<p><em>2023-03-09에 작성된 <a href=\"https://ps-hjhj97.tistory.com/221\">원문</a>을 수정한 버전입니다</em></p>\n<h2>문제상황</h2>\n<p>vue3 환경에서 chart.js 라이브러리를 사용하여 차트 데이터를 화면에 그리려고 한다. 그냥 바닐라 JS를 활용할 수도 있겠지만, 더 편리한 방법으로는 vue 기반으로 래핑해놓은 <a href=\"https://vue-chart-3.netlify.app/\">vue-chart-3</a>를 활용하려고 한다. 그래서 공식문서 <a href=\"https://codesandbox.io/s/demo-vue-chart-3-ugynm?from-embed=&#x26;file=/src/App.vue\">데모 페이지</a>에 나와있는 대로 따라하려고 하니 문제가 하나 생겼다.</p>\n<p>내가 화면에 보여줄 데이터는 서버와 비동기 통신을 통해서 받아온 다음에 그려야 한다. 그런데 데모 소스코드 상에서는 데이터가 아래와 같이 그냥 하드코딩 되어 있었다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">    // &lt;template&gt;\n    &lt;DoughnutChart :chartData=&quot;testData&quot; /&gt;\n    ...\n\n    // &lt;script&gt;\n    const dataValues = ref([30, 40, 60, 70, 5]);\n    const dataLabels = ref([&quot;Paris&quot;, &quot;Nîmes&quot;, &quot;Toulon&quot;, &quot;Perpignan&quot;, &quot;Autre&quot;]);\n    const testData =  {\n      labels: dataLabels.value,\n      datasets: [\n        {\n          data: dataValues.value,\n        },\n      ],\n    };</code>\n        </deckgo-highlight-code>\n<p>실제 chart.js를 활용하는 사례에서는 데이터를 하드코딩해서 넣는 경우보단, 비동기로 넣는 경우가 더 일반적이다. 하지만 chart.js는 차트를 그리는 데 필요한 데이터를 받으면 곧바로 <code class=\"language-text\">&lt;canvas></code>로 그려버리기 때문에, 그 이후에는 비동기로 데이터가 도착한다고 한들 차트가 변하지 않는다는 문제가 있다.</p>\n<p>예를 들어 아래 코드와 같이 비동기 통신을 가장한 <code class=\"language-text\">fetchData</code>함수가 <code class=\"language-text\">onMounted</code>에서 실행된다 하더라도 차트는 그려지지 않는다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const dataValues = ref([])\nconst dataLabels = ref([])\n\nonMounted(() =&gt; {\n  fetchData().then(res =&gt; {\n    dataValues.value = res.map(item =&gt; item.data)\n    dataLabels.value = res.map(item =&gt; item.label)\n  })\n})\n\nconst testData = {\n  labels: dataLabels.value,\n  datasets: [\n    {\n      data: dataValues.value,\n    },\n  ],\n}\n\nconst fetchData = () =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      resolve([\n        { data: 10, label: &quot;a&quot; },\n        { data: 30, label: &quot;b&quot; },\n        { data: 15, label: &quot;c&quot; },\n        { data: 5, label: &quot;d&quot; },\n        { data: 20, label: &quot;e&quot; },\n      ])\n    }, 1000)\n  })\n}</code>\n        </deckgo-highlight-code>\n<h2>해결방법</h2>\n<p>이를 해결하기 위해서는 차트의 props에 해당하는 <code class=\"language-text\">testData</code>에 반응성을 주입시켜야 한다. 그러면 <code class=\"language-text\">fetchData</code>에서 1초 뒤에 값을 받아오고 나서 <code class=\"language-text\">testData</code>도 받아온 값으로 업데이트된다.<br>\n<code class=\"language-text\">testData</code>에 반응성을 부여하려면 <code class=\"language-text\">computed</code> 를 사용하여 감싸주면 된다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// Before\nconst testData = {\n  labels: dataLabels.value,\n  datasets: [\n    {\n      data: dataValues.value,\n    },\n  ],\n}\n\n// After\nconst testData = computed(() =&gt; {\n  return {\n    labels: dataLabels.value,\n    datasets: [\n      {\n        data: dataValues.value,\n      },\n    ],\n  }\n})</code>\n        </deckgo-highlight-code>\n<h2>구현</h2>\n<iframe src=\"https://codesandbox.io/embed/vue-chart-3nbvlh?fontsize=14&hidenavigation=1&theme=dark\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"vue-chart\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>","frontmatter":{"title":"vue-chart에서 비동기 통신 후 화면에 반영하기","date":"2023-06-27","description":"서버 통신 후에 화면을 리렌더링 하는 방법","category":"Vue"}},"previous":{"fields":{"slug":"/vue/230626-save-scroll/"},"frontmatter":{"title":"Vue 에서 스크롤 위치 저장"}},"next":{"fields":{"slug":"/vue/230628-router-view-find-dom/"},"frontmatter":{"title":"router-view 에서 DOM을 찾지 못하는 문제"}}},"pageContext":{"id":"e4ac637f-ae01-51f1-9954-817f6580ddfd","previousPostId":"ec29ee4e-5c9c-50be-814e-8a5bea038212","nextPostId":"bf102f9b-cad5-5dd1-94fa-b407aa4b7b42"}},"staticQueryHashes":["2841359383","3821306223"],"slicesMap":{}}