{"componentChunkName":"component---src-templates-blog-post-js","path":"/vue/230624-vue-roulette/","result":{"data":{"site":{"siteMetadata":{"title":"하주헌 개발 블로그"}},"markdownRemark":{"id":"a8c9c6f4-7f2d-5123-959f-2309b211bde7","excerpt":"2022-11-1…","html":"<p><em>2022-11-12 에 작성된 <a href=\"https://ps-hjhj97.tistory.com/214\">원문</a>을 수정한 버전입니다</em></p>\n<h2>룰렛 이벤트</h2>\n<p>다들 온라인이나 오프라인에서 룰렛(회전판)을 돌려서 나온 상품을 추첨받는 경험 한 번씩 있을 것이다. 현실에서의 룰렛은 공평한 물리법칙에 내 운명을 맡기면 되지만, 웹페이지(프론트엔드)상에서 구현할 때는 룰렛을 어떻게 돌아가게 만들고 어떤 영역을 가리키도록 해야할까? 마침 진행 중인 프로젝트에서 룰렛을 구현해야 했는데 구글링이나 오픈소스에는 내가 원하는 기능이 없어서 직접 구현하게 되었다.</p>\n<h4>요구조건</h4>\n<ol>\n<li>\n<p>사용자가 버튼을 누르면 백엔드 API가 호출되고 리턴값으로 당첨영역을 받는다. 이 영역의 위치에 따라 회전 각도를 조절해야한다.</p>\n</li>\n<li>\n<p>현실에서 룰렛이 회전하는 것처럼, 처음에는 천천히 돌다가 점점 가속도가 붙어서 빨라지고 마지막에는 느려지다 멈춘다.</p>\n</li>\n</ol>\n<h4>구현 방식</h4>\n<p>가장 쉽게 생각해볼 수 있는 방법은 css animation을 활용하여 rotate시키는 방법이다.\n아래와 같이 <code class=\"language-text\">spin</code>이라는 keyframs를 정의하고 <code class=\"language-text\">rotate(360deg)</code>를 부여하면 한 element를 한바퀴 돌릴 수 있다.</p>\n<deckgo-highlight-code language=\"css\"  >\n          <code slot=\"code\">/* roulette.css */\n.roulette_content {\n  animation-name: spin;\n  @keyframes spin {\n    from {\n      transform: rotate(0deg);\n    }\n    to {\n      transform: rotate(360deg);\n    }\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>하지만 <strong>요구조건 1</strong>에서 언급했다시피 당첨영역, 즉 회전 각도는 고정된 값이 아니라 서버에서 리턴받는 값에 따라서 동적으로 변해야 한다. 그래서 나는 <code class=\"language-text\">js</code>단에서 css keyframes에 접근하여 rotate각도를 직접 수정할 수 있는지를 찾아보았다. 예를 들어 DOM element의 <code class=\"language-text\">backgroundColor</code>나 <code class=\"language-text\">fontSize</code>는 <code class=\"language-text\">querySelector()</code>함수를 이용해 접근할 수 있는 것처럼 animation도 그런 작업이 가능한 지 궁금했다.</p>\n<p>결론부터 얘기하자면, 가능은 하지만 방법이 너무 복잡했다.<a href=\"https://stackoverflow.com/questions/59573722/how-can-i-set-a-css-keyframes-in-javascript\">(링크)</a><br>\n<code class=\"language-text\">insertRule()</code>함수를 이용해서 넣는 방식이었는데 keyframe부분을 직접 문자열로 하드코딩해야하기 때문에 너무 억지인 것 같아서 다른 방법을 찾아보기로 하였다.</p>\n<h4>css var()를 활용한 방식</h4>\n<p>다른 방법으로 생각해낸 건 아래와 같이 css의 var()를 활용해서 :root에서 선언해놓은 변수 값을 keyframes에서 갖다 쓰는 방식이다. root 영역의 값은 <code class=\"language-text\">js</code>단에서 <code class=\"language-text\">setProperty()</code>함수를 활용해서 조작할 수 있기 때문에 이 방식이 더 낫다고 판단하였다.</p>\n<deckgo-highlight-code language=\"css\"  >\n          <code slot=\"code\">/*roulette.css*/\n.roulette_content {\n  animation-name: spin;\n  @keyframes spin {\n    from {\n      transform: rotate(0deg);\n    }\n    to {\n      transform: rotate(var(--roulette-angle));\n    }\n  }\n}</code>\n        </deckgo-highlight-code>\n<h4>룰렛의 파라미터</h4>\n<p>룰렛을 돌리기 전에 결정되어야 할 파라미터가 몇 가지가 있다.</p>\n<ol>\n<li>룰렛을 최소 몇 바퀴 돌릴 것인지</li>\n<li>룰렛을 몇 초 동안 돌릴 것인지</li>\n<li>룰렛 안에 채워져 있는 컨텐츠</li>\n</ol>\n<p>이 3가지가 채워지고나면 룰렛을 돌릴 수 있게 된다.</p>\n<p>원리는 간단하다. 룰렛의 중심각이 360도이다. 따라서 <code class=\"language-text\">360/(영역의 개수)</code> 를 계산하면 룰렛의 각 영역당 중심각의 크기<code class=\"language-text\">(=degPerSection)</code>를 구할 수 있다.<br>\n그리고 당첨된 영역<code class=\"language-text\">(=pick)</code>이 (반시계방향 기준)몇 번째인지 구하여 <code class=\"language-text\">degPerSection * pick</code> 값이 룰렛을 회전시켜야하는 각도 값<code class=\"language-text\">(=rouletteAngle)</code>이 된다.\n이 값을 root에 <code class=\"language-text\">--roulette-angle</code>로 저장시키면 <code class=\"language-text\">var()</code>함수를 이용하여 keyframes에서도 이 값을 가져다 쓸 수 있는 방식이다.</p>\n<p>그래서 <code class=\"language-text\">startRoulette()</code>함수를 실행시키면 <code class=\"language-text\">rouletteAngle</code>값이 정해지고 이 값은 다시 :root의 <code class=\"language-text\">roulette-angle</code>으로 채워져서 spin animation이 작동하게 된다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">const useRoulette = () =&gt; {\n  const POINT_ARRAY = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]\n  // 룰렛의 내용, 12시 방향부터 반시계방향\n  const MIN_ROTATION = 3\n  // 룰렛을 최소 몇 바퀴 돌릴 것인지\n  const ROTATION_SECOND = 2\n  // 몇 초동안 돌릴 것인지\n\n  const numberOfSection = POINT_ARRAY.length\n  // 룰렛에 적힌 영역의 개수\n  const degPerSection = 360 / numberOfSection\n  // 하나의 섹션당 각도가 몇 도인지 계산함.\n  let pickedSection\n  // 당첨된 영역\n\n  const setRouletteProperty = () =&gt; {\n    const pick = Math.floor(Math.random() * numberOfSection)\n    // [0, section - 1]범위에 랜덤한 인덱스를 뽑음, 서버에서 영역을 정해준다면 필요없음\n    pickedSection = POINT_ARRAY[pick]\n    // 당첨된 영역 값 대입\n    const rouletteAngle = 360 * MIN_ROTATION + degPerSection * pick\n    // 최소 MIN_ROTATION만큼은 돌고난 후에, pick 영역을 가르키도록 함\n\n    document.documentElement.style.setProperty(\n      &quot;--roulette-angle&quot;,\n      rouletteAngle + &quot;deg&quot;\n    )\n    //css의 root에 선언해놓은 변수에 값 할당함.\n\n    const rouletteEl = document.querySelector(&quot;.roulette_content&quot;)\n    rouletteEl.style.animationDuration = `${ROTATION_SECOND * 1000}ms`\n    // 애니메이션(룰렛회전) 지속시간 적용\n  }\n\n  const startRoulette = () =&gt; {\n    setRouletteProperty()\n\n    const toId = setTimeout(() =&gt; {\n      alert(pickedSection)\n      clearTimeout(toId)\n    }, ROTATION_SECOND * 1000)\n  }\n  return {\n    startRoulette,\n  }\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"css\"  >\n          <code slot=\"code\">/* roulette.css */\n.roulette_content {\n  animation-name: spin;\n  animation-timing-function: ease-in-out;\n  animation-fill-mode: forwards;\n}\n\n@keyframes spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(var(--roulette-angle));\n  }\n}</code>\n        </deckgo-highlight-code>\n<h2>구현</h2>\n<iframe src=\"https://codesandbox.io/embed/vue3-roulette-cu4617?fontsize=14&hidenavigation=1&theme=dark\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"Vue3-roulette\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>","frontmatter":{"title":"CSS,JS를 이용한 룰렛 구현","date":"2023-06-24","keywords":null,"description":null,"category":"Vue"}},"previous":{"fields":{"slug":"/etc/230622-blog-decoration/"},"frontmatter":{"title":"블로그 꾸미기 일지"}},"next":{"fields":{"slug":"/essay/230625-project-review/"},"frontmatter":{"title":"프로젝트 회고"}}},"pageContext":{"id":"a8c9c6f4-7f2d-5123-959f-2309b211bde7","previousPostId":"e15c6215-c93f-55c5-b8e6-5db9c3680fdf","nextPostId":"40d2e5e6-7b84-5697-8c2a-6851785a7962"}},"staticQueryHashes":["2841359383","3821306223"],"slicesMap":{}}