{"componentChunkName":"component---src-templates-blog-post-js","path":"/vue/230703-start-pinia/","result":{"data":{"site":{"siteMetadata":{"title":"JuHeon's Dev Blog"}},"markdownRemark":{"id":"4cfd0013-23d8-5eeb-9570-2cc56fef66cf","excerpt":"pinia란? 기존 vue의 전역 상태관리 라이브러리는 거의 가 독점하다시피 한 시장이었다. 옆 동네 react만 하더라도 ,,,와 같이 여러 라이브러리 중에서 선택할 수 있었지만, vue에서는 선택권 없이 사실상 9…","html":"<h2>pinia란?</h2>\n<p>기존 vue의 전역 상태관리 라이브러리는 거의 <code class=\"language-text\">vuex</code>가 독점하다시피 한 시장이었다. 옆 동네 react만 하더라도 <code class=\"language-text\">redux</code>,<code class=\"language-text\">recoil</code>,<code class=\"language-text\">MobX</code>,<code class=\"language-text\">zustand</code>와 같이 여러 라이브러리 중에서 선택할 수 있었지만, vue에서는 선택권 없이 사실상 99% <code class=\"language-text\">vuex</code>를 써야했다. 오히려 이 점이 학습에 대한 부담(여러 라이브러리 두루 알고 있어야 함)을 줄여주기도 했지만, vuex의 아쉬운 점을 대체할 수단이 없다는 단점을 껴안고 있었다.</p>\n<p>그러다가 2019년 11월에 <code class=\"language-text\">vuex</code>의 experiment to redesign(리디자인 실험)으로서 <code class=\"language-text\">pinia</code>가 처음 출시되었고, 현재는 <code class=\"language-text\">vuex</code>를 대신하여 vue의 공식 상태관리 라이브러리로 자리잡았다. 이름은 달라졌다고는 해도 <code class=\"language-text\">vuex</code> 개발팀이 <code class=\"language-text\">pinia</code>를 개발했기 때문에 기존 <code class=\"language-text\">vuex</code>의 기능과 문법은 거의 바뀌지 않았고 새로 학습해야할 내용도 부담 없는 수준이다.(공식문서에서는 <code class=\"language-text\">pinia</code>를 <code class=\"language-text\">vuex 5</code>의 다른 이름이라고 소개한다)</p>\n<p><a href=\"https://npmtrends.com/pinia-vs-vuex\">npmtrends</a>를 보더라도 <code class=\"language-text\">vuex</code>와의 격차가 점점 줄어들고 있음을 확인할 수 있다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.177215189873415%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA5UlEQVR42lVRC67EIAj0/jfdZPO2La2KAvMC9LNrMgEHcEAK9w4zgwFpVaCqYaEDlSfenwV6/EE8SSfsgud/15qirOsKa44N1ncY79DwKTkmgAk2GqwtyfMevDWC1eWp7YTSvMPZYTJCwZVU5VF2eIxe2RW+eJ/EY17vvndYaz3bxT1CjJxEQmZMEefi7mef4zWFiFzqJynU1DBFwaJhXWRI4mDB1gVbEyxVsLYZPnVBOWrF3v2iNzKY/s5pP1VAp9+nQkLwF84VEYkOLjhZW8cY8x7bbeucmz+3aSZgZqjavWH/w3+SAyeNoekG7wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"npm trends pinia\"\n        title=\"\"\n        src=\"/static/c5bf99a91716a6dc0ec17d96e55aae29/f058b/npm-trends-pinia.png\"\n        srcset=\"/static/c5bf99a91716a6dc0ec17d96e55aae29/c26ae/npm-trends-pinia.png 158w,\n/static/c5bf99a91716a6dc0ec17d96e55aae29/6bdcf/npm-trends-pinia.png 315w,\n/static/c5bf99a91716a6dc0ec17d96e55aae29/f058b/npm-trends-pinia.png 630w,\n/static/c5bf99a91716a6dc0ec17d96e55aae29/40601/npm-trends-pinia.png 945w,\n/static/c5bf99a91716a6dc0ec17d96e55aae29/78612/npm-trends-pinia.png 1260w,\n/static/c5bf99a91716a6dc0ec17d96e55aae29/1cb21/npm-trends-pinia.png 2586w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2>vuex와 비교해 달라진 점</h2>\n<h4>1. 다중 store</h4>\n<p><code class=\"language-text\">vuex</code>에서 여러 종류의 store를 사용할 경우 일반적으로 modules 디렉토리 밑에 몰아넣고 <code class=\"language-text\">index.js</code>에서 하나로 합쳐주는 방식을 사용하였다.</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">// vuex\nsrc\n└── store\n    ├── index.js\n    └── modules\n        ├── counter.js\n        ├── user.js\n        ├── order.js\n        └── ...</code>\n        </deckgo-highlight-code>\n<p>하지만 <code class=\"language-text\">pinia</code>에서는 다중store를 지원하기 때문에 modules를 사용할 필요가 없어졌다. 따라서 stores 디렉토리 밑에 모든 store를 둘 수 있게 되었다. (개인 선호에 따라 <code class=\"language-text\">stores/index.js</code>를 두어서 기본 설정을 초기화하는 코드를 작성하기도 한다.)</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">// pinia\nsrc\n└── stores\n    ├── counter.js\n    ├── user.js\n    ├── order.js\n    └── ...</code>\n        </deckgo-highlight-code>\n<h4>2. mutation 없이 state의 직접 변경 가능</h4>\n<p>기존 <code class=\"language-text\">vuex</code>에서는 state의 값을 변경하려면 반드시 <code class=\"language-text\">mutation</code>을 통해야 했다.<br>\n가령 <code class=\"language-text\">count</code>라는 state와 이 값을 증가시키는 <code class=\"language-text\">increment</code>라는 함수가 있다고 하자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// vuex\nconst store = createStore({\n  state: {\n    count: 1,\n  },\n  mutations: {\n    increment(state) {\n      state.count++\n    },\n  },\n})</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">count</code>값을 증가시키기 위해서는 반드시 <code class=\"language-text\">mutation</code>에 등록된 함수를 통해서만 접근해야 한다.\n<code class=\"language-text\">store.state.count++</code>처럼 직접적으로 state를 변경시키는 건 허용되지 않았다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// vuex\n&lt;template&gt;\n  &lt;p&gt;{{ $store.state.count }}&lt;/p&gt;\n&lt;/template&gt;\n&lt;script&gt;\n  ...\n  setup(){\n    // store.state.count++; // 직접 변형 불가\n    store.commit(&#39;increment&#39;); // 반드시 mutation을 통해서만 변형\n  }\n&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n<br />\n<br />\n<p>하지만 <code class=\"language-text\">pinia</code>에서는 <code class=\"language-text\">mutation</code>이 사라지고 값의 직접 변형이 가능해졌다. 따라서 매번 state값을 변경하기 위한 <code class=\"language-text\">mutation</code>함수를 만들 필요가 없어졌기 때문에 상당히 편리해졌다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// pinia\nexport const useCounterStore = defineStore(&quot;counter&quot;, {\n  state: () =&gt; {\n    return {\n      count: 1,\n    }\n  },\n})</code>\n        </deckgo-highlight-code>\n<p>그러면 <code class=\"language-text\">counterStore</code>로 받아오기만 하면 된다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// pinia\n&lt;template&gt;\n  &lt;p&gt;{{ counterStore.count }}&lt;/p&gt;\n&lt;/template&gt;\n&lt;script&gt;\n  ...\n  setup(){\n    const counterStore = useCounterStore();\n    counterStore.count++; // 직접 변경 가능\n    return{\n      counterStore,\n    }\n  }\n&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n<p>변경해야 하는 값이 복잡하거나, 따로 함수로 분리하고 싶다면 <code class=\"language-text\">actions</code>에서 선언하거나 혹은 아래에서 설명할 <code class=\"language-text\">$patch</code> 라는 내장 메소드를 사용하면 된다.</p>\n<h4>3. Typescript 호환성 증가</h4>\n<p><code class=\"language-text\">vuex</code>에서는 도입하기 까다로웠던 <code class=\"language-text\">typescript</code>가 <code class=\"language-text\">pinia</code>에서는 쉽게 사용할 수 있게 되었다.</p>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// pinia\ninterface VueLib {\n  state: &quot;vuex&quot; | &quot;pinia&quot;\n}\n\nexport const useCounterStore = defineStore(&quot;counter&quot;, {\n  state: () =&gt; {\n    return {\n      count: 0 as number,\n      library: {\n        state: &quot;pinia&quot;,\n      } as VueLib,\n    }\n  },\n})</code>\n        </deckgo-highlight-code>\n<h2>프로젝트 도입 후기</h2>\n<h4>1. mutation 이 없어서 정말 편리하다</h4>\n<p>위에서 언급했다시피 state값의 직접 변형이 가능하기 때문에 별도의 <code class=\"language-text\">mutation</code>을 선언할 필요가 없다는 점이 <code class=\"language-text\">vuex</code>로 개발하면서 느꼈던 답답함을 한방에 뚫어주는듯한 기분이다. 덕분에 <code class=\"language-text\">store</code> 코드의 절반 가량을 차지하던 부분이 사라졌으니 코드가 상당히 가벼워지고 가독성도 나아졌다.</p>\n<h4>2. 생각보다 유용한 내장 메소드</h4>\n<p><code class=\"language-text\">pinia</code>에서는 Option API 기준으로 3개의 내장 메소드를 갖고 있다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">$reset()</code> : 현재 store의 <code class=\"language-text\">state</code> 값들을 모두 초기화시킨다. 예를 들어 회원 로그인시 회원 데이터를 store에 갖고 있다가 로그아웃을 하면 값을 초기화해주어야 할 때 사용한다. 기존 <code class=\"language-text\">vuex</code>에서는 개발자가 직접 reset함수를 만들어야 했는데 <code class=\"language-text\">pinia</code> 에서는 그럴 필요가 없어졌다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">$patch(state)</code> : state값을 변경시켜주는 함수이다. <code class=\"language-text\">pinia</code>는 값의 직접 변경이 가능한데 왜 굳이 필요한가 싶을 수 있는데, 여러 변수들의 값을 한번(함수 하나)에 변경하려고 할 때나 값의 변경 로직이 복잡해지면 오히려 <code class=\"language-text\">mutation</code>이 그리워 질 수도 있다. <code class=\"language-text\">$patch()</code>함수가 그 역할을 대신한다.</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">counterStore.$patch({ count: 1 })\nOR\ncounterStore.$patch(state =&gt; {\n  state.count = state.count + 1\n})</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code class=\"language-text\">$subscribe(mutation,state)</code> : 현재 store의 <code class=\"language-text\">state</code>값을 <code class=\"language-text\">watch</code>하는 기능이라고 생각하면 된다. 프로젝트에서는 이 기능을 써보지 않아서 정확히 어떤 상황에 필요할 지는 잘 모르겠다.</li>\n</ul>\n<h4>3. modules가 없어져서 코드 양은 쪼금 늘어날 수 있다</h4>\n<p>개인적으로 한가지 아쉬운 점은 모든 store를 하나로 묶어주는 modules 기능의 부재로 인하여 <code class=\"language-text\">vuex</code>의 <code class=\"language-text\">template</code>레벨에서 <code class=\"language-text\">state</code>값을 가져올 때처럼 <code class=\"language-text\">$store.state.[store이름]</code> 식으로 접근할 수 없다는 점이다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// vuex\n&lt;tempalate&gt;\n  &lt;div&gt;{{$store.state.counter.count}}&lt;/div&gt;\n&lt;/template&gt;\n</code>\n        </deckgo-highlight-code>\n<p>하지만 <code class=\"language-text\">pinia</code>에서는 반드시 <code class=\"language-text\">script</code>레벨에서 <code class=\"language-text\">use*Store()</code> 훅을 이용하여 <code class=\"language-text\">*store</code>를 한번 빼와야만 <code class=\"language-text\">template</code>레벨에서도 값을 전달할 수 있다. 그래서 코드의 양이 <code class=\"language-text\">vuex</code>대비 늘어날 수도 있다. 그렇다고 이거 하나가 단점이라 지적하기엔 사소한 문제이고 1,2번에서 얻을 수 있는 이점이 훨씬 더 크다고 생각한다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">// pinia\n&lt;tempalate&gt;\n  &lt;div&gt;{{counterStore.count}}&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n  ...\n  setup(){\n    const counterStore = useCounterStore();\n    return{\n      counterStore,\n    }\n  }\n  &lt;/script&gt;\n</code>\n        </deckgo-highlight-code>\n<h2>총평</h2>\n<p><code class=\"language-text\">pinia</code>는 <code class=\"language-text\">vuex</code>와 비교하여 typescript 지원, mutation 삭제, 다중 store지원 같은 기능으로 인하여 DX(개발 경험)을 상당히 개선시켜 주었다. 커뮤니티와 자료의 양이 아직 <code class=\"language-text\">vuex</code>만큼은 아니지만 조금씩 쌓여나가고 있다는 점에서 <code class=\"language-text\">pinia</code> 도입을 주저하는 개발자가 있다면 주저하지 말고 한번 써보라고 추천하고 싶다.</p>","frontmatter":{"title":"pinia 소개 및 도입 후기","date":"2023-07-04","description":"vuex를 대신할 새로운 상태관리 라이브러리 pinia에 대해","category":"Vue"}},"previous":{"fields":{"slug":"/vue/230702-vmodel-and-custom-component-2/"},"frontmatter":{"title":"v-model 원리와 커스텀 컴포넌트 만들기 (2 of 2)"}},"next":null},"pageContext":{"id":"4cfd0013-23d8-5eeb-9570-2cc56fef66cf","previousPostId":"63ab404b-a503-57f0-b270-7ffba96de4d8","nextPostId":null}},"staticQueryHashes":["2841359383","3821306223"],"slicesMap":{}}